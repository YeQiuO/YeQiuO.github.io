<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>深度学习基础概念</title>
    <url>/DL-basic/</url>
    <content><![CDATA[<h1 id="偏差方差">偏差方差</h1>
<p><a
href="https://www.cnblogs.com/makefile/p/bias-var.html#fn2">参考文章</a></p>
<h2 id="泛化误差">泛化误差</h2>
<p>模型的平方预测误差的期望</p>
<p><span
class="math display">\[Err(\mathbf{x})=E\left[\left(y-f(\mathbf{x};D)\right)^2\right]=\mathbb{E}_D\left[\left(f(\boldsymbol{x};D)-\bar{f}\left(\boldsymbol{x}\right)\right)^2\right]+\left(\bar{f}(\boldsymbol{x})-y\right)^2+\mathbb{E}_D\left[(y_D-y)^2\right]\]</span></p>
<h2 id="方差">方差</h2>
<blockquote>
<p>方差是指模型对于不同训练集的预测结果的波动程度（即泛化能力），<strong>刻画了数据扰动所造成的影响</strong>。高方差意味着模型过于复杂，对训练数据中的噪声和细节过于敏感，表示模型<strong>过拟合</strong></p>
</blockquote>
<p>使用样本数相同的不同训练集产生的方差</p>
<p><span
class="math display">\[\mathrm{var}(\mathbf{x})=\mathrm{E}_\mathrm{D}\left[\left(\mathrm{f}(\mathbf{x};\mathrm{D})-\overline{\mathrm{f}}(\mathbf{x})\right)^2\right]\]</span></p>
<p>其中，算法 𝑓 对测试样本 𝑥 的期望预测（不同训练集 𝐷 上模型 𝑓
对测试样本 𝑥 的预测输出的期望）<span
class="math inline">\(\overline{f}(\mathbf{x})=E_D[f\left(\mathbf{x};D\right)]\)</span></p>
<h2 id="偏差">偏差</h2>
<blockquote>
<p>偏差是指模型的预测值与真实值之间的差异，<strong>模型本身的拟合能力</strong>。高偏差意味着模型过于简单，无法捕捉到数据的复杂模式，表示模型<strong>欠拟合</strong></p>
</blockquote>
<p>期望预测与真实标记的误差</p>
<p><span
class="math display">\[\mathrm{bias}^2(\mathbf{x})=\left(\overline{\mathrm{f}}(\mathbf{x})-\mathrm{y}\right)^2\]</span></p>
<h2 id="噪声">噪声</h2>
<blockquote>
<p>表达了当前任务上任何模型所能达到的期望泛化误差的下界，<strong>刻画了学习问题本身的难度</strong>。</p>
</blockquote>
<p>真实标记与数据集中的实际标记间的偏差</p>
<p><span
class="math display">\[\varepsilon^2=E_D\left[(y_D-y)^2\right]\]</span></p>
<h2 id="偏差-方差窘境">偏差-方差窘境</h2>
<img data-src="/DL-basic/606386-20180722194316424-288674381.png" class="" title="bias-variance-tradeoff">
<ul>
<li>偏向左侧时，训练数据的扰动不足以使学习器产生显著变化，此时偏差主导泛化误差，称为<strong>欠拟合现象</strong>
<ul>
<li>增加模型的迭代次数；更换描述能力更强的模型；生成更多特征供训练使用；降低正则化水平</li>
</ul></li>
<li>偏向右侧时，模型的拟合能力非常强，数据轻微变化都能导致模型发生变化，如果过分学习训练数据的特点，则会发生<strong>过拟合现象</strong>
<ul>
<li>扩增训练集；减少训练使用的特征的数量；降低模型复杂度；提高正则化水平</li>
</ul></li>
</ul>
<p>为了解决“偏差和方差在一定程度上是有冲突的”的问题，可以采用K折交叉验证或正则化，它们分别从数据划分和模型复杂度两个角度入手，提升模型的泛化能力和稳健性：</p>
<ul>
<li>K折交叉验证通过多次划分和验证，减少因数据划分不当而导致的性能估计偏差</li>
<li>正则化在损失函数中加入一个与模型复杂度相关的惩罚项，以限制模型的复杂度并防止过拟合
<a href="https://www.cnblogs.com/zingp/p/10375691.html">参考文章</a>
<ul>
<li>L1正则化是指权值向量w中各个元素的绝对值之和，可以使得参数稀疏化，即得到的参数是一个稀疏矩阵，进而可以用于特征选择。二维平面图像：<img data-src="/DL-basic/o_L1.png" class="" title="image"></li>
<li>L2正则化是指权值向量w中各个元素的平方和然后再求平方根，让权值尽可能小，如果参数足够小，数据偏移得多一点也不会对结果造成什么影响，专业一点的说法是<strong>抗扰动能力强</strong>。二维平面图像：<img data-src="/DL-basic/o_L2.png" class="" title="image"></li>
</ul></li>
</ul>
<h1 id="模型训练">模型训练</h1>
<h2 id="优化器">优化器</h2>
<p>Adam：自适应学习率，通过计算梯度的一阶矩（均值）和二阶矩（未中心化的方差）来调整学习率</p>
<p>AdamW：带有权重衰减和学习率预热的Adam优化器。改进了Adam，将权重衰退和梯度更新解耦，把L2正则化移到权重更新时而不是梯度计算时</p>
<h1 id="训练方法">训练方法</h1>
<h2 id="监督学习">监督学习</h2>
<p>训练数据既有特征(feature)又有标签(label)，通过训练，让机器可以自己找到特征和标签之间的联系，在面对只有特征没有标签的数据时，可以判断出标签。</p>
<h2 id="无监督学习">无监督学习</h2>
<p>数据只有特征(feature)无标签(label)，是一种机器学习的训练方式，它本质上是一个统计手段，在没有标签的数据里可以发现潜在的一些结构的一种训练方式。</p>
<h2 id="半监督学习">半监督学习</h2>
<p>利用同时包含有标签和无标签的数据来构建一个模型，使得模型能够在测试阶段更好地泛化到新的、未见过的数据。</p>
<h2 id="强化学习">强化学习</h2>
<p>让一个智能体（agent）在环境（Enviroment）中通过尝试和错误来学习行为（Action）策略。智能体通过与环境进行交互，根据奖励信号来调整其行为策略，以达到最大化累积奖励的目标。</p>
<p>针对 PPO 算法的优化：</p>
<ul>
<li>归一化奖励分数、将奖励分数做白化处理</li>
</ul>
<img data-src="/DL-basic/overview_chatgpt.png" class="" title="overview_chatgpt">
<h3 id="rlhf">RLHF</h3>
<blockquote>
<p>Reinforcement Learning from Human
Feedback，以<strong>强化学习方式依据人类反馈优化语言模型</strong>，是
OpenAI 提出的生成领域（Decoder_only）的新训练范式</p>
</blockquote>
<p>Policy Gradient</p>
<style>.xysdkalxuyye{zoom:50%;}</style>
<img data-src="/DL-basic/image-20240716101748533.png" class="xysdkalxuyye" alt="image-20240716101748533">
<p>RM+PPO</p>
<p>步骤一、预训练语言模型</p>
<style>.aftibgceldpy{zoom: 50%;}</style>
<img data-src="/DL-basic/image-20240715191912939.png" class="aftibgceldpy" alt="image-20240715191912939">
<p>步骤二、训练奖励模型 RM</p>
<style>.dfrpyjfntebn{zoom: 50%;}</style>
<img data-src="/DL-basic/image-20240715191936226.png" class="dfrpyjfntebn" alt="image-20240715191936226">
<p>步骤三、用强化学习 PPO 微调</p>
<style>.fpgqhxjhmlbn{zoom:50%;}</style>
<img data-src="/DL-basic/image-20240715192056550.png" class="fpgqhxjhmlbn" alt="image-20240715192056550">
<p>DPO</p>
<p>KTO</p>
<p>ORPO</p>
<h1 id="损失函数">损失函数</h1>
<p>MSELoss 回归任务</p>
<p>CrossEntropyLoss 单标签分类</p>
<p>BCEWithLogitsLoss 多标签分类</p>
<h1 id="torch">Torch</h1>
<p><code>torch.nn.Parameter()</code>将一个不可训练的 tensor
转换成可以训练的类型 parameter，并将这个 parameter 绑定到这个 module
里面</p>
]]></content>
      <categories>
        <category>LLM基础</category>
      </categories>
      <tags>
        <tag>深度学习基础</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/Design-Pattern/</url>
    <content><![CDATA[<h1 id="单例模式">单例模式</h1>
<p>双重校验锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//类对象加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="模板方法模式">模板方法模式</h1>
<blockquote>
<p>抽象出步骤的执行顺序作为抽象方法，具体的实现方法交给子类实现</p>
</blockquote>
<p>实现 AQS 抽象类的锁，需要重写 CLH 锁的
<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>、<code>isHeldExclusively</code>
方法。</p>
<p>重写钩子方法，可以自定义 <code>state</code>
的含义：值为多少时代表加锁成功/失败 or
解锁成功/失败，也可以实现共享锁或独占锁。</p>
<h1 id="观察者模式">观察者模式</h1>
<p>具体查看 JUC_Lock 博客的 <code>CompletableFuture</code>
的底层实现</p>
<h1 id="适配器模式">适配器模式</h1>
<p>具体查看 SpringMVC 博客的 <code>HandlerAdapter</code> 的底层实现</p>
<p>开闭原则：新增代替修改</p>
]]></content>
      <categories>
        <category>编程思想</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构和算法</title>
    <url>/Java-Algorithm/</url>
    <content><![CDATA[<h1 id="算法">算法</h1>
<h2 id="链表">链表</h2>
<h3 id="快慢指针">快慢指针</h3>
<p>链表倒数第n个数</p>
<h3 id="分治法">分治法</h3>
<p>排序</p>
<h2 id="二分查找">二分查找</h2>
<p>【1】目标不存在于数组中，找第一个大于它的下标</p>
<p>【2】有多个目标存在于数组中，找第一个等于它的下标</p>
<p>【思路】基于二分查找，优化寻找 mid 指针和收敛 left right
指针的步骤，具体问题具体分析</p>
<ul>
<li>mid=(left+right)&gt;&gt;2；if
(nums[left]<strong>&lt;</strong>nums[mid]) left=mid<strong>+1</strong>;
else right=mid;【找左边】</li>
<li>mid=(left+right<strong>+1</strong>)&gt;&gt;2；if
(nums[left]<strong>&lt;=</strong>nums[mid]) left=mid; else
right=mid<strong>-1</strong>;【找右边】</li>
</ul>
<h2 id="堆排序">堆排序</h2>
<p>数组实现大根堆的两个主要方法（注意动态扩容）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Heap</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] data;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">downHeapify</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="comment">// 下标从0开始，子节点下标为2i+1和2i+2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> i*<span class="number">2</span> + <span class="number">1</span>, r = i*<span class="number">2</span> + <span class="number">2</span>, largest = i;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; heapSize &amp;&amp; data[l] &gt; data[largest]) &#123;</span><br><span class="line">            largest = l;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (r &lt; heapSize &amp;&amp; data[r] &gt; data[largest]) &#123;</span><br><span class="line">            largest = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            swap(i, largest);</span><br><span class="line">            maxHeapify(largest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">upHeapify</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="comment">// 父节点下标为(i-1)/2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (i-<span class="number">1</span>)/<span class="number">2</span>, min = i;</span><br><span class="line">        <span class="keyword">if</span> (parent&gt;=<span class="number">0</span> &amp;&amp; data[parent] &lt; data[i]) &#123;</span><br><span class="line">            min = parent;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">            swap(min, i);</span><br><span class="line">            upHeapify(min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态规划">动态规划</h2>
<p>思路：动规的中心思想就是把一个复杂问题拆分成多个简单、可以逐步堆叠得到答案的子问题。</p>
<p>做题步骤</p>
<ol type="1">
<li>确定dp数组（dp table）以及下标的含义</li>
<li>确定递推公式</li>
<li>dp数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ol>
<h3 id="背包">0-1背包</h3>
<blockquote>
<p>每个物品只能用一次</p>
</blockquote>
<p>下标含义：dp[物品 i ][容量 j ] 。如果
物品价值==物品种类，dp数组可以直接用 boolean[][]，不相等用 int[][]</p>
<p>状态转移方程：<code>dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]]</code></p>
<p>初始化：物品 0 和容量 0 的情况</p>
<p>遍历顺序：二维数组先遍历物品和容量都可以，一维数组只能先遍历容量</p>
<h3 id="树形-dp">树形 dp</h3>
<p>题型：<strong>树的直径</strong></p>
<p>思路：可以看作是再求树的深度，在求深度的同时“更新树的最长直径”。</p>
<p>代码模板</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LongestPath</span> &#123;</span><br><span class="line">    List&lt;Integer&gt;[] g;</span><br><span class="line">    <span class="type">int</span> <span class="variable">longestPath</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 两种思路：1.记录最大和次大长的路径；2.记录最大长 max，max+当前结果 和 result 比大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> child:g[x]) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> dfs(child) + <span class="number">1</span>;</span><br><span class="line">            longestPath = Math.max(longestPath, max + cur);</span><br><span class="line">            max = Math.max(max, cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] relate = &#123;-<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;  <span class="comment">// 边的关系(题目给出)</span></span><br><span class="line">        <span class="comment">// 构建关系，List 存儿子节点，可以拓展到一般树的情况</span></span><br><span class="line">        g = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[relate.length];</span><br><span class="line">        Arrays.setAll(g, e -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;relate.length; i++) &#123;</span><br><span class="line">            g[relate[i]].add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        System.out.println(longestPath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拓展：</p>
<ul>
<li>【124】求二叉树中最大的路径和。改左右子树的深度为节点值的和，若和为负数则返回
0</li>
<li>【2245】一般树的最长路径。遍历所有邻居（过滤掉父节点），取最长、次长两条路径相加，结果为最长路径。此外，根据题意还要去除父子结点相同的情况。</li>
</ul>
<p>题型：<strong>树上最大独立集</strong>（从图中选择尽量多的点，使得这些点互不相邻）</p>
<p>题型：<strong>树上最小支配集</strong>（从图中选择尽量少的点，使得这些点和其父子结点包括了整棵树）</p>
<h3 id="二维-dp">二维 dp</h3>
<p>题型：最长公共子序列</p>
<p>思路：定义 <code>dp[i][j]</code> 表示 <code>text1[0:i-1]</code> 和
<code>text2[0:j-1]</code> 的最长公共子序列</p>
<h2 id="前缀和">前缀和</h2>
<blockquote>
<p>应用题型：连续子数组</p>
</blockquote>
<h2 id="并查集">并查集</h2>
<blockquote>
<p>应用题型：检查树是否连通；构造最小生成树</p>
<p>扩展：带权并查集</p>
</blockquote>
<p>数据结构模板</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] tab;</span><br><span class="line">    Node (<span class="type">int</span> size) &#123;</span><br><span class="line">        <span class="built_in">this</span>.tab = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i==tab[i] ? i : (tab[i] = find(tab[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        tab[find(x)] = find(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="java-技巧">Java 技巧</h1>
<p>强制类型转换</p>
<ul>
<li>向零截断，直接保留整数位 <code>1/2 == -1/2 == 0</code></li>
</ul>
<p>基本数据类型的默认值</p>
<ul>
<li>int  double：0</li>
<li>boolean：false</li>
</ul>
<p>常量池</p>
<ul>
<li>包装类型常量池：Byte, Short, Integer [-128,127], Long, Character,
Boolean</li>
<li>字符串常量池</li>
</ul>
<p>初始化</p>
<ul>
<li>成员变量（定义在类里方法外的变量）一定要进行初始化的，如果不显式的进行初始化，那么虚拟机会进行默认的初始化
<ul>
<li>基本数据类型一般是给予默认值</li>
<li>引用类型初始值为 null</li>
</ul></li>
<li>局部变量不会自动初始化，所以在声明局部变量时要注意，可以不在声明时初始化，但在使用之前一定要进行初始化，否则会报编译错误</li>
</ul>
<h2 id="数组列表快速初始化">数组、列表快速初始化</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>[][] array = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);  <span class="comment">// 返回的是Arrays的内部类【无法增删】</span></span><br><span class="line">List&lt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()&#123;&#123;</span><br><span class="line">    add(<span class="number">1</span>);</span><br><span class="line">    add(<span class="number">2</span>);</span><br><span class="line">    add(<span class="number">3</span>);</span><br><span class="line">&#125;&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="初始化小根堆">初始化小根堆</h2>
<p>使用优先级队列 <code>PriorityQueue</code> 实现小根堆</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((pair1,pair2) -&gt; pair1[<span class="number">1</span>]-pair2[<span class="number">1</span>]);  <span class="comment">// 数组</span></span><br><span class="line">PriorityQueue&lt;ListNode&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; o1.val-o2.val);  <span class="comment">// 节点</span></span><br><span class="line"></span><br><span class="line">queue.offer(data)  <span class="comment">// 节点入堆</span></span><br><span class="line">data = queue.poll()  <span class="comment">// 头节点出堆</span></span><br></pre></td></tr></table></figure>
<h2 id="list-转数组">List 转数组</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本数据类型需要手动拆箱</span></span><br><span class="line"><span class="type">int</span>[] array = list.stream().mapToInt(Integer::valueOf).toArray();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 流式</span></span><br><span class="line">String[] array = list.stream().toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line"><span class="comment">// 串行【规定好数组大小，zhuan&#x27;hua速度更快】</span></span><br><span class="line">String[] array = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[list.size()]);</span><br><span class="line">String[] array = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<h2 id="数组转-list">数组转 List</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本数据类型需要手动装箱</span></span><br><span class="line"><span class="type">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">List&lt;Integer&gt; list = Arrays.stream(arr).boxed().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] integers = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">3</span>,<span class="number">8</span>,<span class="number">20</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">25</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(integers); </span><br><span class="line"><span class="comment">// ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">// Collections.addAll(list, a);</span></span><br></pre></td></tr></table></figure>
<h2 id="位运算值交换">位运算值交换</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ch[a] ^= ch[b];</span><br><span class="line">ch[b] ^= ch[a];</span><br><span class="line">ch[a] ^= ch[b];</span><br></pre></td></tr></table></figure>
<h2 id="泛型占位符">泛型&amp;占位符</h2>
<p>泛型：T E K V &gt;
泛型的初衷就是为了能在编译器检查出类型安全问题，并通过编译错误提示程序员</p>
<ul>
<li>泛型必须是引用类型，不能是基本类型</li>
<li>泛型通过类型擦除实现</li>
</ul>
<p>占位符：?</p>
<p>TODO lambda stream 流式计算 详解</p>
<h2 id="位运算判断奇偶">位运算判断奇偶</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">num &amp; <span class="number">1</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="十进制数转-char">十进制数转 char</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">t</span> <span class="operator">=</span> Character.forDigit(i, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h2 id="collection-转-list">Collection 转 List</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;T&gt; collection = map.values();</span><br><span class="line">List&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;T&gt;(collection);</span><br></pre></td></tr></table></figure>
<h2 id="map-遍历方法">Map 遍历方法</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Key.class, Value.class&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;key= &quot;</span> + entry.getKey() + <span class="string">&quot; and value= &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在条件语句中赋值">在条件语句中赋值</h2>
<p>不能直接在 <code>if</code> 语句的条件部分进行声明和赋值，需要在
<code>if</code> 语句之前声明变量，并在条件语句中只进行赋值或比较操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> dis;  </span><br><span class="line"><span class="keyword">if</span> ((dis = i - dp[i - <span class="number">1</span>]) &gt; <span class="number">1</span> &amp;&amp; s.charAt(dis - <span class="number">2</span>) == <span class="string">&#x27;(&#x27;</span>) &#123;  </span><br><span class="line">    <span class="comment">// ... 使用 dis 进行操作 ...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="stringbuilderstringbuffer-常用方法">StringBuilder/StringBuffer
常用方法</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.append(char c) // 将 char 追加到此序列</span><br><span class="line">s.charAt(int index) // 返回指定索引处的此序列中的 char 值</span><br><span class="line">s.deleteCharAt(int index) // 按此顺序删除指定位置的 char</span><br><span class="line">s.setCharAt(int index, char ch) // 指定索引处的字符设置为 ch</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程思想</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Faiss 向量数据库</title>
    <url>/Faiss/</url>
    <content><![CDATA[<h1 id="faiss-索引类型">Faiss 索引类型</h1>
<p><a
href="https://github.com/facebookresearch/faiss/blob">官方教程</a></p>
<h2 id="平面索引-flat">平面索引 FLAT</h2>
<p>平面索引就是暴力搜索，将 <code>queries</code> 于
<code>database</code>中的所有向量计算，时间复杂度是 <span
class="math inline">\(O({n^2})\)</span>。</p>
<p>不同索引计算相似度的方法不同，<code>IndexFlatIP</code>
是点积，<code>IndexFlatL2</code> 是 L2
距离，如果需要计算余弦相似度则需要在点积前 L2 归一化
<code>faiss.normalize_L2(vector)</code>，L2 归一化公式为 <span
class="math inline">\(\mathbf{X}=\left(\frac{x_1}{\left\|\mathbf{x}\right\|},\frac{x_2}{\left\|\mathbf{x}\right\|},\cdots,\frac{x_n}{\left\|\mathbf{x}\right\|}\right)\)</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">index = faiss.IndexFlatL2(d)</span><br><span class="line">index.add(database)</span><br><span class="line">D, I = index.search(queries[:<span class="number">5</span>], k)</span><br></pre></td></tr></table></figure>
<p><span class="math inline">\(D\)</span>
表示具体的相似度<code>D.shape = (query_len, similarity)</code>，取值范围是
[0, 1]</p>
<p><span class="math inline">\(I\)</span> 表示与 <span
class="math inline">\(D\)</span> 相对应的索引
<code>I.shape = (query_len, index)</code>，取值范围是 [0, data_num]</p>
<h2 id="分区索引-ivf">分区索引 IVF</h2>
<p>对索引数据进行分区优化，将数据通过“沃罗诺伊图单元”（也被叫做泰森多边形）来进行切割（类似传统数据库分库分表）。在搜索时，仅将查询
queries 所在单元中包含的数据库向量 database
以及一些相邻的向量与查询向量进行比较，找到 queries
向量所属的泰森多边形单元就是在<strong>质心集中找到该向量的最近邻居</strong>。</p>
<p><code>index.train()</code>训练了一个聚类模型，如
K-means。生成多个聚类中心，聚类的数量由索引的 <code>nlist</code>
参数决定。</p>
<p>倒排索引（IVF）把“文档→单词”的形式变为“单词→文档”的形式。</p>
<p><code>search</code> 有两个参数： <code>nlist</code> （单元格数量）和
<code>nprobe</code>
（为执行搜索而访问的质心集单元数量，在<code>nlist</code>之外），设置
<code>nprobe = nlist</code> 给出与暴力搜索相同的结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">quantizer = faiss.IndexFlatL2(d)</span><br><span class="line">index = faiss.IndexIVFFlat(quantizer, d, nlist, faiss.METRIC_L2)</span><br><span class="line">index.train(database)</span><br><span class="line">index.add(database)</span><br><span class="line">index.nprobe = <span class="number">10</span></span><br><span class="line">D, I = index.search(queries, k)</span><br></pre></td></tr></table></figure>
<h2 id="量化索引-pq">量化索引 PQ</h2>
<p>基于乘积量化器的有损压缩来压缩存储的向量，压缩方法和量化级别参考<a
href="https://inria.hal.science/file/index/docid/514462/filename/paper_hal.pdf">论文</a>。</p>
<p>建立索引时：</p>
<ul>
<li>向量被分配到最近的聚类（同 IVF）</li>
<li>每个向量被划分为 m
个子向量，分别在各自的子空间中进行量化，存储为对应的量化代码</li>
</ul>
<p>查询时：</p>
<ul>
<li>查询向量通过倒排索引（IVF） 来确定最接近的聚类中心</li>
<li>查询向量被划分为 m 个子向量</li>
<li>查询子向量与存储的量化代码进行匹配，基于每个子空间的距离查表来计算近似距离</li>
<li>将所有子空间的距离相加，得到查询向量与候选向量的总距离</li>
</ul>
<p>这个例子，将 64 个 32 位浮点数压缩为 8 个字节，因此压缩因子为
32。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># d 必须是 m 的倍数</span></span><br><span class="line">quantizer = faiss.IndexFlatL2(d)</span><br><span class="line"><span class="comment"># 量化器数量 m、指定每个子向量编码为 8 byte(32 bit)</span></span><br><span class="line">index = faiss.IndexIVFPQ(quantizer, d, nlist, m, <span class="number">8</span>)</span><br><span class="line"><span class="comment"># 可以简写为 index = faiss.index_factory(d, &quot;IVF100,PQ8&quot;)</span></span><br><span class="line">index.train(database)</span><br><span class="line">index.add(database)</span><br><span class="line">index.nprobe = <span class="number">10</span></span><br><span class="line">D, I = index.search(queries, k)</span><br></pre></td></tr></table></figure>
<h1 id="功能">功能</h1>
<h2 id="索引的量化功能">索引的量化功能</h2>
<p>对向量进行编码量化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">index.sa_encode(vectors)</span><br></pre></td></tr></table></figure>
<p>针对非量化索引，也会返回 <code>uint8</code>
类型的更紧凑的离散表示</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">xq[0][:5]</span><br><span class="line"><span class="params">##</span> array([0.81432974, 0.7409969 , 0.8915324 , 0.02642949, 0.24954738], dtype=float32)</span><br><span class="line">index.sa<span class="built_in">_</span>encode(xq[:1, :])[0, :5]</span><br><span class="line"><span class="params">##</span> array([ 93, 234, 119,  80,  63], dtype=uint8)</span><br></pre></td></tr></table></figure>
<h2 id="获取原始数据向量">获取原始数据/向量</h2>
<p>基于根据 index</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">index.reconstruct(vector_id)</span><br></pre></td></tr></table></figure>
<p>为了追求更快的查询性能，IndexIVF 和向量 ID IndexBinaryIVF
都存储在倒排列表中，无法通过向量 ID
来反查索引中的内容，如果我们想要得到某个数据的内容，需要手动重建索引</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">index.make_direct_map()</span><br><span class="line">index.reconstruct(vector_id)</span><br></pre></td></tr></table></figure>
<h2 id="获取原文档">获取原文档</h2>
<p>FAISS 内置了 <code>docstore</code> 和
<code>index_to_docstore_id</code> ，在每次加入向量时同时存储 doc
内容，且以字典的形式储存 index 与 doc
的映射关系，方便后续查找原文档。</p>
<h1 id="bm25-实现">BM25 实现</h1>
<p>额外记录一下 <code>BM25</code> 的实现方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">from</span> langchain.schema <span class="keyword">import</span> Document</span><br><span class="line"><span class="keyword">from</span> langchain_community.retrievers <span class="keyword">import</span> BM25Retriever</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_bm25_retriever</span>(<span class="params">docs, top_k</span>):</span><br><span class="line">    bm25_retriever = BM25Retriever.from_documents(</span><br><span class="line">        docs,</span><br><span class="line">        preprocess_func=jieba.lcut_for_search,</span><br><span class="line">    )</span><br><span class="line">    bm25_retriever.k = top_k</span><br><span class="line">    <span class="keyword">return</span> bm25_retriever</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    docs = [</span><br><span class="line">        Document(page_content=<span class="string">&quot;这是一篇关于机器学习的文档。&quot;</span>),</span><br><span class="line">        Document(page_content=<span class="string">&quot;自然语言处理是人工智能的一个重要领域。&quot;</span>),</span><br><span class="line">        Document(page_content=<span class="string">&quot;深度学习是机器学习的一个子集。&quot;</span>),</span><br><span class="line">    ]</span><br><span class="line">    top_k = <span class="number">2</span></span><br><span class="line">    bm25_retriever = create_bm25_retriever(docs, top_k)</span><br><span class="line">    query = <span class="string">&quot;机器学习&quot;</span></span><br><span class="line">    results = bm25_retriever.get_relevant_documents(query)</span><br><span class="line">    <span class="keyword">for</span> rank, doc <span class="keyword">in</span> <span class="built_in">enumerate</span>(results, start=<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Rank <span class="subst">&#123;rank&#125;</span>: <span class="subst">&#123;doc&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>Debug 查看分词结果
<code>bm25_retriever.vectorizer.doc_freqs</code></p>
<img data-src="/Faiss/image-20240911200426522.png" class="" title="image-20240911200426522">
]]></content>
      <categories>
        <category>LLM开发</category>
      </categories>
      <tags>
        <tag>faiss</tag>
      </tags>
  </entry>
  <entry>
    <title>LLM 应用开发实践</title>
    <url>/LLM-Application/</url>
    <content><![CDATA[<p>实验室项目对话模块的主要工作和创新点，先大致记录一下思路，后续慢慢完善</p>
<h1 id="何为llm应用开发">何为LLM应用开发</h1>
<p>网上不少人认为，与其去做 Prompt 应用不如去提升 LLM 的智能，Prompt
应用对于大语言模型能力提升的作用有限。但我不以为然，获得 Prompt
的加持之后，LLM
可以<strong>应用现实生活的所有工具</strong>；可以<strong>按步骤正确处理一个复杂问题</strong>（因为
LLM
不同于人类对话，只有构造出非常详细且周密的过程约束，才能得到最正确的答案，不然会出现“幻觉”现象）；可以引导
<strong>LLM 自我规划</strong>（下文的长文本对话），目前 Prompt
最常应用在 <code>Dynamic Few-Shot Examples</code> 领域中，可以快速定位与
Query 最相关的小样本，不使不相关的内容分散 LLM
的注意力，而不只局限于“聊天机器人”和“搜索引擎”这类看似没啥么太大用处的名头。</p>
<p>一言以蔽之，应用开发就是将 LLM
聪明的大脑装上可随时替换的手脚、五官和前额叶、海马体，它可以变成任何人，使用任何工具。</p>
<h1 id="长文本对话">长文本对话</h1>
<h2 id="问题背景">问题背景</h2>
<p>虽然模型都支持32k的上下文，但是无法要求模型一次性输出超长文本。若给模型输入：“给我讲讲中国五千年历史，字数不得少于五千”，是无法得到想要的回答，模型最多生成一两千的字，而且由于所有输出都是一次返回的，上下文逻辑和内容都不尽人意。</p>
<h2 id="解决思路">解决思路</h2>
<p>先调用模型生成一次大纲，再拆分大纲分批次输入模型，每次模型的输出只需要关注一小块内容，因此可以获得更优结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">OutlinePrompt = ChatPromptTemplate.from_template(<span class="string">f&#x27;请根据<span class="subst">&#123;query&#125;</span>，按照以下格式对问题提炼目录。回答内容尽量简短\n \</span></span><br><span class="line"><span class="string">            开始生成大纲:\n \</span></span><br><span class="line"><span class="string">            1. XXX\n    1.1xxx 1.2xxx 1.3xxx ...\n  \</span></span><br><span class="line"><span class="string">            2. XXX\n    2.1xxx 2.2xxx 2.3xxx ...\n  \</span></span><br><span class="line"><span class="string">            .......\n&#x27;</span>)</span><br><span class="line">chain = LLMChain(prompt=OutlinePrompt, llm=model1, memory=<span class="literal">None</span>, verbose=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>由于需要<strong>结构化解析</strong>输出结果并<strong>链式调用</strong>模型扩写子论点，采用结构化输出解析器
<code>from langchain.output_parsers import StructuredOutputParser, ResponseSchema</code>
和模型调用链
<code>from langchain.chains import SimpleSequentialChain, SequentialChain</code>
，该方法相较于直接 for
循环调用模型更加麻烦，但是便于整体项目的开发、调用和维护。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chat_prompt = PromptTemplate.from_template(<span class="string">f&#x27;请以<span class="subst">&#123;title&#125;</span>的<span class="subst">&#123;contexts&#125;</span>为主要内容，帮我扩写到<span class="subst">&#123;num&#125;</span>字&#x27;</span>)</span><br><span class="line">combined_prompt = PromptTemplate.from_template(<span class="string">f&#x27;写一段过渡段，从<span class="subst">&#123;title&#125;</span>自然过渡到<span class="subst">&#123;next_title&#125;</span>，内容简短&#x27;</span>)</span><br><span class="line">chat_chain = LLMChain(llm=llm, prompt=chat_prompt, output_key=<span class="string">&quot;chat&quot;</span>)</span><br><span class="line">combined_chain = LLMChain(llm=llm, prompt=combined_prompt, output_key=<span class="string">&quot;combined&quot;</span>)</span><br><span class="line">single_chain = SequentialChain(</span><br><span class="line">    chains=[chat_chain, combined_chain], </span><br><span class="line">    input_variables=[<span class="string">&quot;title&quot;</span>, <span class="string">&quot;contexts&quot;</span>, <span class="string">&quot;num&quot;</span>, <span class="string">&quot;next_title&quot;</span>],</span><br><span class="line">    output_variables=[<span class="string">&quot;chat&quot;</span>, <span class="string">&quot;combined&quot;</span>],</span><br><span class="line">    verbose=<span class="literal">True</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>目前还是通过 for 循环遍历大纲，后续考虑采用路由链
<code>LLMRouterChain</code>，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">router_prompt = PromptTemplate(</span><br><span class="line">    template=router_template,</span><br><span class="line">    input_variables=[<span class="string">&quot;input&quot;</span>],</span><br><span class="line">    output_parser=RouterOutputParser(),</span><br><span class="line">)</span><br><span class="line">chain = MultiPromptChain(</span><br><span class="line">    router_chain=router_chain,    <span class="comment"># 路由链路</span></span><br><span class="line">    destination_chains=destination_chains,   <span class="comment"># 目标链路（LLmChain 数组）</span></span><br><span class="line">    default_chain=default_chain,      <span class="comment"># 默认链路</span></span><br><span class="line">    verbose=<span class="literal">True</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h1 id="私有数据知识库">私有数据知识库</h1>
<h2 id="问题背景-1">问题背景</h2>
<p>离线私有数据不能直接作为语料库训练模型，LLM
需要具有基于私有数据返回的能力。</p>
<h2 id="解决思路-1">解决思路</h2>
<p>知识库系统要包括文档加载、切分、存储、检索和存储聊天记录模块，具体通过向量表征
<code>Embeddings</code> 和向量存储 <code>Vector Store</code> 实现</p>
<ul>
<li>文本表征是对文本语义的向量表征，相似内容的文本具有相似的表征向量。这使我们可以在向量空间中比较文本的相似性。</li>
<li>向量数据库<code>Vector Database</code>用来存储文档的文本块。对于给定的文档，我们首先将其分成较小的文本块<code>chunks</code>，然后获取每个小文本块的文本表征，并将这些表征储存在向量数据库中。这个流程正是创建索引<code>index</code>的过程。将文档分成小文本块的原因在于我们可能无法将整个文档传入语言模型进行处理。</li>
</ul>
<img data-src="/LLM-Application/image-20240424102449161.png" class="" title="image-20240424102449161">
<p>Langchain 中文本分割器 <code>langchain.text_splitter</code> 都根据
chunk_size(块大小) 和 chunk_overlap(块与块之间的重叠大小) 进行分割</p>
<ul>
<li>chunk_size 指每个块包含的字符或 Token（如单词、句子等）的数量</li>
<li>chunk_overlap
指两个块之间共享的字符数量，用于保持上下文的连贯性，避免分割丢失上下文信息</li>
</ul>
<style>.npwbxubefsjv{zoom:50%;}</style>
<img data-src="/LLM-Application/image-20240424102824838.png" class="npwbxubefsjv" alt="langchain.text_splitter">
<p><strong>Q1</strong>：如何加强搜索结果的多样性？</p>
<p><strong>A1</strong>：最大边际相关性
<code>Maximum marginal relevance</code>
，过滤搜索结果中相似度很高的文档，可以同时满足查询的相关性和结果的多样性</p>
<p><strong>Q2</strong>：如何将查询限定在某些文档中？如 LLM
在查询时可能同时查找
浙江省财政报告、江苏省财政报告，但问题只与浙江省相关</p>
<p><strong>A2</strong>：通过 <code>SelfQueryRetriever</code> 参数
<code>document_content_description</code>
指定元素的不同字段（source）以及它们对应的位置（page）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">metadata_field_info_chinese = [</span><br><span class="line">    AttributeInfo(</span><br><span class="line">        name=<span class="string">&quot;source&quot;</span>,</span><br><span class="line">        description=<span class="string">&quot;文章来源于 `index-浙江省财政报告`, `index-江苏省财政报告` 的其中之一&quot;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="string">&quot;string&quot;</span>,</span><br><span class="line">    ),</span><br><span class="line">    AttributeInfo(</span><br><span class="line">        name=<span class="string">&quot;page&quot;</span>,</span><br><span class="line">        description=<span class="string">&quot;文章中的哪一页&quot;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="string">&quot;integer&quot;</span>,</span><br><span class="line">    ),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>Q3</strong>：如何通过过获取到的文档得到 LLM 响应</p>
<p><strong>A3</strong>：采用 检索式问答链 <code>RetrievalQA</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">template = <span class="string">&quot;&quot;&quot;使用以下上下文片段来回答最后的问题。如果你不知道答案，只需说不知道，不要试图编造答案。答案最多使用三个句子。尽量简明扼要地回答。在回答的最后一定要说&quot;感谢您的提问！&quot;</span></span><br><span class="line"><span class="string">&#123;context&#125;</span></span><br><span class="line"><span class="string">问题：&#123;question&#125;</span></span><br><span class="line"><span class="string">有用的回答：&quot;&quot;&quot;</span></span><br><span class="line">QA_CHAIN_PROMPT = PromptTemplate.from_template(template)</span><br><span class="line"><span class="comment"># RetrievalQA 内部使用了 QA_CHAIN_PROMPT</span></span><br><span class="line">qa_chain = RetrievalQA.from_chain_type( </span><br><span class="line">    llm,</span><br><span class="line">    retriever=vectordb.as_retriever()</span><br><span class="line">)</span><br><span class="line">result = qa_chain(&#123;<span class="string">&quot;query&quot;</span>: question&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>Q4</strong>：如果文档太多，无法将它们全部适配到上下文窗口中怎么办？</p>
<p><strong>A4</strong>：采用
<code>MapReduce</code>，首先将每个独立的文档单独发送到语言模型以获取原始答案。然后，将答案通过最终对语言模型的一次调用组合成最终的答案</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">qa_chain_mr = RetrievalQA.from_chain_type(</span><br><span class="line">    llm,</span><br><span class="line">    retriever=vectordb.as_retriever(),</span><br><span class="line">    chain_type=<span class="string">&quot;map_reduce&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>如果信息分布在两个文档之间，无法在同一上下文中获取到所有的信息，也就没法给出正确答案。为解决这个问题，可以采用
<code>Refine 检索式问答链</code> ，Refine 文档链类似于 MapReduce
链，对于每一个文档，会调用一次 LLM，但有所改进的是，我们每次发送给 LLM
的最终提示是一个序列，这个序列会将先前的响应与新数据结合在一起，并请求得到改进后的响应。这种方法类似于
RNN，我们增强了上下文，从而解决信息分布在不同文档的问题。</p>
<p><a href="https://github.com/chatchat-space/Langchain-Chatchat">Github
参考项目链接</a></p>
<h1 id="多场景知识图谱">多场景知识图谱</h1>
<h2 id="问题背景-2">问题背景</h2>
<p>参考 Langchain 外部知识库开源项目的 <a
href="https://github.com/chatchat-space/Langchain-Chatchat/issues/1583">Issue</a>，可以发现，由于单一的文档切分方法和已训练好的分词器切分方法（项目中用的是
bge-large-zh-v1.5
模型）并不能理解场景相关的概念，也就无法构建有针对性的对话知识库，因此简单的导入外部数据无法实现多场景需求。</p>
<h2 id="解决思路-2">解决思路</h2>
<p>针对私有数据的多场景对话需求，可以构建并应用不同场景的知识图谱。</p>
<img data-src="/LLM-Application/image-20240424140419971.png" class="" title="image-20240424140419971">
<p>基于 用户输入Query 和 图数据库 Schema 构建 Prompt，通过 LLM
获取简短、精要的实体和关系信息，后续再基于此生成对话响应。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.chains <span class="keyword">import</span> GraphCypherQAChain</span><br><span class="line"><span class="keyword">from</span> langchain.graphs <span class="keyword">import</span> Neo4jGraph</span><br><span class="line"></span><br><span class="line">graph = Neo4jGraph(</span><br><span class="line">    url=<span class="string">&quot;bolt://localhost:7687&quot;</span>, </span><br><span class="line">    username=<span class="string">&quot;neo4j&quot;</span>, </span><br><span class="line">    password=<span class="string">&quot;&quot;</span></span><br><span class="line">)</span><br><span class="line">chain = GraphCypherQAChain.from_llm(</span><br><span class="line">    model, graph=graph, verbose=<span class="literal">True</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>Langchain 底层针对图数据库对话的 Prompt</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CYPHER_GENERATION_TEMPLATE = <span class="string">&quot;&quot;&quot;Task:Generate Cypher statement to query a graph database.</span></span><br><span class="line"><span class="string">Instructions:</span></span><br><span class="line"><span class="string">Use only the provided relationship types and properties in the schema.</span></span><br><span class="line"><span class="string">Do not use any other relationship types or properties that are not provided.</span></span><br><span class="line"><span class="string">Schema:</span></span><br><span class="line"><span class="string">&#123;schema&#125;</span></span><br><span class="line"><span class="string">Note: Do not include any explanations or apologies in your responses.</span></span><br><span class="line"><span class="string">Do not respond to any questions that might ask anything else than for you to construct a Cypher statement.</span></span><br><span class="line"><span class="string">Do not include any text except the generated Cypher statement.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">The question is:</span></span><br><span class="line"><span class="string">&#123;question&#125;&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>Langchain 底层针对上下文问答的 Prompt</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CYPHER_QA_TEMPLATE = <span class="string">&quot;&quot;&quot;You are an assistant that helps to form nice and human understandable answers.</span></span><br><span class="line"><span class="string">The information part contains the provided information that you must use to construct an answer.</span></span><br><span class="line"><span class="string">The provided information is authoritative, you must never doubt it or try to use your internal knowledge to correct it.</span></span><br><span class="line"><span class="string">Make the answer sound as a response to the question. Do not mention that you based the result on the given information.</span></span><br><span class="line"><span class="string">If the provided information is empty, say that you don&#x27;t know the answer.</span></span><br><span class="line"><span class="string">Information:</span></span><br><span class="line"><span class="string">&#123;context&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Question: &#123;question&#125;</span></span><br><span class="line"><span class="string">Helpful Answer:&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="多轮对话">多轮对话</h1>
<p>采用 qdrant 向量库保存对话历史</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomQdrantMemory</span>(<span class="title class_ inherited__">BaseChatMemory</span>):</span><br><span class="line">    <span class="comment"># 访问数据库抽取最相关联的 message_limit 条数据</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buffer</span>(<span class="params">self, inputs: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]</span>) -&gt; <span class="type">List</span>[BaseMessage]:</span><br><span class="line">        chat_messages: <span class="type">List</span>[BaseMessage] = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> inputs:</span><br><span class="line">            <span class="keyword">return</span> chat_messages</span><br><span class="line">        hits = self.qdrant.search(</span><br><span class="line">            collection_name=self.conversation_id,</span><br><span class="line">            query_vector=self.encoder.encode(inputs[<span class="string">&#x27;input&#x27;</span>]).tolist(),</span><br><span class="line">            limit=self.message_limit,</span><br><span class="line">        )</span><br><span class="line">        hits = <span class="built_in">sorted</span>(hits, key=<span class="keyword">lambda</span> x:x.<span class="built_in">id</span>)</span><br><span class="line">        <span class="keyword">for</span> hit <span class="keyword">in</span> hits:</span><br><span class="line">            chat_messages.append(HumanMessage(content=hit.payload[<span class="string">&#x27;human&#x27;</span>]))</span><br><span class="line">            chat_messages.append(AIMessage(content=hit.payload[<span class="string">&#x27;assistant&#x27;</span>]))</span><br><span class="line">        curr_buffer_length = self.llm.get_num_tokens(get_buffer_string(chat_messages))</span><br><span class="line">        <span class="comment"># 如果超出模型最长上下文，则弹出最早的对话历史</span></span><br><span class="line">        <span class="keyword">if</span> curr_buffer_length &gt; self.max_token_limit:</span><br><span class="line">            pruned_memory = []</span><br><span class="line">            <span class="keyword">while</span> curr_buffer_length &gt; self.max_token_limit <span class="keyword">and</span> chat_messages:</span><br><span class="line">                pruned_memory.append(chat_messages.pop())</span><br><span class="line">                curr_buffer_length = self.llm.get_num_tokens(get_buffer_string(chat_messages))</span><br><span class="line">        <span class="keyword">return</span> chat_messages        </span><br></pre></td></tr></table></figure>
<h1 id="虚拟人设">虚拟人设</h1>
<p><a href="https://github.com/LC1332/Chat-Haruhi-Suzumiya">Github
参考项目链接</a></p>
<p>流程</p>
<ul>
<li>音视频上传
<ul>
<li>语音转文字 FFmpeg</li>
<li>【初始化时】声纹构建</li>
<li>语音转文字 Whisper</li>
<li>特征语料库构建</li>
</ul></li>
<li>语料 + Chroma 向量库相似度 + KNN 距离匹配</li>
<li>组成输入，LLM 响应结果</li>
</ul>
]]></content>
      <categories>
        <category>LLM开发</category>
      </categories>
      <tags>
        <tag>Langchain</tag>
      </tags>
  </entry>
  <entry>
    <title>我爱上班</title>
    <url>/How-to-Work/</url>
    <content><![CDATA[<ol type="1">
<li>不卑不亢，谦虚有礼</li>
<li>可以竞争但要避免内斗</li>
<li>及时和领导同步进度</li>
<li>平和谦逊，思维敏捷，处理问题简明扼要</li>
</ol>
<p>【先抄抄人家的感悟，这边文章留给未来工作了慢慢充实】</p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>LLM 基础知识</title>
    <url>/LLM-Basic/</url>
    <content><![CDATA[<blockquote>
<p>大模型核心技术点在于训练资源、数据清洗和数据配比等，其难点或许不在于模型训练和模型结构搭建</p>
</blockquote>
<p><strong>【变形金刚之神！Bless Me】</strong></p>
<style>.ycrmoufgbpgy{zoom:70%;}</style>
<img data-src="/LLM-Basic/image-20240714162218754.png" class="ycrmoufgbpgy" alt="image-20240714162218754">
<ul>
<li>相较于 RNN，Transformer
直接将句子中<strong>任意两个单词的联系通过一个计算步骤直接联系起来</strong>，远距离依赖特征之间的距离被极大缩短，有利于有效地利用这些特征；</li>
<li>Self Attention
大大提升了<strong>计算的并行</strong>，通过上三角mask可以同时训练一句话中的所有token；</li>
</ul>
<p>NLP
任务：情感分析、文本生成、命名体识别、阅读理解、掩码填充、文本摘要、机器翻译、特征提取、对话机器人。</p>
<p>NLP
数据集大多是未标注的文档，因此采用自监督学习的方式训练模型，如预测下一个词
LM、完形填空 MLM。早些年，流行的是词嵌入 Word
Embedding，目标是采用向量的形式表示词元，采用一组向量表示一段话，可以用于计算词/句子相似度。</p>
<p>现阶段，Transformer 的出现促使三种类型的模型的出现：前缀语言模型
Encoder-Decoder（prefix-lm）；掩码语言模型/自编码模型
Encoder-Only；因果语言模型/自回归模型 Decoder-Only。Encoder-only
适用于机器翻译、句子分类、命名体识别和问答（大概）；Decoder-only
适用于文本预测；Encoder-Decoder 适用于文本压缩。</p>
<h1 id="基础知识">基础知识</h1>
<h2 id="预训练显存占用">预训练显存占用</h2>
<p>样例：大小为 n B的模型，Adam 优化器，混合精度 fp16，
b(batch_size)，s(sequence len)，h(hidden size)</p>
<ol type="1">
<li>输入输出：sbh*2 byte</li>
<li>模型大小：n*2 GB</li>
<li>梯度大小：n*2 GB</li>
<li>优化器大小：(4+4+4) *n
GB。模型更新时，梯度很小，学习率也很小，精度丢失会影响模型收敛效果，所以优化器中的数据全都是
fp32 精度。</li>
<li>激活值大小：sbh(34+5*a*s/h)*L byte <a
href="https://zhuanlan.zhihu.com/p/673916177">分析</a></li>
</ol>
<h2 id="数据获取和清洗">数据获取和清洗</h2>
<blockquote>
<p>少量高质量数据优于大量低质量数据</p>
</blockquote>
<h2 id="tokenizer">Tokenizer</h2>
<p>特殊 Token</p>
<ul>
<li>[PAD] 填充至固定长度</li>
<li>[CLS] 分类任务</li>
<li>[SEP] 分隔符</li>
<li>[MASK] 自监督任务，序列填空</li>
<li>[BOS] / [EOS] 自回归任务，约束文本生成的边界</li>
<li>[UNK] 无法识别的词</li>
<li>[SPE] 词汇表预留的标志</li>
</ul>
<p>[Q] Tokenizer 是选左 Padding 还是右 Padding？</p>
<p>训练和推理阶段的 &lt;PAD&gt; 标记是填充在左边还是右边都可以</p>
<ul>
<li>训练阶段，每一轮的 batch 都是独立的，<code>attention mask</code>
会把与有效序列无关的部分都屏蔽了，因此两者都行；</li>
<li>推理阶段，存在自回归的推理过程，当并发 <code>batch infer</code>
时，左 padding 可以直接将推理得到的下一跳 Token 合并到
<code>input_ids</code> 尾部，简化编码过程；</li>
</ul>
<h2 id="优化器">优化器</h2>
<p>在石器时代，人们直接使用 <code>loss.backward()</code>
计算梯度，乘以固定的学习率，得到所有参数更新的幅度。然而，使用固定的学习率，在梯度变化剧烈的地方，会导致更新不稳定或收敛慢。</p>
<p>为提高收敛效果，出现了很多优化器，它们被收藏在
<code>torch.optim</code> 里面，最出名的应该是
<code>Adam</code>、<code>AdamW</code>、<code>SGD</code>三大天王，待我娓娓道来。</p>
<h3 id="adam">Adam</h3>
<p>自适应学习率： Adam
通过计算一阶和二阶矩估计来为每个参数自适应地调整学习率；</p>
<p>偏差校正：
初始阶段梯度估计可能偏低，通过偏差校正可以加速初期的学习速率；</p>
<p>适应性强： Adam 在很多不同的模型和数据集上都表现出了良好的性能；</p>
<h2 id="减少显存占用">减少显存占用</h2>
<p>混合精度训练：FP16
速度快，占用小，适合前向传播、反向传播、矩阵计算；FP32
精度高，适合梯度累积、权重更新、归一化、softmax（可以通过动态损失缩放减少精度损失）</p>
<p>梯度累积：
<code>loss = loss / self.args.gradient_accumulation_steps</code>，更稳定的梯度估计</p>
<p>梯度检查点：<code>gradient_checkpointing=True</code>
只保存计算代价大且显存占用少的中间激活值，在反向传播时重新计算未保存的激活值</p>
<h2 id="采样">采样</h2>
<p>top_k
(int)：每次保留概率最大的几个序列，再按照概率选择保留的序列（不适用于概率分布平滑的情况）</p>
<p>top_p (float: 0~1)：保留前n个概率和大于 p
的序列，再按照概率选择保留的序列（适用于概率分布平滑的情况，按照概率采样，提高响应多样性）</p>
<p>temperature：优化了 Softmax 函数改为 <span
class="math inline">\(p(x_i)=\frac{e^{\frac{x_i}t}}{\sum_{j=1}^ne^{\frac{x_j}t}}\)</span>，温度越小
softmax 的概率分配越尖锐（确定性），反之越平滑（随机性）</p>
<p>num_beams：每次保留概率最大的几个序列，最后输出概率最大的值（上面三个方法已足够，束搜索未包含在
OpenAI API 中）</p>
<h2 id="嵌入模型">嵌入模型</h2>
<blockquote>
<p>提示词在嵌入模型中扮演着关键角色，提供上下文、指导生成的格式、增强模型效果、适应不同任务并减少噪声。通过使用合适的提示词，可以提高嵌入模型的性能和实用性。</p>
</blockquote>
<p><code>bge-large-zh-v1.5</code> 嵌入模型的架构：</p>
<ul>
<li>BertEmbeddings
<ul>
<li>word_embeddings</li>
<li>position_embeddings</li>
<li>token_type_embeddings</li>
<li>LayerNorm + dropout</li>
</ul></li>
<li>BertEncoder
<ul>
<li>attention</li>
<li>MLP</li>
<li>LayerNorm + dropout</li>
</ul></li>
<li>BertPooler
<ul>
<li>dense + activation</li>
</ul></li>
</ul>
<h1 id="编程">编程</h1>
<h2 id="transformers及相关库">Transformers及相关库</h2>
<blockquote>
<p>优秀的基础知识分享 <a
href="https://www.bilibili.com/video/BV1CB4y1R78v/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&amp;vd_source=3cc51ca1725a727b98e3f7d482a21ed1">B
站课程</a>，<a
href="https://github.com/datawhalechina/tiny-universe/tree/main">开源项目</a></p>
</blockquote>
<p>Transformers：核心库，模型加载、模型训练、流水线并行等</p>
<p>Tokenizer：分词器，对数据进行预处理，文本到token序列的互相转换。具体工作包括：分词、索引、填充截断、attention_mask、token_type</p>
<p>Datasets：数据集库，提供了数据集的加载、处理等方法</p>
<p>Evaluate：评估函数，提供各种评价指标的计算函数</p>
<p>Trainer：将模型训练流程打包，包括：创建优化器、创建DataLoader、tensor转移到CUDA上</p>
<p>PEFT：高效微调模型的库，提供了几种高效微调的方法，小参数量动大模型</p>
<p>Accelerate：分布式训练，提供了分布式训练解决方案，包括大模型的加载与推理解决方案</p>
<p>Optimum：优化加速库，支持多种后端，如Onnxruntime、OpenVino等</p>
<p>Gradio：可视化部署库，几行代码快速实现基于Web交互的算法演示系统</p>
<h2 id="分布式训练">分布式训练</h2>
<p>Accelerate 包，融合了 Deepspeed、DDP、FSDP；</p>
<h2 id="llama-factory-源码">LLaMA-Factory 源码</h2>
<p>trainargs.main_process_first()
内的代码只在主进程里面运行，适用于数据处理；</p>
<p>为实现高效打包，替换 transformers 包内模型的
<code>_get_unpad_data</code>方法，实现4Dmask，以区分每个 batch
中的不同序列；</p>
]]></content>
      <categories>
        <category>LLM基础</category>
      </categories>
      <tags>
        <tag>大模型基础</tag>
      </tags>
  </entry>
  <entry>
    <title>LLM 结构和创新点</title>
    <url>/LLM-Model/</url>
    <content><![CDATA[<h1 id="优化技术">优化技术</h1>
<blockquote>
<p>大模型领域针对 Transformer 计算过程的一些优化</p>
</blockquote>
<h2 id="滑动窗口注意力">滑动窗口注意力</h2>
<p>sliding window attention: Longformer</p>
<img data-src="/LLM-Model/swa.png" class="" title="img">
<p><a
href="https://amaarora.github.io/posts/2024-07-04%20SWA.html#sliding-window-attention-in-pytorch">技术博客</a></p>
<h2 id="稀疏注意力">稀疏注意力</h2>
<p>Generating Long Sequences with Sparse
Transformers，核心是只让设置好的像素点参与自注意力的计算（注意这里不是只选取设置好位置上的像素点，其他mask掉，因为这样并不能降低模型的复杂度），引入一个名为连接模式(Connectivity
Pattern)的变量，连接模式只作用在<span
class="math inline">\(K\)</span>和<span
class="math inline">\(V\)</span>的计算上，(bs, head_num, seq_len,
head_dim) 中的 seq_len 只选取连接模式中选择的。</p>
<p>连接模式（注意力核）的选择：局部稀疏模式、分块稀疏模式、对角块稀疏模式</p>
<img data-src="/LLM-Model/2.png" class="" title="img">
<p><a
href="https://fengyan-wby.fun/2023/08/22/%E3%80%90%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%E3%80%91Generating-Long-Sequences-with-Sparse-Transformers/">技术博客</a></p>
<h2 id="flash-attention">Flash Attention</h2>
<p>其核心思想是将原始的注意力矩阵分解成更小的子矩阵，然后分别对这些子矩阵进行计算，只要这个子矩阵的大小可以在
SRAM 内存放，那么不就可以在计算过程中只访问 SRAM 了。</p>
<p>采用了 Recomputation
(重算）方法，这算是在深度学习优化中的老概念了，它是一种算力换内存的把戏。</p>
<p>Tiling 方法将 NxN 的 softmax 分数矩阵划分为块，核心是
<strong>分块SoftMax算法</strong>，详细推导过程见<a
href="http://fancyerii.github.io/2023/10/23/flashattention/">技术博客</a>。</p>
<h1 id="qwen2-模块">Qwen2 模块</h1>
<img data-src="/LLM-Model/dccdd5360d984d2c84a9f7338c55e665.jpeg" class="" title="img">
<p><a
href="https://github.com/datawhalechina/tiny-universe/tree/main/content/Qwen-blog">DataWhale社区教程</a></p>
<p><code>modeling_qwen2.py</code> 架构</p>
<ul>
<li><p>Qwen2RMSNorm： RMS归一化层</p></li>
<li><p>Qwen2RotaryEmbedding： 旋转位置编码</p></li>
<li><p>Attention</p>
<ul>
<li><p>Qwen2Attention： 注意力层</p></li>
<li><p>Qwen2FlashAttention2： 使用Flash Attention
2.0版本加速的注意力层</p></li>
<li><p>Qwen2SdpaAttention： 使用Sdpa（pytorch自带的加速， Scaled
Dot-Product Attention）加速的注意力层</p></li>
</ul></li>
<li><p>Qwen2DecoderLayer： 编码层，核心结构，之后就是堆叠</p></li>
<li><p>Qwen2PreTrainedModel： 预训练类</p></li>
<li><p>Qwen2Model： 不带head的Qwen2模型</p></li>
<li><p>Qwen2ForCausalLM： 带Causal LM head的Qwen2模型</p></li>
<li><p>Qwen2ForSequenceClassification： 带序列分类头的Qwen2模型</p></li>
</ul>
<p>功能函数</p>
<ul>
<li><p>_get_unpad_data： 在flash attention的数据预处理中会用到。主要是对
attention mask 进行一些操作；</p></li>
<li><p>rotate_half： 在旋转位置编码中用到；</p></li>
<li><p>apply_rotary_pos_emb： 对数据主要是注意力运算中的 q，k
做旋转位置编码；</p></li>
<li><p>repeat_kv： 主要是在 MQA（Multi-Query Attention）和
GQA（Group-Query Attention）中用到，因为 q head 数量是 k，v head
的数量的整数倍</p></li>
</ul>
<p>优化注意力机制，降低处理长序列时的计算复杂度。</p>
<h2 id="分组查询注意力-gqa">分组查询注意力 GQA</h2>
<p>MQA 将所有注意力头的键和值共享</p>
<p>GQA 的方式是将多个注意力头分成组，每组头共享同一组的键和值。</p>
<img data-src="/LLM-Model/v2-8a907719f9e3ced8347a051d9a66c732_720w.webp" class="" title="img">
<p>实现方式：<code>transformers.models.llama.modeling_llama.repeat_kv</code>
复制多次 KV，使用 <code>expand</code> 而不是 <code>repeat</code> 是因为
KV 的参数是组内共享的</p>
<h2 id="旋转位置编码-pore">旋转位置编码 PoRE</h2>
<blockquote>
<p>通过旋转编码，使得每个 token
既有相对位置信息，又有绝对位置信息，Qwen2 的位置信息编码是在 attention
中计算到 KV 中的</p>
</blockquote>
<p>例如，对于一个维度为 512 的向量<span
class="math inline">\(v=(v_0,v_1,v_2,v_3，...，v_{511})\)</span>，RoPE
可能将其看作：</p>
<ul>
<li>第 1 对：<span class="math inline">\((v_0,v_1)\)</span></li>
<li>第 2 对：<span class="math inline">\((v_2,v_3)\)</span></li>
<li>...</li>
<li>第 256 对：<span
class="math inline">\((v_{510},v_{511})\)</span></li>
</ul>
<p>然后，通过旋转矩阵分别对每一对进行旋转，使得每一对的旋转角度与相对位置相对应。</p>
<style>.odyjbghoasxw{zoom： 67%;}</style>
<img data-src="/LLM-Model/ROPE3.png" class="odyjbghoasxw" alt="img">
<p>代码层面，Qwen2 构造 <code>Qwen2RotaryEmbedding</code> 类和
<code>apply_rotary_pos_emb</code> 方法，
<code>Qwen2RotaryEmbedding</code> 类基于 seq_len 返回缓存的 cos 和 sin
数据， <code>apply_rotary_pos_emb</code> 方法将位置信息作用到<span
class="math inline">\(K\)</span>和<span
class="math inline">\(V\)</span>上。</p>
<h2 id="均方根归一化-rmsnorm">均方根归一化 RMSNorm</h2>
<p>矩阵计算要进行归一化防止不同特征的取值过大，常用的是 layer
norm，也就是每一项减去样本的均值，再除以样本的方差；而 RMS
则是去除了减去均值的操作，以便提升效率。</p>
<ul>
<li>LayerNorm
通过均值和标准差对输入进行标准化，确保输入具有<strong>零均值和单位方差</strong>，这对稳定训练有帮助。</li>
<li>RMSNorm
则通过均方根进行归一化，<strong>不关注均值，仅对幅值进行规范化，避免了对数据的中心化处理</strong>，减少了计算复杂度，并且在某些模型中表现优越。</li>
</ul>
<p><span class="math inline">\(\text{LN}(x) = \frac{x - \mu}{\sigma}
\cdot \gamma + \beta\)</span></p>
<ul>
<li>x 是输入向量（通常是模型中每一层的输出）。</li>
<li><span class="math inline">\(\mu\)</span> 是输入向量的均值。</li>
<li><span class="math inline">\(\sigma\)</span>
是输入向量的标准差。</li>
<li><span class="math inline">\(\gamma\)</span> 和 <span
class="math inline">\(\beta\)</span> 是可学习的缩放和偏移参数。</li>
</ul>
<p>LN 会计算整个输入的均值 <span class="math inline">\(\mu\)</span>
和标准差 $ $，并用它们对输入进行标准化。</p>
<p><span class="math inline">\(\text{RMSNorm}(x) =
\frac{x}{\text{RMS}(x)} \cdot \gamma\)</span></p>
<ul>
<li><span class="math inline">\(\text{RMS}(x) = \sqrt{\frac{1}{n}
\sum_{i=1}^n x_i^2}\)</span>是输入向量的均方根；</li>
<li>$$ 是可学习的缩放参数；</li>
<li>不使用均值和偏移参数 <span class="math inline">\(\beta\)</span>
；</li>
</ul>
<p>RMSNorm 只关注输入的
<strong>范数（幅值）</strong>，而不考虑均值，避免了对数据的中心化处理。</p>
<p>它是一种更轻量级的标准化方法，在某些情况下可以提高训练效率和收敛速度。</p>
<h2 id="激活函数-swiglu">激活函数 SwiGLU</h2>
<p>SwiGLU 将 GLU 的门控改为 <code>Swish</code> ，后验证实其在 GLU
的众多变体里效果最好，优于 Transformer 一开始使用的
<code>ReLU</code>。</p>
<p><span class="math inline">\(F.silu(self.w1(x)) *
self.w2(x)\)</span>，其中 silu 公式为 <span
class="math inline">\(\mathrm{Swish}_\beta(x)=x\otimes\sigma(\beta
x)\)</span></p>
]]></content>
      <categories>
        <category>LLM基础</category>
      </categories>
      <tags>
        <tag>大模型结构</tag>
      </tags>
  </entry>
  <entry>
    <title>大模型微调 PEFT 方法</title>
    <url>/LLM-PEFT/</url>
    <content><![CDATA[<blockquote>
<p>因此，近年来研究者们提出了各种各样的参数高效迁移学习方法，即<strong>固定住预训练模型的大部分参数，仅调整模型的一小部分参数来达到与全部参数的微调接近的效果</strong>。调整的可以是模型自有的参数，也可以是额外加入的一些参数。目前的微调方法分为加性方法、选择性方法、重参数化方法和混合方法。</p>
</blockquote>
<h1 id="qa">Q&amp;A</h1>
<p>[Q] 什么情况下模型显存占用大？</p>
<ul>
<li>batch size 大，并行计算；</li>
<li>模型参数量大，每个参数都需要存储空间（精度不同占用空间不同 fp32 fp16
bf16 int8 int4）；</li>
<li>计算过程产生大量的中间变量（如激活值、梯度等），这些中间变量也需要存储在显存中，以便进行后续的计算；</li>
<li>优化器所需的额外信息多（如动量、学习率等）；</li>
<li>模型复杂，反向传播的计算图占用更多显存；</li>
</ul>
<p>[Q] 为什么减少了可训练参数就会减少显存占用？</p>
<ul>
<li>不需要存储它们的梯度；</li>
<li>不需要为不可训练参数分配额外的内存来存储优化状态（如动量、学习率等）；</li>
<li>不需要存储中间激活值（激活值用于在后向传播过程中，计算梯度，进而更新模型的参数）；</li>
</ul>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">以 LP32 精度全量微调一个 1.3B 的模型需要占用多少显存？</span><br><span class="line"></span><br><span class="line">模型权重：1.2G * 4B = 4.8GB</span><br><span class="line">梯度：1.2G * 4B = 4.8GB</span><br><span class="line">优化器状态：1.2G * 4B * 2 = 9.6GB</span><br><span class="line">前向激活值：取决于序列长度、隐层维度、batch size</span><br><span class="line"></span><br><span class="line">实际加载后，占用大约 20GB 的显存</span><br></pre></td></tr></table></figure>
<p>[Q] 模型训练过程中有什么有效的减少显存占用的方法？</p>
<ul>
<li>梯度累计技术：将多个小批量训练数据的梯度进行累积，在达到指定累积次数后，使用累积梯度统一更新一次模型参数，从而达到与大批量数据训练相近的效果；
<ul>
<li>相当于降低了 batch size，因而减少了显存占用；</li>
<li>多个小批量的可训练参数的梯度是存在一起的，不额外占用显存；</li>
</ul></li>
<li>梯度检查点
gradient_checkpoint：在后向传播过程中重新计算前向传播中的某些中间激活值，从而减少显存占用；</li>
</ul>
<p>[Q] 为什么需要 PEFT？</p>
<ul>
<li><p><strong>全量微调大模型</strong>虽然效果还不错，但需要大量的计算资源和训练数据（训练数据中通用数据和领域数据都要有）；</p></li>
<li><p>为了降低计算资源，只<strong>微调模型的某几层参数</strong>时，无法得到较好的微调结果，会出现欠拟合或泛化能力降低的情况，模型无法有效学习领域数据的知识，且可能会破坏了预训练模型的通用语言语义能力；</p></li>
<li><p>当修改了输入 Embedding
或大模型每一层的某些部分时，可以在有限的计算资源上，得到与全量微调近似的微调效果，这便是
PEFT 存在的理由；</p></li>
<li><p>不同领域的全量微调模型需要分开部署，资源占用量大；由于只修改了部分参数，PEFT
中的方法，都具有“<strong>一次部署，多领域共用</strong>”的能力，只需要一次就能加载所有参数，针对不同领域的调用切换不同的
PEFT 参数，即采用该领域微调所增加的小部分参数；</p></li>
</ul>
<p>[Q] 有哪些显存优化策略？</p>
<ul>
<li>高效微调 PEFT；
<ul>
<li>Lora</li>
<li>Prefix-Tuning</li>
</ul></li>
<li>前向激活值；
<ul>
<li>Gradient Accumulation</li>
<li>Gradient Checkpoints</li>
<li>Data Length</li>
</ul></li>
<li>优化器状态；
<ul>
<li>Adafactor Optiomizer</li>
</ul></li>
<li>前向激活值 + 梯度；
<ul>
<li>Freeze Model</li>
</ul></li>
<li>参数量化；
<ul>
<li>QLora</li>
</ul></li>
</ul>
<h1 id="背景">背景</h1>
<p>2018年Bert问世后，NLP
研究的趋势转变为“预训练模型+微调”。虽然更大的模型带来了更好的性能，但以传统的方式对模型进行全量微调会消耗巨大的计算和存储资源，过高的硬件门槛不利于该领域的研究和发展。</p>
<p>在此背景下，参数高效微调和量化技术应运而生，参数高效微调方法仅对模型的一小部分参数（这一小部分可能是模型自身的，也可能是外部引入的）进行训练，便可以为模型带来显著的性能变化，一些场景下甚至不输于全量微调，颇有一种<strong>四两拨千斤</strong>的感觉。</p>
<p>由于训练一小部分参数，极大程度降低了训练大模型的算力需求，不需要多机多卡，单卡即可完成对一些大模型的训练。不仅如此，少量的训练参数对存储的要求同样降低了很多，大多数的参数高效微调方法只需要保存训练部分的参数，与动辄几十
GB 的预训练大模型相比，几乎可以忽略。</p>
<p>当下流行 PEFT 结构一览：</p>
<img data-src="/LLM-PEFT/peft%E6%96%B9%E6%B3%95.jpg" class="" title="peft方法">
<p>常用的参数高效微调方法：</p>
<style>.cixolllysxpj{zoom: 50%;}</style>
<img data-src="/LLM-PEFT/image-20240718093213465.png" class="cixolllysxpj" alt="image-20240718093213465">
<ul>
<li>Selective：选择模型中的一部分参数进行微调；</li>
<li>Additive：冻结模型原有参数，微调新增的参数和模块；
<ul>
<li>Adapters：</li>
<li>Soft Prompt：</li>
</ul></li>
<li>Reparameterzation：</li>
</ul>
<h1 id="实现方法">实现方法</h1>
<h2 id="开源工具">开源工具</h2>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>开源项目</th>
<th>微调方法</th>
<th>实现方法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="https://github.com/hiyouga/LLaMA-Factory">Llama
Factory</a></td>
<td>GaLore、BAdam、DoRA、LongLoRA、LLaMA
Pro、Mixture-of-Depths、LoRA+、LoftQ、PiSSA</td>
<td>peft 包、编写 LongLoRA、LlamaPro
流程【重点是对微调流程的整体架构，包括量化、数据预处理、加速训练、评估和模型存储等，用户可以开箱即用】</td>
</tr>
<tr class="even">
<td><a href="https://github.com/modelscope/swift">Swift</a></td>
<td>LoRA、LoRA+、LLaMA
Pro、GaLore、LISA、UnSloth、SCEdit、NEFTune、LongLoRA、Adapter、IA3、AdaLoRA</td>
<td>peft 包、编写 LongLoRA、LoRA、LlamaPro、Adapter 流程</td>
</tr>
<tr class="odd">
<td><a
href="https://github.com/meta-llama/llama-recipes">llama-recipes</a></td>
<td>LoRA、QLoRA、IA3、AdaLoRA</td>
<td>peft 包</td>
</tr>
<tr class="even">
<td><a href="https://github.com/yangjianxin1/Firefly">Firefly</a></td>
<td>LoRA、QLoRA</td>
<td>直接操作模型结构，为所有全连接添加 Adapter</td>
</tr>
<tr class="odd">
<td><a
href="https://github.com/axolotl-ai-cloud/axolotl">Axolotl</a></td>
<td>LoRA、QLoRA、ReLoRA</td>
<td>peft 包、编写 ReLoRA 流程</td>
</tr>
</tbody>
</table>
<h2 id="开发包">开发包</h2>
<p>Bitsandbytes：训练过程中的参数量化、压缩和加速</p>
<p>Peft（没有Adapter方法的实现）：参数高效微调技术，旨在通过最小化微调参数的数量和计算复杂度来提高预训练模型在新任务上的性能（可以实现）</p>
<p>Adapters：HuggingFace Transformers
的附加库，将各种适配器方法集成到最先进的预训练语言模型中，以最小的训练和推理编码开销。</p>
<p>DeepSpeed：提供了从训练到推理的全面优化方案，包括参数初始化、训练加速、内存优化等多个方面</p>
<h2 id="开源数据集">开源数据集</h2>
<p><a
href="https://fengyan-wby.fun/2024/04/11/LLM%E8%AE%AD%E7%BB%83%E8%B5%84%E6%BA%90/">Link</a></p>
<h2 id="测评方法">测评方法</h2>
<p>Acc、F1、PPL、Distinct-n、BLUE-n、Rouge-n、Rouge-L</p>
<h1 id="微调算法">微调算法</h1>
<blockquote>
<p>不包括：</p>
<ul>
<li><p>微调图像大模型 Stable Diffusion：lokr loha；</p></li>
<li><p>将文本到图像的扩散模型适应下游任务：正交矩阵OFT、蝴蝶微调 Boft
；</p></li>
</ul>
</blockquote>
<p>基于加法
PEFT：增加额外可训练模型结构或参数（Embedding、MLP、LSTM），如：Prompt
Tuning、Prefix Tuning、Adapter；</p>
<p>基于选择 PEFT：直接微调大模型中的一部分参数，如：BitFit、LN
Tuning；</p>
<p>基于重参数化
PEFT：在已经训练好的参数矩阵的基础上，增加可训练、可合并的参数，如：LoRA、AdaLoRA、PISSA、GaLore；</p>
<p>融合上述三种方法的 PEFT：混合上述三种方法，如：MAM
Adapter、UniPELT；</p>
<p>高效量化：不降低训练效果的前提下，降低计算资源的需求，如：QLoRA；</p>
<p>并行训练：提升训练速度，SLoRA；</p>
<p>工程系统角度的优化：梯度检查点、内存卸载；</p>
<p>可训练参数量比较：IA3 &lt; BitFit &lt; Prompt-Tuning &lt; Lora =
Prefix-Tuning</p>
<h2 id="bitfit">BitFit</h2>
<p><strong>只训练模型中的 bias 部分</strong>，冻结其他参数。</p>
<p>优势：</p>
<ul>
<li>简单高效，资源占用量小；</li>
<li>泛化性强，适用各种场景；</li>
</ul>
<p>不足：</p>
<ul>
<li>可解释性差；</li>
<li>强依赖于大模型自身的质量；</li>
</ul>
<h2 id="ln-tuning">LN-Tuning</h2>
<p>单独调整 LayerNorm 模块的 weight 和 bias
参数，训练参数量少，便于和其他的微调方法一起使用。</p>
<style>.oijzgfrvhgme{zoom:50%;}</style>
<img data-src="/LLM-PEFT/image-20240723134459641.png" class="oijzgfrvhgme" alt="image-20240723134459641">
<p>实验表明，Prefix-Tuning + LN 的微调效果最佳。</p>
<p>优势</p>
<ul>
<li>参数量低，效果不错；</li>
</ul>
<h2 id="prompt-tuning">Prompt-Tuning</h2>
<p>冻结预训练大模型的全部参数，在训练的输入数据前加入一小段
Prompt，<strong>只训练 Prompt 的表示层，即一个 Embedding
模块</strong>。</p>
<p>其中，Prompt 存在两种形式，分别是 hard prompt 和 soft prompt。hard
prompt 通过人工输入的提示词初始化 prompt，soft prompt 随机初始化
prompt。二者相比，hard prompt 可控性更强，训练速度更快。为了优化Soft
prompt 的效果，后续研究提出了 P-Tuning。</p>
<blockquote>
<p>可训练模块：Embedding(virtual_token, hidden_size)</p>
</blockquote>
<style>.fffmomqhqgzv{zoom:50%;}</style>
<img data-src="/LLM-PEFT/image-20240712160012402.png" class="fffmomqhqgzv" alt="image-20240712160012402">
<p>优势：</p>
<ul>
<li>简化了不同任务之间的转换和迁移，使得模型可以更加灵活地应用于各种场景；</li>
</ul>
<p>不足：</p>
<ul>
<li>预训练模型较小或在Few-shot场景下，微调结果不佳；</li>
</ul>
<h2 id="p-tuning">P-Tuning</h2>
<p>在 Prompt-Tuning 的 Soft Prompt 基础上，对 Prompt
部分进行进一步的编码计算，加速收敛。具体来说，PEFT
包中支持两种编码方式，一种是 LSTM，一种是 MLP。</p>
<blockquote>
<p>可训练模块：Embedding(virtual_token, hidden_size) + MLP/LSTM</p>
</blockquote>
<img data-src="/LLM-PEFT/PT.png" class="" title="PT.png">
<p>优势：</p>
<ul>
<li>通过 Encoder 将离散的 Prompt Embedding 转变为连续的，减少了 Prompt
Embedding 初始化对微调性能的影响，提高了训练的稳定性；</li>
</ul>
<p>不足：</p>
<ul>
<li>增加的 Prompt Encoder 需要额外的计算资源；</li>
</ul>
<h2 id="prefix-tuning">Prefix Tuning</h2>
<p>将可学习的前缀以 past_key_values 的形式放到模型的 attention 的 KV
头部，每个 MHA 中的注意力层共享同一组前缀。</p>
<blockquote>
<p>past _key_values：Transformer 模型中历史计算过的 key 和 value
的结果，最早是用于生成类模型解码加速，解码逻辑是根据历史输入，每次预测一个新的
Token，然后将新的 Token 加入输入，再预测下一个
Token。这个过程中，会存在大量的重复计算，因此可以将 key 和 value
的计算结果缓存，作为 past_key_values
输入到下一次的计算中，这一技术又被称之为 kv cache。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可训练模块：Embedding + MLP，与 P-Tuning 的区别是 prefix 映射到了模型的隐藏层上</span></span><br><span class="line">self.embedding = torch.nn.Embedding(num_virtual_tokens, token_dim)</span><br><span class="line">self.transform = torch.nn.Sequential(</span><br><span class="line">    torch.nn.Linear(token_dim, encoder_hidden_size),</span><br><span class="line">    torch.nn.Tanh(),</span><br><span class="line">    torch.nn.Linear(encoder_hidden_size, num_layers * <span class="number">2</span> * token_dim),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># transformers.models.bloom.BloomAttention 源码实现</span></span><br><span class="line"><span class="keyword">if</span> layer_past <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    past_key, past_value = layer_past</span><br><span class="line">    key_layer = torch.cat((past_key, key_layer), dim=<span class="number">2</span>)</span><br><span class="line">    value_layer = torch.cat((past_value, value_layer), dim=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<style>.nikftxgpyapj{zoom:50%;}</style>
<img data-src="/LLM-PEFT/image-20240712161951488.png" class="nikftxgpyapj" alt="image-20240712161951488">
<p>优势：</p>
<ul>
<li>拟合速度快；</li>
</ul>
<p>不足：</p>
<ul>
<li>直接修改模型结构，依赖预训练模型本身的结构；</li>
<li>实现复杂，相比于直接修改输入 Prompt Embedding 没有显著优势；</li>
<li>相比于其他的 Soft Prompt 方法，Prefix Tuning
可训练参数量大，每一层的 K V 都需要可训练前缀；</li>
</ul>
<h2 id="p-tuning-v2">P-Tuning V2</h2>
<p>与 Prefix Tuning
最大的区别在于：移除重参数化的编码器，即没有MLP。</p>
<p>通过共享连续提示同时优化多个任务，多任务学习是 P-Tuning v2
的可选功能，可以通过多任务共享前缀进一步提升性能。</p>
<style>.krvwugfcgvjd{zoom:50%;}</style>
<img data-src="/LLM-PEFT/image-20240712162302772.png" class="krvwugfcgvjd" alt="image-20240712162302772">
<p>优势：</p>
<ul>
<li>移除重参数化的编码器，对于较小的模型，会影响模型的表现，且对于大模型提升不大；</li>
<li>引入多任务学习概念，先在多任务的Prompt上进行预训练，然后再适配下游任务；</li>
</ul>
<p>不足：</p>
<ul>
<li>prefix长度在 100~200
时，微调结果最优，但由于模型可接受的最大输入长度有限，随着软提示的参数量增多，实际输入序列的最大长度也会相应减小；</li>
<li>直接优化 prompt 和 prefix 是非单调的，比较难以收敛；</li>
</ul>
<h2 id="diff-pruning">Diff pruning</h2>
<p>不是修改模型的结构，而是通过一个特定任务的 diff
向量扩展基础模型。学习特定于任务的差异向量，该向量扩展了原始预训练参数。diff
向量 <span class="math display">\[\delta_{task}\]</span>
在训练过程中自适应修剪，并加入 𝐿0 范数惩罚的可微近似来鼓励稀疏性。</p>
<p><span
class="math display">\[\theta_{task}=\theta_{pretrained}+\delta_{task}\]</span></p>
<p>不足：</p>
<ul>
<li>需要底层实现来加速非结构化稀疏矩阵的计算，不能直接使用现有的框架；</li>
<li>训练过程中需要存储完整的∆矩阵，相比于Full
finetune并没有降低计算成本；</li>
</ul>
<h2 id="lora">LoRA</h2>
<p>深度网络由大量 Dense
层构成，这些参数矩阵通常是低秩的。相关工作表明，在适应特定任务时，预训练模型是过度参数化的，hidden_size
实际上存在于一个较低的内在维度上，即高维数据实际是在低维子空间中。</p>
<p>因此，将 <span class="math inline">\(\Delta\mathbf{W}\)</span>
用两个更参数量更小的矩阵 <span
class="math inline">\(\mathbf{A}\in\mathbb{R}^{d\times r}\)</span> 和
<span class="math inline">\(\mathbf{B}\in\mathbb{R}^{r\times d}\)</span>
低秩近似（r&lt;d）。其中，矩阵 B 通过高斯函数初始化，矩阵 A
为全零初始化，使得训练开始之前旁路对原模型不造成影响。</p>
<p>具体而言，冻结预训练的模型权重，并将可训练的秩分解矩阵注入到大模型的每个
Attention
层的线性变换中。输入分别与原始权重和两个低秩矩阵进行计算，共同得到最终结果。</p>
<style>.qqxlyuefytrq{zoom:40%;}</style>
<img data-src="/LLM-PEFT/image-20240712170241205.png" class="qqxlyuefytrq" alt="image-20240712170241205">
<p>训练完成后，可以将两个低秩矩阵与原始模型中的权重进行合并，合并后的模型与原始模型无异，避免了推理期间
Prompt 系列方法带来的额外计算量。</p>
<p><span
class="math display">\[\mathbf{h}=(\mathbf{W}_0+\Delta\mathbf{W})\mathbf{x}=\mathbf{W}_0\mathbf{x}+\mathbf{B}\mathbf{A}\mathbf{x}\]</span></p>
<p>优势：</p>
<ul>
<li>可以将原权重与训练后权重合并，在推理时不存在额外的计算开销；</li>
<li>不增加输入参数，不改变模型结构，简单易用，泛化性强；</li>
<li>提出低秩分解矩阵的思路，在减少计算资源需求的同时，不会丢失预训练原有的通用能力；</li>
</ul>
<p>不足：</p>
<ul>
<li>预先指定每个增量矩阵的内在秩 r
相同，忽略了在微调预训练模型时，权重矩阵的重要性在不同模块和层之间存在显著差异，在实验中可以发现
Wq
的秩更大，即存储的信息更多；因此无法完全捕捉预训练模型的特征，或无法有效地将原始模型的知识迁移到目标任务上；</li>
<li>只训练了self-attention，没有训练 feed-forward networks，事实上 FFN
更重要；</li>
</ul>
<h2 id="ia3">IA3</h2>
<blockquote>
<p>由于不同大模型结构不同，源码实现有差别。bloom 预训练模型的 QKV 共用
Linear 层 (hidden_size, hidden_size*3)，IA3
的可训练参数同时作用于三者之上</p>
</blockquote>
<p>抑制和放大内部激活，通过可学习的向量对激活值进行抑制或放大。具体来说，通过一组可训练参数直接于
K、V、FFN 相乘，针对不同 batch
的同一位置进行相同的调整（即乘上相同可学习参数），训练过程中冻结原始模型的权重，只更新新增的参数。训练完成后，与
Lora 类似，可以将学习部分的参数与原始权重合并，没有额外推理开销。</p>
<style>.vmttxytiktsu{zoom:67%;}</style>
<img data-src="/LLM-PEFT/image-20240718191324572.png" class="vmttxytiktsu" alt="image-20240718191324572">
<p>优势：</p>
<ul>
<li>调节的参数少于 Lora，微调效果也不错；</li>
</ul>
<p>不足：</p>
<ul>
<li>学习率对微调效率影响较大，论文中的建议是 3e-3；</li>
</ul>
<h2 id="adalora">AdaLora</h2>
<p>AdaLora
在微调过程中，采用“先探索参数空间，再关注最重要的权重”的方法，不预先指定矩阵的秩，而是动态更新增量矩阵的秩，因为研究发现权重矩阵的重要性在不同模块和层之间存在显著差异。在该微调方法中，需要先找到更加重要的矩阵，给其分配更多的参数（更大的秩），并裁剪不重要的矩阵。相比于Lora，该方法在提升模型效果的同时，降低了参数计算量。</p>
<p>区别于 Lora 的低秩矩阵分解，AdaLora
采用参数化矩阵来模拟奇异值分解（SVD），并舍弃不重要的奇异值，保留奇异向量。由于对一个大矩阵进行精确
SVD
分解的计算消耗非常大，这种方法可以加速计算，同时保留未来恢复的可能性并稳定训练。</p>
<p><span class="math display">\[W=W^{(0)}+\Delta=W^{(0)}+P \Lambda
Q\]</span></p>
<p>计算三元组 QKV
的重要性分数，修剪不太重要的奇异值，将更多预算留给优先级较高的增量矩阵。</p>
<p><span
class="math display">\[S_{k,i}=s\left(\lambda_{k,i}\right)+\frac{1}{d_1}\sum_{j=1}^{d_1}s\left(P_{k,ji}\right)+\frac{1}{d_2}\sum_{j=1}^{d_2}s\left(Q_{k,ij}\right)\]</span></p>
<p>通过灵敏度平滑和不确定性量化，加入累计灵敏度的影响来解决随机采样和复杂的训练动态导致灵敏度估计的变异性大、不确定性大的问题</p>
<p><span
class="math display">\[\begin{aligned}&amp;\bar{I}^{(t)}\left(w_{ij}\right)=\beta_1\bar{I}^{(t-1)}\left(w_{ij}\right)+\left(1-\beta_1\right)I^{(t)}\left(w_{ij}\right)\\&amp;\bar{U}^{(t)}\left(w_{ij}\right)=\beta_2\bar{U}^{(t-1)}\left(w_{ij}\right)+\left(1-\beta_2\right)\left|I^{(t)}\left(w_{ij}\right)-\bar{I}^{(t)}\left(w_{ij}\right)\right|\end{aligned}\]</span></p>
<p><span
class="math display">\[s^{(t)}\left(w_{ij}\right)=\bar{I}^{(t)}\left(w_{ij}\right)\cdot\bar{U}^{(t)}\left(w_{ij}\right)\]</span></p>
<p>可以通过梯度下降的方式对<span class="math inline">\(P, \Lambda,
Q\)</span>进行更新，将不需要的奇异值 λ 剪裁 Mask，后续仍可以加入训练</p>
<p><span
class="math display">\[\Lambda_k^{(t+1)}=\mathcal{T}\left(\tilde{\Lambda}_k^{(t)},S_k^{(t)}\right),\text{
with
}\mathcal{T}\left(\tilde{\Lambda}_k^{(t)},S_k^{(t)}\right)_{ii}=\begin{cases}\tilde{\Lambda}_{k,ii}^{(t)}&amp;S_{k,i}^{(t)}\text{
is in the top- }b^{(t)}\text{ of }S^{(t)}\\0&amp;\text{
otherwise}&amp;\end{cases}\]</span></p>
<p>训练损失中添加了额外的惩罚项，以规范奇异矩阵P和Q的正交性，从而避免SVD的大量计算并稳定训练。</p>
<p><span class="math display">\[R(P,Q)=\left\|P^\top
P-I\right\|_\mathrm{F}^2+\left\|QQ^\top-I\right\|_\mathrm{F}^2\]</span></p>
<p>最终，微调的损失函数为</p>
<p><strong>重要结论</strong></p>
<style>.fsytdnysoken{zoom:50%;}</style>
<img data-src="/LLM-PEFT/image-20240723112058468.png" class="fsytdnysoken" alt="image-20240723112058468">
<p>AdaLoRA 总是倾向于将更多预算分配给 FFN 和顶层，即 FFN
模块和顶层的权重矩阵对于模型性能更为重要。</p>
<h2 id="adapter-tuning">Adapter Tuning</h2>
<p>在 Transformer Layer 的 Self-Attetion 和 FFN
之后插入一个先降维再升维的 MLP（以及一层残差和Layer
Normalization）来学习模型微调的知识。</p>
<style>.vvjsbcolbpew{zoom:50%;}</style>
<img data-src="/LLM-PEFT/image-20240723101505442.png" class="vvjsbcolbpew" alt="image-20240723101505442">
<p>图中，Adapter 即插入的 FF Down + 非线性激活层 + FF
up。在微调过程中，固定原始模型的参数，只微调适配层。</p>
<p>不足：</p>
<ul>
<li>需要修改原有模型结构，会增加模型参数量；</li>
</ul>
<p>变体：</p>
<ul>
<li><a
href="https://aclanthology.org/2020.findings-emnlp.41.pdf">Paper</a>：仅在
MLP 模块之后和 LayerNorm 之后使用适配器层</li>
</ul>
<h2 id="adapterfusion">AdapterFusion</h2>
<p>整合来自多个任务的知识的方法时，常遇到灾难性遗忘和多任务数据集平衡方面的困难。AdapterFusion
分离知识提取和知识组合这两个阶段，可以以非破坏性的方式有效地利用从多个任务中学到的表示。知识提取阶段学习Adapter
任务特定参数，其封装了特定于任务的信息；知识组合阶段将不同任务的 Adapter
组合到一起。</p>
<style>.kyvuvrqlgtrr{zoom:60%;}</style>
<img data-src="/LLM-PEFT/image-20240723102934378.png" class="kyvuvrqlgtrr" alt="image-20240723102934378">
<style>.ggcrcpbqepav{zoom:50%;}</style>
<img data-src="/LLM-PEFT/image-20240723103303792.png" class="ggcrcpbqepav" alt="image-20240723103303792">
<p>AdapterFusion
组件将在不同任务上训练的多个适配器的输出作为输入，并学习编码信息的参数化混合器，应用于单个任务多
Adapter 的场景和多任务混合的场景。单任务场景中，可以多个 Adapter
可用于提取同一下游任务不同维度的信息，再将他们融合起来。</p>
<p>优势：</p>
<ul>
<li>优于在单任务和多任务中训练的 Adapter
模型，可以视为多Adapter提取不同维度的信息，AdapterFusion
将他们融合起来。</li>
</ul>
<h2 id="adapterdrop">AdapterDrop</h2>
<p>该方法在不影响任务性能的前提下，动态高效的移除冗余的
Adapter，可以尽可能地减少模型的参数量，提高模型在反向传播（训练）和正向传播（推理）时的效率。</p>
<style>.dnpjjholnmbq{zoom:50%;}</style>
<img data-src="/LLM-PEFT/image-20240723103450147.png" class="dnpjjholnmbq" alt="image-20240723103450147">
<p>优势：</p>
<ul>
<li>通过从较低的 Transformer 层删除可变数量的Adaper来提升推理速度。
当对多个任务执行推理时，动态地减少了运行时的计算开销，并在很大程度上保持了任务性能；</li>
</ul>
<h2 id="mam-adapter">MAM Adapter</h2>
<p>分解了最先进的参数高效迁移学习方法的设计，并提出了一个在它们之间建立联系的统一框架。</p>
<style>.pkgblmgnycjg{zoom: 50%;}</style>
<img data-src="/LLM-PEFT/image-20240723104300363.png" class="pkgblmgnycjg" alt="image-20240723104300363">
<h2 id="unipeft">UniPEFT</h2>
<p>不同的 PEFT
方法在同一任务上的表现不同，因此为特定任务选择最合适的方法并非易事，特别是考虑到新
PEFT 方法和任务数量的快速增长。鉴于模型的多样性和模型选择的难度，UniPEFT
提出了一个统一的框架 UniPEFT，它将不同的PEFT
方法作为子模块，并通过门控机制学习激活最适合当前数据或任务设置的方法。</p>
<style>.lhvtueorgvzg{zoom:50%;}</style>
<img data-src="/LLM-PEFT/image-20240723104910206.png" class="lhvtueorgvzg" alt="image-20240723104910206">
<h2 id="pissa">PISSA</h2>
<blockquote>
<p>peft 包中有 PISSA 初始化方法
<code>self.pissa_init(adapter_name, init_lora_weights)</code></p>
</blockquote>
<p>PISSA 和 LoRA 主要的区别是初始化方式不同。同样基于低秩特性的假设，但
PISSA 不是去近似，而是直接基于原矩阵操作。</p>
<p>PiSSA 对预训练模型的参数矩阵<span class="math display">\[W\in
R^{m\times n}\]</span> 进行奇异值分解，其中前 r
个奇异值和奇异向量用来初始化适配器 (adapter) 的两个矩阵<span
class="math display">\[A\in R^{m\times r}\]</span> 和<span
class="math display">\[B\in R^{r\times n}\]</span> ，； <span
class="math display">\[r\ll\min(m,n)\]</span>
剩余的奇异值和奇异向量用来构造残差矩阵<span
class="math display">\[W^{res}\in R^{m\times n}\]</span> ，使得<span
class="math display">\[W=AB+W^{res}\]</span>
。因此，适配器中的参数包含了模型的核心参数，而残差矩阵中的参数是修正参数。通过微调参数量较小的核心适配器
A、B，冻结参数量较大的残差矩阵 <span
class="math display">\[\text{Wres}\]</span>
，就达成了用很少的参数近似全参数微调的效果。</p>
<style>.pbbvyridqweb{zoom:50%;}</style>
<img data-src="/LLM-PEFT/image-20240723093258953.png" class="pbbvyridqweb" alt="image-20240723093258953">
<p>优势</p>
<ul>
<li>相比于 LoRA，收敛速度更快，性能更好</li>
</ul>
<h2 id="vera">VeRA</h2>
<p>区别于Lora，Vera 将 A 和 B
矩阵按照高斯分布随机初始化并冻结，只训练两组直接和A、B相乘的一维参数。虽然直观看起来A和B像两个无用的张量，但实际上它们仍然是必不可少的，实验证明即使是随机张量也可以用于微调。</p>
<style>.rtvifiupiwdx{zoom:50%;}</style>
<img data-src="/LLM-PEFT/image-20240723100503853.png" class="rtvifiupiwdx" alt="image-20240723100503853">
<p>优势：</p>
<ul>
<li>VeRA显著减少了可训练参数的数量（LoRA相比参数减少了10倍），而精度没有损失；</li>
<li>缩放向量尺寸小，可以将许多版本驻留在单个GPU的有限内存中，从而大大提高了服务效率，适合于需要频繁交换大量微调模型的场景，比如针对个人用户个性化的基于云的人工智能服务；</li>
</ul>
<h2 id="dora">DoRA</h2>
<p>将每个高阶矩阵都分解为 1*k 大小矩阵和 d*k 方向矩阵的乘积，LoRA
倾向于同时改变幅度和方向，DoRA可以更容易地将二者分开调整，或者用另一个的负变化来补偿一个的变化。</p>
<style>.forqleixyhfq{zoom:50%;}</style>
<img data-src="/LLM-PEFT/image-20240723110508921.png" class="forqleixyhfq" alt="image-20240723110508921">
<h2 id="slora">SLORA</h2>
<p>一个 GPU 上并行执行多个 lora adapters 的微调</p>
<p>S-LoRA 能够在单个 GPU 上或跨多个 GPU 以较小的开销为数千个 LoRA
适配器提供服务。该方法将所有 LoRA
模块存储在主内存中，并将当前运行的查询使用的适配器获取到 GPU
内存，提出采用统一分页技术，使用统一的内存池来管理具有不同等级的动态适配器权重和具有不同序列长度的
KV 缓存张量。此外，该方法采用新颖的张量并行策略和高度优化的定制 CUDA
内核，可视为定制化的 LoRA微调高效计算流程。</p>
<h2 id="galore">GaLore</h2>
<p>梯度低秩投影（GaLore）是一种全量参数学习的训练策略，但比常见的低秩自适应方法（LoRA）更节省内存。其关键思想是利用权重矩阵
W 的梯度 <span class="math display">\[G\in \mathbb{R}^{m\times
n}\]</span> 缓慢变化的低秩结构，而不是试图将权重矩阵本身近似为低秩。</p>
<p>优势：</p>
<ul>
<li>节省内存（三倍）；</li>
<li>性能不错；</li>
</ul>
<p>不足：</p>
<ul>
<li>训练速度慢（三倍）；</li>
</ul>
<h2 id="lora-1">LoRA+</h2>
<p>LoRA 中的适配器矩阵 A 和 B 以相同的学习率更新，实验表明对 A 和 B
使用相同的学习率并不能实现有效的特征学习，LoRA+ 通过精心选择的固定比率为
LoRA 适配器矩阵 A 和 B 设置不同的学习率，纠正 LoRA 的这种次优性。</p>
<style>.oowczpmsgudg{zoom: 67%;}</style>
<img data-src="/LLM-PEFT/image-20240725102452954.png" class="oowczpmsgudg" alt="image-20240725102452954">
<h2 id="longlora">LongLoRA</h2>
<p>LongLoRA
扩展了模型的上下文，同时保留了其原始架构，并且与大多数现有技术兼容。一方面，虽然推理过程中需要密集的全局注意力，但微调过程更需要稀疏的局部注意力实现有效且高效反向传播。由此，该方法提出转移稀疏注意力</p>
<p><span class="math display">\[S^2-Attn\]</span></p>
<p>有效地实现了上下文扩展。另一方面，除了在线性层中训练 LoRA
权重之外，LongLoRA
还进一步使嵌入层和归一化层变得可训练，由此可以表现出较好的性能。从实现上来看，该方法在训练中只需两行代码即可实现，且在推理中是可选的，不会占用额外计算资源。</p>
<img data-src="/LLM-PEFT/image-20240725143254778.png" class="" title="image-20240725143254778">
<h2 id="rslora">RsLoRA</h2>
<p>LoRA通过在选定层添加可训练的低秩Adapter来实现参数有效的微调。每个LoRA由两个低秩矩阵乘积组成，并乘以一个与秩相关的因子，传统的LoRA采用“直接除以秩的因子”的方法过于激进，导致高秩Adapter的学习速度减缓，性能受限。因此，在实际应用中，LoRA通常仅限于使用非常低的秩。</p>
<p>rsLoRA深入研究了 LoRA 的缩放因子对学习过程的影响，并证明了 LoRA
应该除以秩的平方根而不是秩，通过使用较大的秩在训练期间增加计算资源以获得更好的微调性能，同时不改变推理计算成本。</p>
<style>.wtnpsfwjvxxm{zoom:67%;}</style>
<img data-src="/LLM-PEFT/image-20240903102620304.png" class="wtnpsfwjvxxm" alt="image-20240903102620304">
<h2 id="llama-pro">LLaMA Pro</h2>
<p>该方法提出的Block
Expansion方法，即块扩展，在保持预训练模型参数不变的基础上，增加新的block来适应新的训练任务。这些新加入的block与原有block协同工作，既保留了模型原有的知识，又能够适应新的训练数据和任务需求。</p>
<style>.nmivbahrmlqe{zoom:50%;}</style>
<img data-src="/LLM-PEFT/image-20240729142017433.png" class="nmivbahrmlqe" alt="image-20240729142017433">
<h2 id="方法性能对比">方法性能对比</h2>
<p>从方法类型、是否存储高效、是否内存高效、反向传播成本、推理开销五个维度比较
PEFT 方法：</p>
<img data-src="/LLM-PEFT/image-20240714150443014.png" class="" title="image-20240714150443014">
<p>各种参数高效方法的参与训练的参数量、最终模型与原始模型的改变参数（delta值）以及论文中参与评估的模型的范围：</p>
<img data-src="/LLM-PEFT/image-20240714150638355.png" class="" title="image-20240714150638355">
<p>PEFT
方法在何种模型大小上进行过评估，以及在论文中通常使用的可训练参数数量。我们所说的可训练参数数量是指由梯度优化算法更新的参数数量，而不是我们用“更改参数”表示的原始模型与最终模型之间的差异。对于重参数化方法，我们报告了重参数化前后的参数数量。由于S4模型在不同层使用了不同的方法，因此估算其更新后的参数数量比较复杂。我们报告了在已发表的文献中对这些方法进行评估的范围。</p>
<p>近年来，基于Transformer架构的大语言模型（LLM），在众多自然语言处理（NLP）任务达到了最佳性能表现。目前，构建领域专用LLM的主流策略是：在海量通用数据集上预训练的大语言模型（PLM），并通过针对特定下游任务的微调（Fine-tuning）。相较于直接采用PLM，针对下游任务的微调能显著提升模型性能。然而，随着LLM参数规模急剧增长，在消费级硬件上进行微调变得不切实际。</p>
<p>为应对此挑战，研究者们近年来提出了参数高效微调技术（Parameter-Efficient
Fine-Tuning,
PEFT），其核心思想在于固定PLM的大部分参数，仅调整一小部分关键参数或引入额外参数，以接近直接微调PLM的效果。这种方法不仅保留了PLM的广泛知识库，还显著降低了计算与存储需求，为在资源受限环境下高效微调LLM开辟了新路径。</p>
<h1 id="高效量化">高效量化</h1>
<h2 id="qlora">QLoRA</h2>
<p>创新点：</p>
<ul>
<li>4位NormalFloat（NF4）：这是一种针对正态分布权重设计的信息理论上最优的量化数据类型。相较于传统的4位整数和4位浮点数，NF4为正态分布数据提供了更优异的实证性能。</li>
<li>双重量化：QLora引入了对量化常数的二次量化，进一步减小了缓存占用。这种双重量化机制包含对普通参数的一次量化和对量化常数的再量化，从而在不牺牲精度的前提下进一步压缩模型。</li>
<li>分页优化器：这是一种智能的内存管理技术，当GPU内存不足时，它可以将部分数据移到系统内存中，并在需要时调回GPU内存。这有助于处理长序列或大批量数据时的内存峰值问题。</li>
</ul>
<p>优势：</p>
<ul>
<li>提出了高效且有效的量化技术，使在单个GPU上微调超大型参数模型成为可能；</li>
</ul>
<h2 id="loftq">LoftQ</h2>
<p>该方法一种新的量化框架，在对 LLM 进行量化的同时，为 LoRA
微调找到合适的低秩初始化。这种初始化减轻了量化模型和全精度模型之间的差异，并显着提高了下游任务的泛化能力。</p>
<h2 id="gptq">GPTQ</h2>
<h2 id="awq">AWQ</h2>
<p>GGUF</p>
<h1 id="微调方法适配">微调方法适配</h1>
<blockquote>
<p>如何将微调模型应用在 自定义/未被官方适配 的大模型上</p>
</blockquote>
<p>通过 <code>target_modules</code> 和 <code>modules_to_save</code>
实现自定义可训练参数和模块</p>
<p>Merge Peft Model：将预训练好的 Lora 或 IA3
的模型参数融入预训练模型中，实现不修改原模型的结构和参数量</p>
]]></content>
      <categories>
        <category>LLM微调</category>
      </categories>
      <tags>
        <tag>大模型微调</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 Langchain 的 RAG 架构底层原理</title>
    <url>/LLM-RAG-Langchain/</url>
    <content><![CDATA[<p>当下，微调（Fine-Tuning）和检索增强生成（Retrieval-Augmented
Generation，简称RAG）是大型语言模型（LLM）与专有数据之间融合贯通的最主流的两种方法。微调对数据集和硬件要求高，如果没有足够大的平台很难深入研究，因此本文主要涉及检索增强生成（RAG架构）领域知识。</p>
<h1 id="概念">概念</h1>
<p>RAG 是一种使用额外数据增强 LLM 知识的技术，是 2020 年发表的论文 <a
href="https://arxiv.org/abs/2005.11401">面向知识密集型 NLP
任务的检索增强生成</a>中提出的新思想。LLM
通过外部知识源获取额外信息，从而生成更准确、更符合上下文的答案，并减少错误信息（或称为“幻觉”，即模型对用户意图的误解或在处理特定指示时产生了不准确的推断）。典型的
RAG 应用程序有两个主要组件：</p>
<ul>
<li>索引：用于引入源数据并对其进行<strong>索引</strong>的管道
<ul>
<li>加载：将数据库中的大段文本读入系统</li>
<li>拆分：大块数据不便于搜索，且模型的上下文窗口有限，因此需要拆分数据</li>
<li>存储：采用向量数据库和索引存储数据</li>
</ul></li>
<li>检索和生成：实际的 RAG
链，它在运行时接受用户查询并从索引中检索相关数据，然后将其传递给模型
<ul>
<li>检索：将用户的查询通过嵌入模型转化为向量，以便与向量数据库中的其他上下文信息进行比对。通过这种相似性搜索，可以找到向量数据库中最匹配的前
k 个数据</li>
<li>生成：将用户的查询和检索到的额外信息一起嵌入到一个预设的提示模板中，这个经过检索增强的提示内容会被输入到大语言模型
(LLM) 中，以生成所需的输出</li>
</ul></li>
</ul>
<p>从原始数据到响应生成最常见的流程图如下：</p>
<img data-src="/LLM-RAG-Langchain/x7ta8v77.png" class="" title="x7ta8v77">
<p>流程图2：</p>
<img data-src="/LLM-RAG-Langchain/c9b5e6b82c3243f3b51817fe9c5bcc72.png" class="" title="img">
<p>RAG 测评指标：</p>
<style>.wpvoqkhswtin{zoom:40%;}</style>
<img data-src="/LLM-RAG-Langchain/image-20240820085527076.png" class="wpvoqkhswtin" alt="image-20240820085527076">
<h1 id="langchain">Langchain</h1>
<p>LangChain
采用组件化设计的思想，将语言模型开发分为多个子任务：<strong>对话历史
Memory、提示工程 Prompt、输出解析 Parase、LLM链 Chain、索引
Indexes、代理 Agents</strong>。Langchain
模块化设计的中心思想是提升代码维护、扩展和重用的能力，可以快速开发多轮提示以及解析输出的应用。</p>
<p>此外，Langchain
还提供了对话过程中需要的基本功能，如：<strong>文档加载器
UnstructuredBaseLoader、文档分割器 TextSplitter、向量数据库存储和搜索
BaseChatMemory、多种工具类链调用 MapReduceDocumentsChain</strong></p>
<p>还有额外的功能：API 用量记录、数据流返回 acall、缓存
SQLite、支持多种模型接口
OpenAI、向量数据库接口langchain.vectorstores</p>
<h2 id="模型链-chain">模型链 Chain</h2>
<p>链（Chains）通常将大语言模型（LLM）与其他组件组合在一起来构建更复杂的链。比如，LLMChain
允许我们对创建的 Prompt 使用大模型；</p>
<p>Chain 基类是所有 Chain
对象的起点，处理输入、输出、历史和回调等功能，支持同步和异步调用，内部组件也可以通过回调进行交互；</p>
<p>自定义 Chain 需要继承 Chain 基类，实现 _call/_acall
方法定义调用逻辑；</p>
<h2 id="对话历史-memory">对话历史 Memory</h2>
<p>根据需求可以将历史存储在
SQLite、qdrant等数据库中，下面代码将历史存储在缓存中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.memory <span class="keyword">import</span> ConversationBufferMemory</span><br><span class="line">memory = ConversationBufferMemory(</span><br><span class="line">    memory_key=<span class="string">&quot;history&quot;</span>, <span class="comment"># 与 prompt 的输入变量保持一致。</span></span><br><span class="line">    return_messages=<span class="literal">True</span> <span class="comment"># 将以消息列表的形式返回聊天记录，而不是单个字符串</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="提示工程-prompt">提示工程 Prompt</h2>
<p>Prompt 很少是写明不变的，通常从多个组件构建而成的。 PromptTemplate
负责构建这个输入。</p>
<p><strong>输出解析 Parase</strong> 是提示工程的一种：</p>
<ul>
<li><code>get_format_instructions() -&gt; str</code>：方法，返回一个包含有关如何格式化语言模型输出的字符串，即提示
Prompt。</li>
<li><code>parse(str) -&gt; Any</code>：方法，接受一个字符串（假定为语言模型的响应）并将其解析为某个结构。</li>
<li><code>parse_with_prompt(str) -&gt; Any</code>：一个方法，它接受一个字符串（假设是语言模型的响应）和一个提示（假设是生成这样的响应的提示），并将其解析为某种结构。提示在此大多数情况下是为了提供信息以便
OutputParser 重新尝试或以某种方式修复输出。</li>
</ul>
<h2 id="索引-indexes">索引 Indexes</h2>
<p>结构化文档，以便 LLM 可以与外部文档交互。
LangChain有许多模块可帮助您加载、结构化、存储和检索文档。</p>
<h2 id="代理-agents">代理 Agents</h2>
<p>代理涉及 LLM
做出行动决策（Observation）、执行该行动（Action）、查看一个观察结果（Observation），并重复该过程直到完成。LangChain
提供了一个标准的代理接口，一系列可供选择的代理，以及端到端代理的示例。</p>
<ul>
<li>使用工具并观察其输出</li>
<li>生成相应返回给用户</li>
</ul>
<h1 id="文本召回">文本召回</h1>
<blockquote>
<p>RAG
将匹配分为多个阶段，可分为：粗召回、细召回、粗排序、精排序、再排序。该任务包括多个子任务，如文本相似度计算、问答匹配、对话匹配，类似于RAG的文本抽取式阅读理解和多项选择</p>
</blockquote>
<p>RAG 采取召回（IF-IDF、BM25）、粗排（双塔 Bert
模型、Sentence-Bert、text2vec、uniem）、精排（单塔 Bert
模型），得到相关的文档输入 LLM 中。</p>
<h2 id="基于词匹配">基于词匹配</h2>
<blockquote>
<p>传统方法将词匹配、词距等分数作为特征，用线性模型或树模型预测相关性，效果远不如深度学习。</p>
</blockquote>
<p>将查询文本分词，词在文档 d 中出现的次数越多，则查询文本和文档 d
越相关</p>
<h3 id="if-idf">IF-IDF</h3>
<p><strong>概念</strong></p>
<p>词袋模型：（bag of words）只考虑词频，不考虑词的顺序和上下文</p>
<p>词频 TF：每个词在文档中出现的次数的集合；<span
class="math inline">\(\sum_{t\in\mathcal{Q}}\operatorname{tf}_{t,d}\)</span></p>
<ul>
<li>缺陷：文档越长，TF 越大；解决：除以文档长度，归一化；<span
class="math inline">\(\sum_{t\in
Q}\frac{\mathrm{tf}_{t,d}}{l_d}\)</span></li>
<li>缺陷：每个词重要性不同；解决：语义重要性（term
weight），在文档中出现的越多，权重越低；</li>
</ul>
<p>文档频率 DF：词 t 在多少文档中出现过，定义“词”区别文档的能力；</p>
<p>逆文档排序 IDF：衡量一个词在 N 个文档中的重要性；<span
class="math inline">\(\mathrm{idf}_t=\mathrm{log}\frac
N{\mathrm{df}_t}\)</span></p>
<p><span class="math inline">\(\mathrm{TFIDF}(\mathcal{Q},d) =
\sum_{t\in\mathcal{Q}} \frac{\mathrm{tf}_{t,d}}{l_{d}} \cdot
\mathrm{idf}_{t}.\)</span></p>
<p>其中，查询词q的分词后得到 Q 集合，它与文档 d 的相关性用 TF-IDF
衡量；结果还取决于所采取的分词算法；</p>
<h3 id="bm25">BM25</h3>
<p>IF-IDF 的变种，k 和 b 是参数（通常设置为 k∈[1.2, 2]，b=0.75）</p>
<p><span class="math inline">\(\sum_{t\in
Q}\frac{\mathrm{tf}_{t,d}\cdot(k+1)}{\mathrm{tf}_{t,d}+k\cdot\left(1-b+b\cdot\frac{l_d}{\mathrm{mean}(l_d)}\right)}\cdot\ln\left(1+\frac{N-\mathrm{df}_t+0.5}{\mathrm{df}_t+0.5}\right)\)</span></p>
<h3 id="基于词距">基于词距</h3>
<p>两个词在文档中出现位置之间，间隔的词越少越可能相关；</p>
<p>简而言之，查询词切分后的 term
在文档中出现的次数越多越好，任意两个词之间的距离越近越好；</p>
<p>eg：<strong>OkaTP</strong></p>
<h2 id="基于深度学习">基于深度学习</h2>
<p><strong>基于交互策略的单塔模型</strong> 准确度更高</p>
<p>Bert 输出 similarity，二分类任务（相似/不相似）</p>
<p><strong>基于向量匹配的双塔模型 </strong>速度更快</p>
<p>Bert 输出 Sentence_Embedding，拟合 cos_Similarity（回归任务）</p>
<h1 id="评价指标">评价指标</h1>
<p>二分类评价指标 AUC</p>
<style>.tmzcozmulnir{zoom: 33%;}</style>
<img data-src="/LLM-RAG-Langchain/image-20240815155230728.png" class="tmzcozmulnir" alt="image-20240815155230728">
<h1 id="可信度-rag">可信度 RAG</h1>
<p>当检索返回的结果有错误或信息丢失时，会导致LLM回复出现幻觉。</p>
<p>为解决这个问题的三个指标：可信度（Faithfulness）、答案相关性（Answer
Relevance）、上下文相关性（Context Relevance）</p>
<h1 id="query-预处理">Query 预处理</h1>
<p>同义Query，</p>
<p>意图识别</p>
<h1 id="召回">召回</h1>
<p>索引技术：倒排索引、压缩倒排索</p>
<p>检索模型：BM25、BERT</p>
<p>引入上下文信息，更好地理解用户意图</p>
<h1 id="langchain-chatchat-源码解读">Langchain-chatchat 源码解读</h1>
<h2 id="qa">Q&amp;A</h2>
<p>Embedding 模型怎么保持加载的：EmbeddingPool；</p>
<p>metaData 存在哪里：MySQL 数据库；</p>
<p>LLMChain 怎么区分chatprompt和prompt的：ChatOpenAI、OpenAI；</p>
<p>docstore 和 <code>index_to_docstore_id</code> 存在哪里：本地文件
<code>&#123;index_name&#125;.pkl</code>；</p>
]]></content>
      <categories>
        <category>LLM开发</category>
      </categories>
      <tags>
        <tag>RAG架构</tag>
        <tag>LLM应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 开发工具</title>
    <url>/Linux-Tool/</url>
    <content><![CDATA[<h1 id="vim">Vim</h1>
<h2 id="基本模式切换">基本模式切换</h2>
<ul>
<li><strong><code>i</code></strong>：进入插入模式，从光标前插入文本。</li>
<li><strong><code>a</code></strong>：进入插入模式，从光标后插入文本。</li>
<li><strong><code>Esc</code></strong>：退出插入模式，回到正常模式。</li>
<li><strong><code>v</code></strong>：进入可视模式，用于选择文本块。</li>
<li><strong><code>V</code></strong> 或
<strong><code>vv</code></strong>：进入可视行模式，选择整行文本。</li>
<li><strong><code>Ctrl + v</code></strong>：进入可视块模式，选择矩形区域。</li>
</ul>
<h2 id="光标移动">光标移动</h2>
<ul>
<li><strong><code>w</code></strong>：光标移动到下一个单词的开头。</li>
<li><strong><code>b</code></strong>：光标移动到上一个单词的开头。</li>
<li><strong><code>0</code></strong>：移动到行首。</li>
<li><strong><code>$</code></strong>：移动到行尾。</li>
<li><strong><code>gg</code></strong>：移动到文件的第一行。</li>
<li><strong><code>G</code></strong>：移动到文件的最后一行。</li>
<li><strong><code>H</code></strong>：移动到屏幕的顶部。</li>
<li><strong><code>M</code></strong>：移动到屏幕的中部。</li>
<li><strong><code>L</code></strong>：移动到屏幕的底部。</li>
</ul>
<h2 id="编辑文本">编辑文本</h2>
<ul>
<li><strong><code>x</code></strong>：删除光标所在的字符。</li>
<li><strong><code>dw</code></strong>：删除从光标到单词末尾的内容。</li>
<li><strong><code>dd</code></strong>：删除当前行。</li>
<li><strong><code>d$</code></strong>：删除从光标到行末的内容。</li>
<li><strong><code>yy</code></strong>：复制当前行。</li>
<li><strong><code>p</code></strong>：粘贴到光标之后。</li>
<li><strong><code>u</code></strong>：撤销上一步操作。</li>
<li><strong><code>Ctrl + r</code></strong>：重做撤销的操作。</li>
<li><strong><code>r</code></strong>：替换光标下的字符。</li>
<li><strong><code>ciw</code></strong>：删除光标所在的单词并进入插入模式。</li>
<li><strong><code>c$</code></strong>：删除从光标到行尾的内容并进入插入模式。</li>
</ul>
<h2 id="搜索和替换">搜索和替换</h2>
<ul>
<li><strong><code>/pattern</code></strong>：向下搜索
<code>pattern</code>。</li>
<li><strong><code>?pattern</code></strong>：向上搜索
<code>pattern</code>。</li>
<li><strong><code>n</code></strong>：跳到下一个搜索结果。</li>
<li><strong><code>N</code></strong>：跳到上一个搜索结果。</li>
<li><strong><code>:s/old/new/g</code></strong>：将当前行的所有
<code>old</code> 替换为 <code>new</code>。</li>
<li><strong><code>:%s/old/new/g</code></strong>：将整个文件中的所有
<code>old</code> 替换为 <code>new</code>。</li>
</ul>
<h2 id="文件操作">文件操作</h2>
<ul>
<li><strong><code>:w</code></strong>：保存文件。</li>
<li><strong><code>:q</code></strong>：退出 Vim。</li>
<li><strong><code>:wq</code></strong>：保存并退出。</li>
<li><strong><code>:q!</code></strong>：不保存强制退出。</li>
<li><strong><code>:e filename</code></strong>：打开文件
<code>filename</code>。</li>
<li><strong><code>:r filename</code></strong>：在当前文件中插入
<code>filename</code> 的内容。</li>
</ul>
<h1 id="screen">Screen</h1>
<h2 id="基本命令">基本命令</h2>
<ul>
<li><strong><code>screen</code></strong>：启动一个新的
<code>screen</code> 会话。</li>
<li><strong><code>screen -S session_name</code></strong>：启动一个命名为
<code>session_name</code> 的 <code>screen</code> 会话。</li>
<li><strong><code>screen -ls</code></strong>：列出当前所有的
<code>screen</code> 会话。</li>
<li><strong><code>screen -r</code></strong>：重新连接到一个
<code>screen</code> 会话（如果只有一个会话）。</li>
<li><strong><code>screen -r session_name</code></strong>：重新连接到一个名为
<code>session_name</code> 的 <code>screen</code> 会话。</li>
<li><strong><code>screen -d session_name</code></strong>：在其他地方的终端断开某个会话的连接。</li>
<li><strong><code>screen -d -r session_name</code></strong>：强制从其他地方的终端断开并重新连接到
<code>session_name</code> 会话。</li>
<li><strong><code>screen -X quit</code></strong>：关闭所有
<code>screen</code> 会话</li>
</ul>
<h2 id="在-screen-会话中操作">在 <code>screen</code> 会话中操作</h2>
<p>在 <code>screen</code> 会话中，所有命令都以 <code>Ctrl + a</code>
开头（表示“前缀键”），然后跟随其他按键来执行操作。</p>
<ul>
<li><strong><code>Ctrl + a, X</code></strong>：关闭当前的分割窗口。</li>
<li><strong><code>Ctrl + a, c</code></strong>：创建一个新的窗口。</li>
<li><strong><code>Ctrl + a, n</code></strong>：切换到下一个窗口。</li>
<li><strong><code>Ctrl + a, p</code></strong>：切换到上一个窗口。</li>
<li><strong><code>Ctrl + a, "</code></strong>：列出当前所有窗口，允许选择切换。</li>
<li><strong><code>Ctrl + a, 0-9</code></strong>：切换到指定编号的窗口（例如
<code>Ctrl + a, 1</code> 切换到窗口 1）。</li>
<li><strong><code>Ctrl + a, d</code></strong>：将当前
<code>screen</code> 会话断开（detach），会话继续在后台运行。</li>
<li><strong><code>Ctrl + a, A</code></strong>：重命名当前窗口。</li>
<li><strong><code>Ctrl + a, K</code></strong>：关闭当前窗口。</li>
<li><strong><code>Ctrl + a, S</code></strong>：水平分割当前窗口。</li>
<li><strong><code>Ctrl + a, |</code></strong>：垂直分割当前窗口。</li>
<li><strong><code>Ctrl + a, tab</code></strong>：在分割的窗口间切换焦点。</li>
<li><strong><code>Ctrl + a, Q</code></strong>：关闭除了当前窗口外的所有分割窗口。</li>
<li><strong><code>Ctrl + a, X</code></strong>：关闭当前的分割窗口。</li>
</ul>
<h2 id="会话管理">会话管理</h2>
<ul>
<li><strong><code>Ctrl + a, :quit</code></strong> 或
<strong><code>Ctrl + a, d</code></strong>：结束当前 <code>screen</code>
会话。</li>
<li><strong><code>Ctrl + a, :kill</code></strong>：强制关闭当前窗口。</li>
<li><strong><code>exit</code></strong>：退出当前 <code>screen</code>
会话。</li>
</ul>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Linux工具</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络知识点</title>
    <url>/Network/</url>
    <content><![CDATA[<h1 id="概览">概览</h1>
<p>OSI
七层模型：应用层、表示层、会话层、传输层、网罗层、数据链路层、物理层</p>
<p>TCP/IP 四层模型：应用层、传输层、网络层、网络接口层</p>
<ul>
<li><p>应用层，直接服务于用户。唯一运行在用户态的层：HTTP、FTP、Telnet、DNS、SMTP、DHCP</p></li>
<li><p>传输层，应用层的技术支持。应用层数据超过 MSS 会将其切分成 TCP
段，传输层报文中包括了端口号，用于区分报文属于哪个应用：TCP、UDP</p></li>
<li><p>网络层，负责数据在网络中的传输，即寻址和路由。超过 MTU
会切分，IP地址代表网络号和主机号：IP、ARP、ICMP</p></li>
<li><p>传输层，关注链路级别的传输</p></li>
</ul>
<p>应用数据转换到传输块的过程：</p>
<style>.xrvagxmvfmct{zoom: 50%;}</style>
<img data-src="/Network/12.jpg" class="xrvagxmvfmct" alt="img">
<h2 id="访问网站的过程">访问网站的过程</h2>
<style>.bbpvmsdfxrol{zoom: 67%;}</style>
<img data-src="/Network/image-20240730153032143.png" class="bbpvmsdfxrol" alt="image-20240730153032143">
<ol type="1">
<li>解析 URL</li>
<li>DNS 查询服务器 IP
地址（本地域名服务器-&gt;根域名服务器-&gt;顶级域名服务器）</li>
<li>操作系统协议栈，包括传输层和网络层协议实现</li>
<li>TCP 建立连接（SYN_SEND、SYN_RECE、ESTABLISHED）</li>
<li>基于端口的 TCP 可靠传输</li>
<li>基于地址的 IP 定位传输</li>
<li>头部加上发送和接收方的 MAC 头部，ARP 查找接收端的 MAC</li>
<li>网卡，帧校验符</li>
<li>交换机，以太网设备，基于 MAC 地址表转发，没有缓存就广播</li>
<li>路由器，和网卡类似，各个端口都具有 MAC 和
IP。通过路由表确定要到目的地 IP 需要走哪个端口，并替换帧的源、目标
MAC</li>
</ol>
<p>在网络包传输的过程中，源 IP 和目标 IP 始终是不会变的（前提：没有使用
NAT 网络的），一直变化的是 MAC 地址，因为需要 MAC
地址在以太网内进行两个设备之间的包传输</p>
<p>校验过程：MAC 地址、IP 地址、序列号、端口</p>
<ol start="11" type="1">
<li>TCP 四次挥手（FIN_WAIT_1、FIN_RECE、FIN_WAIR_2、LAST_ACK）</li>
</ol>
<h2 id="linux-实现数据包收发">Linux 实现数据包收发</h2>
<p><strong>发送</strong></p>
<p>NAPI
机制：不采用中断的方式读取数据，而是首先采用中断唤醒数据接收的服务程序，然后
poll 的方法来轮询数据</p>
<p>DMA 技术：将网络包写入到指定的内存地址，接着网卡向 CPU
发起硬件中断，当 CPU
收到硬件中断请求后，根据中断表，调用已经注册的中断处理函数</p>
<p>硬中断先把收到的数据存在内存中，暂时屏蔽 CPU
中断，后续软中断统一处理先前的数据</p>
<p><strong>接收</strong></p>
<ol type="1">
<li>将用户待发送的数据从用户态拷贝到内核态 sk_buff
内存，并将其加入到发送缓冲区；</li>
<li>克隆一份 sk_buff 的副本，用于网络层传输，传输层保留原始 sk_buff
直到接收到 ACK，以保证可靠传输；</li>
<li>当 IP 层发现数据包大于 MTU 时，会申请额外的
sk_buff，并将原来的数据包拆分成多个小的 sk_buff；</li>
</ol>
<h1 id="应用层-http">应用层 HTTP</h1>
<blockquote>
<p>HTTP
是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」</p>
</blockquote>
<p>常用字段</p>
<p><strong>Content-Length</strong>：HTTP 协议通过设置回车符、换行符作为
HTTP header 的边界，通过 Content-Length 字段作为 HTTP body
的边界，这两个方式都是为了解决“粘包”的问题。</p>
<p>HTTP/1.1 优化</p>
<ul>
<li>长连接，复用 TCP 连接</li>
<li>缓存：强制缓存和协商缓存</li>
<li>压缩</li>
<li>管道传输</li>
<li>灵活、易于扩展</li>
</ul>
<p>HTTP/2 优化</p>
<ul>
<li>头部压缩</li>
<li>并发传输</li>
<li>服务端主动推送</li>
<li>二进制帧格式传输</li>
</ul>
<p>HTTP/3 优化</p>
<ul>
<li>提出了 QUIC 传输层协议代替
tcp。quic是基于udp实现的，在无连接的基础上实现了可靠和安全
<ul>
<li>更快的请求多路复用</li>
<li>避免队头阻塞</li>
<li>更快的建立连接</li>
</ul></li>
</ul>
<p>HTTPS</p>
<ul>
<li>加密传输：在应用层和传输层之间加了 SSL/TLS 安全协议；建立连接时需要
SSL/TLS 的握手过程；使用时需要向 CA 申请数字证书</li>
<li>摘要算法 + 数字签名
<ul>
<li>混合加密：建立连接用非对称加密：公钥和私钥；传输数据用对称加密：一个密钥</li>
<li>摘要算法：用摘要算法（哈希函数）来计算出内容的哈希值，哈希值是唯一的，且无法通过哈希值推导出内容</li>
<li>数字签名：通过「私钥加密，公钥解密」的方式，来确认消息的身份</li>
<li>数字证书：通过第三方 CA 保证服务器的公钥私钥没有被别人替换过</li>
</ul></li>
<li>建立连接：RSA算法
<ul>
<li>ClientHello：客户端生产随机数 Client Random</li>
<li>SeverHello：服务端生产随机数 Server Random、数字证书</li>
<li>客户端回应：获取证书中的服务器公钥、加密通信算法改变通知、公钥加密随机数
pre-master key</li>
<li>三个随机数算出<strong>会话密钥</strong>，双方都通知对方后续请求都使用会话密钥加密通信</li>
</ul></li>
</ul>
<h1 id="传输层-tcp">传输层 TCP</h1>
<blockquote>
<p>负责为应用层提供网络支持，实现应用到应用的数据传输</p>
</blockquote>
<p>TCP ：面向连接的、可靠的、基于字节流的</p>
<p>三次握手</p>
<style>.omxlvfnljkbi{zoom:50%;}</style>
<img data-src="/Network/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png" class="omxlvfnljkbi" alt="TCP 三次握手">
<p>四次挥手【closed_wait；last_ack】</p>
<style>.wghfockkbgjy{zoom: 67%;}</style>
<img data-src="/Network/format,png-20230309230614791.png" class="wghfockkbgjy" alt="客户端主动关闭连接 —— TCP 四次挥手">
<ul>
<li>首先确认客户端不会再发送请求给服务端</li>
<li>然后服务端在发送完数据后，再向客户端发送断开连接</li>
</ul>
<p>为什么这么设计？因为TCP是双向通信的可靠的协议，需要确保客户端和服务端都有收发数据包的能力；为后续传输做准备：序列号</p>
<p>流量控制、超时重传、拥塞控制</p>
<p><a
href="https://blog.csdn.net/dl962454/article/details/115796513">拥塞控制</a>：慢开始（每经过一个传输轮次，拥塞窗口
cwnd 就加倍）、拥塞避免（慢开始门限
ssthresh）、快重传（连续收到三个重复确认就立即重传对方尚未收到的报文段，不等待重传计时器到期）、快恢复</p>
<h1 id="网络层-ip">网络层 IP</h1>
<blockquote>
<p>负责路径传输过程中路径和节点的选择，实现设备到设备的数据传输</p>
</blockquote>
<p>寻址能力：网络号+主机号（子网掩码）</p>
<p>路由：数据包每到达一个节点，通过路由算法决定下一步走哪条路径</p>
<p>分片重组：以太网的 MTU（最大传输单元）是 1500
字节。在分片传输中，一旦某个分片丢失，则会造成<strong>整个 IP
数据报作废</strong>，所以 TCP 引入了 MSS 也就是在 TCP 层进行分片不由 IP
层分片，那么对于 UDP 我们尽量不要发送一个大于 MTU 的数据报文</p>
<p>ICMP：诊断和通知出错</p>
<p>NAT：网络地址转换</p>
<p>DHCP：动态获取 IP 地址</p>
<p>ARP：下一跳的 MAC 地址</p>
<p>DNS：域名解析</p>
<p>IGMP：组播</p>
]]></content>
      <categories>
        <category>八股文</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统知识点</title>
    <url>/OS/</url>
    <content><![CDATA[<p>重点：线程进程、死锁</p>
<h1 id="内存管理">内存管理</h1>
<h2 id="虚拟内存">虚拟内存</h2>
<p>CPU
只会访问虚拟内存地址，在操作总线前，通过一个地址转换硬件将虚拟内存地址转换为物理内存地址</p>
<p>进程隔离：将虚拟内存映射到物理内存，进程之间的地址空间相互隔离，互不干扰</p>
<p>虚拟内存空间：</p>
<style>.zbmdsxpvsltq{zoom:50%;}</style>
<img data-src="/OS/image-20240518105657086.png" class="zbmdsxpvsltq" alt="image-20240518105657086">
<p>用户态虚拟内存空间是相互隔离相互独立的；内核虚拟内存空间是各个进程共享的；</p>
<h1 id="进程管理">进程管理</h1>
<p>数据结构 PCB</p>
<p><strong>进程和线程的区别</strong></p>
<p>线程是调度的基本单位，而进程则是资源拥有的基本单位。</p>
<ul>
<li>进程是资源（包括内存、打开的文件等）分配的最小单位，线程是 CPU
调度的最小单位；</li>
<li>进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈，线程之间共享地址空间和文件等资源；</li>
<li>线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；</li>
<li>线程能减少并发执行的时间和空间开销；</li>
</ul>
<h2 id="进程间通信方式">进程间通信方式</h2>
<p>匿名管道 / 命名管道</p>
<p>消息队列</p>
<p>共享内存+信号量</p>
<p>Socket</p>
<h2 id="乐观锁悲观锁">乐观锁悲观锁</h2>
<p>CAS 是乐观锁没错，但是 CAS 和自旋锁不同之处，自旋锁基于 CAS 加了while
或者睡眠 CPU
的操作而产生自旋的效果，加锁失败会忙等待直到拿到锁，自旋锁是要需要事先拿到锁才能修改数据的，所以算悲观锁。</p>
<h2 id="线程崩溃">线程崩溃</h2>
<p>1、如果线程是<strong>非法访问内存</strong>引起的崩溃，其对应进程一定会崩溃。</p>
<p>2、进程崩溃的本质是：操作系统对进程发出了信号，例如非法访问内存的信号是
SIGSEGV（序号 11）</p>
<p>3、想要防止进程奔溃，需要自定义信号处理函数去拦截 SIGSEGV 信号。参考
JVM 中线程崩溃但 JVM 进程不会崩溃</p>
<h1 id="网络系统">网络系统</h1>
<h2 id="io-多路复用">I/O 多路复用</h2>
<p><strong>单个进程或线程同时监视多个文件描述符</strong>，如网络连接或文件句柄。当这些描述符中的任何一个就绪时，比如有数据可读或可写，多路复用机制就能够通知应用程序进行相应的读写操作。常见的IO多路复用技术包括
select、poll 和 epoll 等。</p>
<p>select</p>
<p>将已连接的 Socket 都放到一个文件描述符集合，然后调用 select
函数将文件描述符集合拷贝到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过遍历文件描述符集合的方式，当检查到有事件产生后，将此
Socket 标记为可读或可写，
接着再把整个文件描述符集合拷贝回用户态里，然后用户态还需要再通过遍历的方法找到可读或可写的
Socket，然后再对其处理。<strong>2
次「遍历」文件描述符集合</strong>，<strong>2
次「拷贝」文件描述符集合</strong>。</p>
<p>poll</p>
<p>它使用一个 pollfd
结构来表示被监视的文件描述符及其事件，与select相比，poll没有文件描述符数量的限制，因为它基于链表来存储。<strong>都是使用「线性结构」存储进程关注的
Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的
Socket，时间复杂度为
O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合</strong></p>
<p>epoll</p>
<img data-src="/OS/640.webp" class="" title="图片">
<ul>
<li>epoll
只在初始时完成一次文件描述符的注册，避免了每次调用时的拷贝开销；</li>
<li>当有一个或多个文件描述符就绪时，会调用回调函数将 Socket
集合一次性传递到就绪事件列表中，并通知用户空间，这使得 epoll
在处理大量文件描述符时仍然能保持高效；</li>
<li>当用户调用 epoll_wait()
返回有事件发生的文件描述符的个数，明确指出了哪些文件描述符是就绪的，无需像
select 和 poll 遍历所有 socket 集合；</li>
</ul>
<p><strong>触发时机</strong></p>
<ul>
<li>边缘触发【epoll】：只有当文件描述符的状态从不就绪变为就绪时，epoll
才会发出通知；一旦通知过后，除非状态再次发生变化，否则不会再次通知；</li>
<li>水平触发【select/poll】：只要文件描述符处于就绪状态，epoll就会持续发出通知，直到数据处理完毕；</li>
</ul>
]]></content>
      <categories>
        <category>八股文</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>论文阅读 RAFT</title>
    <url>/paper-PAFT/</url>
    <content><![CDATA[<p><a
href="https://gorilla.cs.berkeley.edu/blogs/9_raft.html">Paper</a></p>
<h1 id="创新点">创新点</h1>
<p>提出了新颖的特定 RAG 场景下的大模型微调方法（有明确文档域的
RAG）；</p>
<p>基于 COT，进一步完善了模型的推理能力；</p>
<h1 id="背景">背景</h1>
<p>当前的开放域对话模型做的是”闭卷考试“；</p>
<p>RAG 做的是”开卷考试“，其结果依赖于检索器的效果；</p>
<p>PAFT
应用于”特定领域的开卷考试“，模型先在特定域文档内学习如何做”开卷考试“，可以提高模型
RAG 的能力，还能减少幻觉的产生；</p>
<h1 id="实验">实验</h1>
<h2 id="方法">方法</h2>
<p>前置条件：<span class="math inline">\(\mathrm{Q}\)</span>问题； <span
class="math inline">\(\mathrm{A}^{*}\)</span> 答案； <span
class="math inline">\(\mathrm{D}^{*}\)</span> 答案来源文档； <span
class="math inline">\(D_n\)</span> 无关文档。</p>
<p>正例样本：<span class="math inline">\(Q+ \mathrm{D^*}
+D_1+D_2+\dots+D_k=&gt;\mathrm{A}^{*}\)</span></p>
<p>负例样本： <span
class="math inline">\(\mathrm{Q}+\mathbf{D}_{1}+\mathbf{D}_{2}+\dots+\mathbf{D}_{\mathbf{k}}=&gt;\mathbf{A}^{\star}\)</span></p>
<p>论文中基于数据集做全量 SFT 训练</p>
<h2 id="数据集">数据集</h2>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Question: The Oberoi family is part of a hotel company that has a head office in what city?</span><br><span class="line"></span><br><span class="line">context: [The Oberoi family is an Indian family that is famous for its involvement in hotels, namely through The Oberoi Group]...[It is located in city center of Jakarta, near Mega Kuningan, adjacent to the sister JW Marriott Hotel. It is operated by The Ritz-Carlton Hotel Company. The complex has two towers that comprises a hotel and the Airlangga Apartment respectively]...[The Oberoi Group is a hotel company with its head office in Delhi.]</span><br><span class="line"></span><br><span class="line">Instruction: Given the question, context and answer above, provide a logical reasoning for that answer. Please use the format of: <span class="params">##</span>Reason: &#123;reason&#125; <span class="params">##</span>Answer: &#123;answer&#125;.</span><br><span class="line"></span><br><span class="line">CoT Answer: <span class="params">##</span>Reason: The document <span class="params">##</span>begin<span class="built_in">_</span>quote<span class="params">##</span> The Oberoi family is an Indian family that is famous for its involvement in hotels, namely through The Oberoi Group. <span class="params">##</span>end<span class="built_in">_</span>quote<span class="params">##</span> establishes that the Oberoi family is involved in the Oberoi group, and the document <span class="params">##</span>begin<span class="built_in">_</span>quote<span class="params">##</span> The Oberoi Group is a hotel company with its head office in Delhi. <span class="params">##</span>end<span class="built_in">_</span>quote<span class="params">##</span> establishes the head office of The Oberoi Group. Therefore, the Oberoi family is part of a hotel company whose head office is in Delhi. <span class="params">##</span>Answer: Delhi</span><br></pre></td></tr></table></figure>
<p>从数据集 <code>Answer</code>
中可以看出，提问者引导模型以思维链的方式去回答问题，先说原因
<code>Reason</code> 再说答案 <code>Answer</code></p>
<p>文中采用 ##begin_quote## 和 ##end_quote##
表示直接从上下文复制粘贴的引用，研究人员发现这是防止模型产生幻觉并坚持提供的上下文的有效方法。</p>
<h2 id="实验结果">实验结果</h2>
<p>DFS（Domain-Specific Finetuning）：特定领域内微调</p>
<p>PAFT：特定领域微调+特定领域 RAG</p>
<img data-src="/paper-PAFT/image-20240815185100137.png" class="" title="image-20240815185100137">
<h1 id="总结">总结</h1>
<p>将模型在特定领域的文档上做思维链微调</p>
<ul>
<li>通过特定领域微调，模型可以学会如何做“开卷考试“；</li>
<li>当领域内数据发生一些变化时，模型依然能找到答案，即使没有正确答案也不会出现幻觉；</li>
<li>可以认为，模型需要专业的微调来训练其在特定领域的
RAG（开卷考试）能力；</li>
</ul>
]]></content>
      <categories>
        <category>读论文</category>
        <category>LLM微调</category>
      </categories>
      <tags>
        <tag>大模型微调</tag>
      </tags>
  </entry>
  <entry>
    <title>实习笔试题汇总</title>
    <url>/%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<ol start="2024" type="1">
<li></li>
</ol>
<h1 id="美团笔试">2024.4.27 美团笔试</h1>
<p>和携程差不多，签到题速通，后续疯狂折磨人，过不了一点。感觉题目难度差的好大，要么我秒杀它，要么它秒杀我</p>
<p><strong>第三题</strong></p>
<blockquote>
<p>回溯写了半天，结果只能过20%。看别人是用前缀和+dp，那就是和腾讯第四题类似了，当时学会了现在又忘了，真难崩。</p>
</blockquote>
<p>小美拿到了一个数组，她每次操作可以将两个相邻元素合并为一个元素，合并后的元素为原来两个元素之和。小美希望最终数组的最小值不小于
k。她想知道有多少种不同的合并结果?</p>
<p>输入描述：第一行输入两个正整数n,k，代表数组大小和数组的最大值。第二行输入几个正整数q:，代表小美拿到的数组。1
≤ n,k,ai &lt; 200</p>
<p>输出描述：输出一个整数，代表小美可以得到多少种不同的结果。由于结果可能很大，输出对10^9+7取模的结果。</p>
<p>eg：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">4 4</span><br><span class="line">2 3 4 5</span><br></pre></td></tr></table></figure>
<p>输出 4</p>
<p><strong>回溯</strong>解法，只过20%（加了dp保存过程值也没用）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution_3</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp;</span><br><span class="line">    <span class="type">int</span>[] a;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dp = <span class="keyword">new</span> <span class="title class_">int</span>[a.length];</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        Arrays.fill(dp, -<span class="number">1</span>);</span><br><span class="line">        System.out.println(backtrack(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> sum, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index==a.length) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (sum==<span class="number">0</span> &amp;&amp; dp[index]!=-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> dp[index];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isBegin</span> <span class="operator">=</span> sum==<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=index; i&lt;a.length; i++) &#123;</span><br><span class="line">            sum += a[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sum&gt;=k) &#123;</span><br><span class="line">                cnt += backtrack(<span class="number">0</span>, i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isBegin) dp[index] = cnt;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt(), k = in.nextInt();</span><br><span class="line">        <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            a[i] = in.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Solution_3</span>().solve(a, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自己试试写<strong>前缀和+dp</strong>（思路重要真的很重要，二十分钟就写出来了）</p>
<blockquote>
<p>dp[i] 表示<del>数字 0-i 的方案数</del>[0, i)
的字串可以拆分的种类，状态转移方程为<span class="math inline">\(dp[i] =
\sum dp[j]\)</span>（j-i 大于等于 k 的数量总和，用前缀和求出）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt(), k = in.nextInt();</span><br><span class="line">        <span class="type">int</span>[] sum = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        sum[<span class="number">1</span>] = in.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            sum[i] += sum[i-<span class="number">1</span>] + in.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sum[i] - sum[j] &gt;= k) &#123;</span><br><span class="line">                    dp[i] += dp[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Q1</strong>：前缀和算法初始化时为什么都要设置
<code>[0, 0] = 1</code> 呢？ 如: <code>dp[0] = 1</code> or
<code>map.put(0,1)</code></p>
<p><strong>A1</strong>：想不明白呢，需要对状态转移数组 dp[]
的理解非常正确才行</p>
<p><strong>第四题</strong></p>
<p>小美拿到了一棵树，其中有一些节点被染成红色。</p>
<blockquote>
<p>大佬的思路：预打表小质数，然后dfs遍历连通块，统计块内每个红点的质因子，得到结点编号的乘积的质因子分解形式，根据质因子数量计算因子个数。对于我来说，需要背一下并查集的模板。</p>
</blockquote>
<p>小美定义一个红色连通块的权值为:所有节点编号乘积的因子数量。小美想知道，所有红色连通块的权值之和是多少?由于答案过大，请对10^9+
7取模。</p>
<p><strong>输入描述</strong>：</p>
<p>第一行输入一个正整数n，代表节点数量。
第二行输入一个长度为几的、仅由'R"和"W组成的字符串，第i个字符为'R'代表;号节点被染成红色，"W代表未被染色。保证至少有一个节点被染成红色。</p>
<p>接下来的n -
1行，每行输入2个正整数4,U，代表u号节点和u号节点有一条边连接。1 ≤n ≤
10^5, 1 ≤u,v≤n</p>
<p><strong>输出描述</strong>：</p>
<p>一个整数，代表所有红色连通块的权值之和。</p>
<h1 id="华为测评">2024.4.25 华为测评</h1>
<p>华子免笔试，只有测评了。看网上好多人测评挂了我都惊呆了，还好没和其他的厂一样直接做测评而是上我搜了下，其他的厂可以不去但华子我必然拿下（小心谨慎哈哈哈）</p>
<p>华子要什么样性格的人？（前后回答要一致）</p>
<ul>
<li>不需要凸显自己的能力、表达自己的个性，更多的是团队合作</li>
<li>遇到挫折要坚持，遇到问题会咨询</li>
<li>热爱工作，吃苦耐劳，积极向上</li>
</ul>
<p>（准备了又好像没准备，就这样吧，希望能过！阿弥陀佛财神爷保佑！）</p>
<p><strong>复盘</strong>：有些过于没有压力了，前面每一题都认真思考结果
40min 过完才做了一半，人家都是 40min
就做完了，实在是有些拖拉（但这个要认真选真的很难啊，得回忆自己平常的所思所想所做才然后选个答案，后续时间紧张直接主观臆断速度还是很快的）。<strong>只要时间不紧张就慢慢做，一旦时间紧张了才开始全神贯注做，这可真的是一个坏毛病，得改。</strong></p>
<p>后续学习工作中都应该有这个意识，主动养成专注的习惯，要做就认真仔细专注的做事情！</p>
<h1 id="携程笔试">2024.4.16 携程笔试</h1>
<p>前两道签到题，后面一个半小时纯折磨</p>
<p>第三题</p>
<p>游游拿到了一个数组，她每次操作可以将相邻的两个素数元素进山314行合并，合并后的新数为原来的两个数之和，并删除原来两个数。游游希望最终数组的元素数量尽可能少，你能帮帮她吗?</p>
<blockquote>
<p>第一行输入一个正整数n，代表数组的大小。
第二行输入几个正整数a_i，代表数组的元素 1 ≤ n &lt; 10^5 1 ≤ a_i &lt;
10^6</p>
</blockquote>
<p>返回合并结束后的元素的数量</p>
<p><strong>题目分析</strong>：素数是只能被1和自身整除的数。针对这道题可以用到，它的一大特性：除了
2 之外两个素数之和一定是偶数（即，一定不是素数）</p>
<p>因此只要先把所有 2
和素数合并，后续只需要判断还有多少相邻的素数即可。</p>
<p>做题的时候没有考虑到 <code>7 2 2 3</code> 这种情况，即素数和 2
合并完的结果如果是素数，还需要和判断他的左边还有没有
2，有的话还要合并，即代码中的 <code>i--</code> 部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrimeMerge</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        List&lt;Integer&gt; numbers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取数组元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            numbers.add(scanner.nextInt());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并素数，优先处理2</span></span><br><span class="line">        mergePrimesWithPriorityToTwo(numbers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出最终数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : numbers) &#123;</span><br><span class="line">            System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查一个数是否是素数的辅助函数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i * i &lt;= num; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergePrimesWithPriorityToTwo</span><span class="params">(List&lt;Integer&gt; numbers)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并2与其相邻的素数，得到一个新的素数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numbers.size(); ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers.get(i) == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// 检查左边是否有素数可以合并</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; isPrime(numbers.get(i - <span class="number">1</span>)) &amp;&amp; isPrime(numbers.get(i - <span class="number">1</span>) + <span class="number">2</span>)) &#123;</span><br><span class="line">                    numbers.set(i - <span class="number">1</span>, numbers.get(i - <span class="number">1</span>) + <span class="number">2</span>);</span><br><span class="line">                    numbers.remove(i);</span><br><span class="line">                    i--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; numbers.size() - <span class="number">1</span> &amp;&amp; isPrime(numbers.get(i + <span class="number">1</span>)) &amp;&amp; isPrime(numbers.get(i + <span class="number">1</span>) + <span class="number">2</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 检查右边是否有素数可以合并</span></span><br><span class="line">                    numbers.set(i, numbers.get(i) + numbers.get(i + <span class="number">1</span>));</span><br><span class="line">                    numbers.remove(i + <span class="number">1</span>);</span><br><span class="line">                    i--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 没有可以合并的素数，继续下一个数</span></span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并剩余的素数对</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numbers.size() - <span class="number">1</span>; ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime(numbers.get(i)) &amp;&amp; isPrime(numbers.get(i + <span class="number">1</span>))) &#123;</span><br><span class="line">                numbers.set(i, numbers.get(i) + numbers.get(i + <span class="number">1</span>));</span><br><span class="line">                numbers.remove(i + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第四题</p>
<p>定义一棵树的直径为：任意两个节点的距离的最大值。现在定义f(i)：对i号节点上再连接一个新的子叶节点后，树的直径长度。现在要求f(1)到f(n)的值。</p>
<p>输入描述：第一行输入一个正整数n，代表树的节点数量。</p>
<p>接下来的n-1行，每行输入两个正整数u和v，代表u号节点和v号节点之间有一条长度为1的边连接。</p>
<p>变量的范围：1≤n≤10的五次方，1≤u，v≤n。</p>
<p><strong>题目分析：</strong> 树的直径引出树形 dp 算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    List&lt;TreeNode&gt; children;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        children = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeDiameter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] f; <span class="comment">// 存储每个节点的最大直径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt(); <span class="comment">// 树的节点数量</span></span><br><span class="line"></span><br><span class="line">        f = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        TreeNode[] nodes = <span class="keyword">new</span> <span class="title class_">TreeNode</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            nodes[i] = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接节点之间的关系</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            nodes[u].children.add(nodes[v]);</span><br><span class="line">            nodes[v].children.add(nodes[u]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每个节点，添加一个新的子叶节点，计算f(i)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 添加新的子叶节点</span></span><br><span class="line">            nodes[i].children.add(<span class="keyword">new</span> <span class="title class_">TreeNode</span>(-<span class="number">1</span>));</span><br><span class="line">            <span class="comment">// 计算当前最大直径</span></span><br><span class="line">            dfs(nodes[i], <span class="literal">null</span>, i);</span><br><span class="line">            <span class="comment">// 删除添加的子叶节点</span></span><br><span class="line">            nodes[i].children.remove(nodes[i].children.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            System.out.print(f[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归计算以当前节点为根的子树的直径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode node, TreeNode parent, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxDepth1</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 最大深度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxDepth2</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 次大深度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历当前节点的子节点</span></span><br><span class="line">        <span class="keyword">for</span> (TreeNode child : node.children) &#123;</span><br><span class="line">            <span class="keyword">if</span> (child == parent) <span class="keyword">continue</span>; <span class="comment">// 不访问父节点，防止死循环</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">childDepth</span> <span class="operator">=</span> dfs(child, node, i) + <span class="number">1</span>; <span class="comment">// 递归计算子节点的深度</span></span><br><span class="line">            <span class="keyword">if</span> (childDepth &gt; maxDepth1) &#123;</span><br><span class="line">                maxDepth2 = maxDepth1;</span><br><span class="line">                maxDepth1 = childDepth;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDepth &gt; maxDepth2) &#123;</span><br><span class="line">                maxDepth2 = childDepth;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新当前状态的最大直径</span></span><br><span class="line">        f[i] = Math.max(f[i], maxDepth1 + maxDepth2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxDepth1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="恒生笔试">2024.4.9 恒生笔试</h1>
<ol type="1">
<li>下列代码的返回值</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>/<span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*<span class="number">3</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a
href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.20.2">根据Java语言规范文档规定</a>。在
try-catch-finally 语句块中，finally 语句块中的
return/抛出异常（立即结束语句）的优先级最高，程序会优先返回 finally
语句块中的立即结束语句的结果，此时 try-catch 语句块中的
return/抛出异常（立即结束语句）的结果就会被丢弃掉。</p>
<ol start="2" type="1">
<li>SQL 语句</li>
</ol>
<p>联结语法、INNER JOIN 语法</p>
<ol start="3" type="1">
<li>初始资金 M，N 天价格信息，K 次交易后，能赚多少钱？（动态规划）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 根据输入计算最大收益</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> M double浮点型 初始资金</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> N int整型 历史价格天数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> historyPrices double浮点型一维数组 N天历史价格</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> K int整型 最大允许交易次数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> double浮点型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">get_max_profit</span> <span class="params">(<span class="type">double</span> M, <span class="type">int</span> N, <span class="type">double</span>[] historyPrices, <span class="type">int</span> K)</span> &#123;</span><br><span class="line">    <span class="type">double</span>[][] dp = <span class="keyword">new</span> <span class="title class_">double</span>[K+<span class="number">1</span>][N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;N; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;=K; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=K; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;N; j++) &#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">max</span> <span class="operator">=</span> dp[i][j-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> t=<span class="number">0</span>; t&lt;j; t++) &#123;</span><br><span class="line">                <span class="type">double</span> <span class="variable">rest</span> <span class="operator">=</span> dp[i-<span class="number">1</span>][t]%historyPrices[t], buy = (dp[i-<span class="number">1</span>][t]-rest)/historyPrices[t];</span><br><span class="line">                max = Math.max(max, buy*historyPrices[j]+rest);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][j] = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[K][N-<span class="number">1</span>]-dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="腾讯笔试">2024.3.31 腾讯笔试</h1>
<p>没做好记录，只记了没做出来的第四题，其他四道题 AC
了三道，还有一道通过 97% 我怀疑是样例有问题[手动狗头]</p>
<ol start="4" type="1">
<li>给你 n 个数，这 n 个数要被拆成 k
份，对每份中的数字求异或，求各份异或总和的最大值（和恒生第二题的思路基本一样）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">    <span class="type">long</span>[][] dp = <span class="keyword">new</span> <span class="title class_">long</span>[k + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[<span class="number">1</span>][i + <span class="number">1</span>] = in.nextInt() ^ dp[<span class="number">1</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span>[] prefix = dp[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 拆分为 i 份</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="comment">// 从头到尾遍历：将第 1~j 个元素拆成 i 份</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 将第 [1,s] 个元素拆成 i-1 份，(s,j] 是最后一份</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> j - <span class="number">1</span>; s &gt;= i - <span class="number">1</span>; s--) &#123;</span><br><span class="line">                <span class="comment">// 异或的优先级小于加减法</span></span><br><span class="line">                max = Math.max(max, dp[i - <span class="number">1</span>][s] + (prefix[j] ^ prefix[s]));</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][j] = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(dp[k][n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>实习面试题汇总</title>
    <url>/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="海康技术主管面">2024.6.24 海康技术主管面</h1>
<h1 id="谐云技主管面">2024.6.13 谐云技主管面</h1>
<ol type="1">
<li>讲一讲和算法相关的经历</li>
</ol>
<ul>
<li>专利：基于异构图网络的情绪支持对话</li>
<li>项目：LLM应用开发</li>
</ul>
<ol start="2" type="1">
<li>这个项目都在使用别人开发好的技术，那么你在其中有什么贡献？</li>
</ol>
<ul>
<li>目前很多开源项目只停留在科研方面，如何落地到具体项目中，就比如 LLM
出现错误宕机的时候，重启容器化运行的 LLM
实例并采用一致性轮询方法，访问其他正常运行的容器</li>
</ul>
<ol start="3" type="1">
<li>做过最大的项目</li>
</ol>
<ul>
<li>实习的时候做的数据中台项目</li>
</ul>
<ol start="4" type="1">
<li>对未来的计划</li>
</ol>
<ul>
<li>作为一个刚进入工作的学生，要不断学习拓宽自己的技术面</li>
</ul>
<h1 id="华为主管面">2024.5.22 华为主管面</h1>
<h1 id="谐云技术面">2024.5.21 谐云技术面</h1>
<p>并发</p>
<h1 id="华为技术面">2024.5.10 华为技术面</h1>
<ul>
<li>让我调了下摄像头，好展示我的颜，然后自我介绍</li>
<li>手撕算法（由于太紧张写代码一直在絮絮叨叨）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">业务发送数据到对端，由于网络原因会出现概率丢包；现发送1W条数据到对端，指定输入N为丢包数量，随后列出丢包数据的具体位置；你有机会进行补包，M为可补包的数量，请返回补包后最大可连续发送数据的数量</span><br><span class="line"></span><br><span class="line">无需实现交互式输入，只需实现如下函数</span><br><span class="line"><span class="type">int</span> <span class="title function_">maxContinuousPackages</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] lostPackages, <span class="type">int</span> m)</span></span><br></pre></td></tr></table></figure>
<p>测试样例</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">示例1：</span><br><span class="line">3</span><br><span class="line">1 5 10</span><br><span class="line">1</span><br><span class="line">-----</span><br><span class="line">9995</span><br><span class="line">本示例中，丢包数量N为3，丢包位置分布为第1、5、10三个位置，补包数量M为1；在第10个位置补包后可连续发包数量最大，为10000 - 5 = 9995</span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line">4</span><br><span class="line">4 6 20 9990</span><br><span class="line">2</span><br><span class="line">-----</span><br><span class="line">9994</span><br><span class="line"></span><br><span class="line">示例3：</span><br><span class="line">4</span><br><span class="line">1500 4100 5000 8000</span><br><span class="line">2</span><br><span class="line">---</span><br><span class="line">6499</span><br><span class="line"></span><br><span class="line">示例4：</span><br><span class="line">4</span><br><span class="line">4 699 700 9990</span><br><span class="line">2</span><br><span class="line">---</span><br><span class="line">9985</span><br><span class="line"></span><br><span class="line">示例5：</span><br><span class="line">6</span><br><span class="line">100 2700 5100 7498 7499 7500</span><br><span class="line">2</span><br><span class="line">---</span><br><span class="line">7397</span><br></pre></td></tr></table></figure>
<p>AC 代码，中途写错了还考虑了动态规划，导致三十分钟用满了，说是最多 30
min 再满一点我就 GG 了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxContinuousPackages</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] lostPackages, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> lostPackages.length, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] data = <span class="keyword">new</span> <span class="title class_">int</span>[len+<span class="number">1</span>];</span><br><span class="line">    data[<span class="number">0</span>] = lostPackages[<span class="number">0</span>]-<span class="number">1</span>;</span><br><span class="line">    data[data.length-<span class="number">1</span>] = <span class="number">10000</span> - lostPackages[len-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;data.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        data[i] = lostPackages[i] - lostPackages[i-<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m++;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">        sum += data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ans = sum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=m; i&lt;data.length; i++) &#123;</span><br><span class="line">        sum -= data[i-m];</span><br><span class="line">        sum += data[i];</span><br><span class="line">        ans = Math.max(ans, sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans+m-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>算法思路讲一遍，中间做错了删掉的代码也要讲为什么做错了，然后把代码截了个图</li>
<li>说一下自己的技术栈</li>
</ul>
<p>Java基础、JUC、JVM、SpringBoot、MySQL</p>
<ul>
<li>挑一个自己熟悉的讲一讲，选了 MySQL 索引</li>
</ul>
<p>B+ 树结构，聚簇索引、二级索引、和 B 树的对比</p>
<ul>
<li>如果让你建一张表，你会如何设计索引</li>
</ul>
<p>联合索引、覆盖索引、前缀索引</p>
<ul>
<li>IOC 容器的理解</li>
</ul>
<p>代理所有单例的创建，防止频 GC</p>
<ul>
<li>那为什么不直接用单例模式而用 IOC 容器的 Bean</li>
</ul>
<p>还能实现 Bean 的生命周期管理，可以实现 AOP</p>
<ul>
<li>用 Python 能否实现 AOP</li>
</ul>
<p>我说不能，AOP 实现需要操作字节码，他说行，我道歉</p>
<ul>
<li>设计模式讲一下</li>
</ul>
<p>讲了 SpringMVC 中 HanderAdapter 用到的适配器模式</p>
<ul>
<li>Rest 和 Rpc 有什么区别</li>
</ul>
<p>首先说了实习的时候 Rpc 底层有用到 Rest
传输数据包，而这没有本质区别</p>
<p>http 头部冗余，效率低；但 http3 效率挺好但没普及</p>
<p>Rpc 更适合后台内部调用，效率高；Rest 适合所有场景，适配做的好</p>
<ul>
<li>OS 为什么需要虚拟地址</li>
</ul>
<p>没复习到的八股，说了下虚拟地址映射到物理地址，页的映射，道歉</p>
<ul>
<li>会什么语言</li>
</ul>
<p>还会点 Python，不懂 C</p>
<ul>
<li>反问，进去需要什么技术栈</li>
</ul>
<p>Java 微服务开发等</p>
<h1 id="小红书一面">2024.4.29 小红书一面</h1>
<blockquote>
<p>以后有机会的话可以问问 HR
这个部门是干什么的，再做相应的准备，不然临时抱佛脚可能抱错佛了。</p>
</blockquote>
<p>他温我哭，面试官又帅又贴心，看到我紧张也不催我。但是他一直在叹气，搞得我压力好大。面试总共30min，后续手撕了一道算法题20min，==已经好几次算法题读题不准确了，连续字串和子序列最容易理解错==</p>
<ol type="1">
<li><p>自我介绍</p></li>
<li><p>深入讲一下实习经历（完全没想到会问这个）</p></li>
</ol>
<p>数据中台项目</p>
<ul>
<li>了解项目架构，微服务和多模块开发，数据流过程</li>
<li>尝试开发字典结构</li>
<li>AOP 日志：运行时间、调用接口、速度、ip</li>
<li>调用微服务获取运维大屏数据，并展示：线程池、CompletableFuture
线程先后调用关系</li>
</ul>
<ol start="3" type="1">
<li>日志 AOP，能不能查找、过滤逻辑，为什么不用
ELK。如果有监控平台的话，为什么不存到监控平台里（看得出来面试官很奇怪怎么只有
AOP 记录日志，没有其他的相关功能）</li>
</ol>
<p>Leader 安排的，直接存到 MySQL 中即可（搪塞一下）</p>
<ol start="4" type="1">
<li>AOP 底层原理</li>
</ol>
<p>CGLib、Java 原生，SpringBoot 中只使用 CGLib 代理（一定要说 Spring
是可以配置的）</p>
<ol start="5" type="1">
<li>行，继续说（我超，怎么说啊说啥啊）</li>
</ol>
<p>扯到 Rpc 服务端接口代理；底层原理，编译成字节码，读入 JVM
前做一层代理</p>
<ol start="6" type="1">
<li>有 A 类中的 BC 方法。B 方法使用注解代理，再用 C 方法通过 this.B()
调用，会出现什么逻辑</li>
</ol>
<p>会直接调用 B 方法</p>
<ol start="7" type="1">
<li><strong>那如何让 this.B() 的代理生效呢</strong></li>
</ol>
<p>获取到被代理的 Bean，再调用 B 方法【如何获取被 AOP 代理的
Bean？】</p>
<ol start="8" type="1">
<li>修改一个数据，存储层、缓存层一起用的话怎么办</li>
</ol>
<p>双删一致性</p>
<ol start="9" type="1">
<li>单例模式实际应用场景，Spring 底层的设计有哪些用到了单例模式</li>
</ol>
<p>Spring 单例模式的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> sychronize Singleton <span class="title function_">getInstace</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">            <span class="keyword">if</span>(instance==<span class="literal">null</span>) instance=<span class="keyword">new</span> <span class="title class_">Singleton</span>(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>==底层针对单例模式的使用：IOC
容器、BeanFactory==、工具类、线程池、ApplicationContext自身、</p>
<ol start="10" type="1">
<li>底层创建 Bean 是线程安全的吗？一定会用到 <code>synchronized</code>
吗？</li>
<li>启动时直接把所有 Bean 都创建好，可不可以保证线程安全？</li>
</ol>
<p>Bean
生命周期中，初始化和依赖注入是两个阶段，不会相互影响，因此是安全的</p>
<ol start="10" type="1">
<li>MySQL 的索引机制</li>
</ol>
<p>聚簇索引；相比于跳表，B+ 树可以有效降低树的高度；【InnoDB 的 B+
树到达四层的情况下能装下多少数据？】</p>
<ol start="10" type="1">
<li>B+ 和 B 树的区别</li>
</ol>
<p>顺序访问叶子节点；中间节点不会存到下层节点</p>
<ol start="11" type="1">
<li>MySQL 乐观锁和悲观锁</li>
</ol>
<p><del>MVCC</del>
时间戳或版本号字段；间隙锁行锁表锁【悲观锁底层如何实现的？】</p>
<ol start="12" type="1">
<li><strong>update 用的是行锁还是表锁</strong></li>
</ol>
<p>在 update 语句的 where
条件没有使用索引，就会全表扫描，于是就会对所有记录加上 next-key
锁（记录锁 + 间隙锁），相当于把整个表锁住了</p>
<ol start="13" type="1">
<li>二级索引、联合索引、最左前缀匹配原则</li>
<li>Redis 怎么实现过期删除策略（不是内存淘汰策略）</li>
<li>缓存穿透</li>
</ol>
<p>太紧张了，回答成缓存雪崩了</p>
<ol start="13" type="1">
<li><strong>Redis 大 Key 问题的定义，解决方法</strong></li>
<li><strong>线程池的核心线程池的个数是如何设置的？</strong></li>
</ol>
<p>线程等待时间所占比例越高，需要越多线程；线程计算时间所占比例越高，需要越少线程；</p>
<ul>
<li>CPU密集型任务：N+1</li>
<li>IO密集型任务：2N</li>
</ul>
<p>手撕算法：【300. 最长递增子序列】一开始贪心没写出来，后面用 dp
写出来的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line"><span class="type">int</span>[] data = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">    data[i] = in.nextInt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">    dp[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data[j]&lt;data[i]) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i], dp[j]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = Math.max(ans, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(ans);</span><br></pre></td></tr></table></figure>
<p><strong>总结QA</strong></p>
<p><strong>Q</strong>：JDK 动态代理和 cglib 的底层实现的区别？</p>
<p><strong>A</strong>：JDK：目标类加载后，使用 Native
方法在<strong>运行时动态生成代理类</strong>，将切面织入到代理类中；CGLib：目标类加载后，字节码构建框架
<strong>ASM
构建字节码</strong>文件，并生成目标类的子类，将切面逻辑加入到子类中；AspectJ：<strong>编译期间</strong>，将切面织入代理类中，得到代理后的字节码；</p>
<p><strong>Q</strong>：类上有 AOP
注解，如何分别获取被代理前和代理后的这个类呢？</p>
<p><strong>A</strong>：代理前：直接 new 一个对象；代理后：通过
<code>ApplicationContext</code> 或 <code>@Autowired</code>
注解来获取代理 Bean
对象，即<strong>容器中只会存放被代理过的类</strong>；</p>
<p><strong>Q</strong>：单例模式 Bean 是线程安全的吗？</p>
<p><strong>A</strong>：主要取决于 Bean 是否是无状态的，即 Bean
中是否包含可变的状态信息；</p>
<p><strong>Q</strong>：MySQL 如何实现乐观锁和悲观锁？</p>
<p><strong>A</strong>：乐观锁：版本号或时间戳字段；悲观锁：InnoDB
所有的行锁算法都是基于索引实现的，锁定的都是索引或索引区间；</p>
<p><strong>Q</strong>：update 用的是行锁还是表锁【TODO】</p>
<p><strong>A</strong>：Where
条件判断有索引就走索引，走索引就锁索引，索引锁了就是行锁，不然就是表锁</p>
<p><strong>Q</strong>：Redis 怎么实现过期删除策略</p>
<p><strong>A</strong>：惰性删除+定期删除（不采用定时删除）<img data-src="/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5.jpg" class="" title="img"></p>
<p><strong>Q</strong>：Redis 大 Key 问题的定义，解决方法</p>
<p><strong>A</strong>：从应用服务、持久化角度分别作答</p>
<p><strong>定义</strong>：某个 key 所对应的 value 过大。具体来说，对于
String 类型的数据，如果其大小超过 10KB，一般被认为是大 key；而对于
set、zset、hash 等集合类型的数据，如果其包含的元素数量超过 5000
条，也通常被视为大 key。</p>
<p><strong>解决办法</strong>：</p>
<ul>
<li>把大 key 拆分成一个一个小 key；</li>
<li>将大 Key 拆分成多个小 Key 并用 Hash 结构存储；</li>
<li>定时检查 Redis 是否存在大 key ，如果该大 key 是可以删除的，不要使用
DEL 命令删除，因为该命令删除过程会阻塞主线程，而是用 unlink 命令（Redis
4.0+）删除大 key，因为该命令的删除过程是异步的，不会阻塞主线程；</li>
</ul>
<p>造成的不良影响：</p>
<ul>
<li>应用服务：Redis 是单线程的，大 Key
写入和删除会阻塞其他命令；内存分布不均，失去内存时空局部性特性；网络阻塞，IO
压力大；</li>
<li>持久化：Always 参数下数据同步到硬盘时会阻塞主线程；经常性触发AOF
重写机制；AOF 重写机制和 RDB 快照（bgsave 命令）的过程，都会分别通过
fork()
函数创建一个子进程来处理任务，会导致阻塞父进程（主线程）；集群模式下内存分布不均</li>
</ul>
<h1 id="恒生一面">2024.4.10 恒生一面</h1>
<p>虽然面试只有
17min，但感觉再长一点我真的要蚌埠住了，哭（在杭电十二教线下面的）</p>
<p>反思：自我介绍准备不足，都要开始面试了还在考虑怎么改（其实也怪他们面试通知太晚了，不怪我嘻嘻）平时学的不扎实，说不出
AQS 的底层实现原理我可以接受，但连 AQS
都没提到实在是太蠢了，果然还是准备的不够充分。谢谢恒生一巴掌拍醒了我，认清了自己还是个小菜鸡。摆正心态，继续努力！！！</p>
<ol type="1">
<li>自我介绍</li>
</ol>
<p>面试官看了简历，说“不愧是软件工程内容比别人多多了”，面试官真的是很认真的把简历从头看到尾（泪目）</p>
<ol start="2" type="1">
<li>Rpc 项目具体是什么</li>
</ol>
<p>因为自我介绍里说了为什么要做 RPC 项目，面试官顺势问了。</p>
<p>简单说了上段实习中用到了自定义 Cluster 集群策略，因为 Dubbo 自带的
ClusterRules（广播、失败立刻返回）没有涉及到轮询检查离线任务是否完成的功能，所以
Leader 让我利用 Dubbo 的 SPI
机制做了一个查询微服务的计算过程是否完成的方法，然后挂载在
META-INF/dubbo 下就 Dubbo
框架就可以直接调用该集群执行方式（当时说的并没有这么清晰，还是太菜了呜呜）</p>
<ol start="3" type="1">
<li>如何分析 dump 文件</li>
</ol>
<p>感觉简历里唯一吸引面试官的就是如何处理 OOM Crash 了。</p>
<p>测试报服务异常，线程池等待队列过长；Leader 带我用 jstack
获得线程的状态；发现该线程池中的所有线程都处在阻塞状态，并且都阻塞在父线程；查看父子线程调用关系和
Executors.<em>newFixedThreadPool</em>(25) 底层原理，发现 FixedThreadPool
使用了无限长的阻塞队列，父线程未执行完成，且子线程只能在队列中等待，造成死锁所以队列一直在变长</p>
<ol start="4" type="1">
<li>synchronized Reentrantlock 的具体使用场景有什么不同</li>
</ol>
<p>只知道底层实现原理不同且都是可重入锁，并不知道具体使用场景的区别（哪来的这么真实业务多场景啊喂）</p>
<ol start="5" type="1">
<li>MySQL 调优</li>
</ol>
<p>愚蠢的我只知道构建索引、优化表结构和增大
BufferPool，好在后续上网也没找到什么很好的方法。或许==预编译 SQL
语句==是个不错的想法，根据 MySQL 运行过程推出的优化方法。</p>
<h1 id="面试-prepare">面试 Prepare</h1>
<h2 id="自我介绍">自我介绍</h2>
<blockquote>
<p>由于错误使用 Dubbo 注解导致的 JVM 异常问题；Rpc 中间件采用 Netty
传输数据、Zookeeper
注册服务;调度各微服务，聚合并缓存数据；我还和同事一起分析解决了线上告警事故；</p>
</blockquote>
<p>面试官您好，很荣幸能来参加华为的面试，我叫王哲文，目前在杭州电子科技大学读研，本科就读于浙大城市学院。</p>
<p>本科期间我加入了黑胡桃实验室，参与了智慧实验室和时间序列预测等项目，还在实验室举办的
2020
年谷歌开发者大会上分享了自己的项目经验。我在浙江华坤道威数据科技有限公司实习期间，主要负责日志切面和运维大屏的开发，在这期间我积累了企业级分布式微服务项目的开发经验。</p>
<p>在读研期间，我加入了大数据与城市计算实验室，主要负责三友阴极板项目的后端开发和某涉密项目的大语言模型应用开发。在项目开发过程中，我不仅更加深入掌握了
SpringBoot、MySQL、Redis 等主流技术，还了解了 Langchain、PyTorch、Milvus
等前沿技术。在工作之余，我还学习了 Rpc
中间件的架构和设计思想，并开发了一个简易的轻量级 Rpc
中间件。此外，我还搭建了个人博客网站，定期发布学习笔记和技术总结，不断沉淀自己的开发经验。</p>
<p>最后，我非常希望能有机会加入华为，将所学知识应用到实际工作中，并与优秀的团队一起共同成长。谢谢！</p>
<h2 id="项目困难解决方法">项目困难/解决方法</h2>
<p>实习</p>
<ul>
<li>分布式微服务架构复杂 === 请教前辈、打断点弄明白数据流；</li>
<li>多线程并发，编排任务执行流程 === 美团技术博客 CompletableFuture
原理和实践；</li>
<li>沟通协作，和同事交流，理解别人的想法的同时清楚地表达自己的想法；让领导清楚自己在做什么，工作量和重难点在哪
=== 多沟通多交流，先理清自己的想法再和同事、领导沟通；</li>
</ul>
<p>LLM 应用开发</p>
<ul>
<li>LLM 部署，技术选型 FastChat、FastApi、VLLM 加速 ===
实践尝试，选择最合适的方法；</li>
<li>思考如何实现需求 ===
参考别人发表的经验和思路，比如看论文、技术博客、线上宣讲会、开源项目等，在针对需求改进和优化；</li>
<li>Prompt 构建，数据切分、数据集构建：分词、分段、Embedding 计算</li>
</ul>
<p>RPC 中间件</p>
<ul>
<li>Netty 数据传输</li>
<li>RPC架构==Bean 生命周期，分布式注册中心：zk（CP、zab算法）</li>
</ul>
<p>三友</p>
<ul>
<li>数据库缓存一致性设计</li>
<li>新需求的开发</li>
</ul>
<h2 id="qa">Q&amp;A</h2>
<p><a
href="https://www.bilibili.com/read/cv13183086/#:~:text=%EF%BC%88%E7%AE%80%E5%8C%96%E7%89%88%EF%BC%89,%E5%8D%8E%E4%B8%BA%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BB%B7%E5%80%BC%E8%A7%82%E6%9C%89%E5%9B%9B%E4%B8%AA%E6%96%B9%E9%9D%A2%EF%BC%9A1%E3%80%81%E4%BB%A5%E5%AE%A2%E6%88%B7%E4%B8%BA%E4%B8%AD%E5%BF%83%EF%BC%8C%E5%AE%83%E5%8F%AF%E4%BB%A5%E7%A1%AE%E5%AE%9A%E5%A5%8B%E6%96%97%E7%9A%84%E6%96%B9%E5%90%91%3B2%E3%80%81%E4%BB%A5%E5%A5%8B%E6%96%97%E8%80%85%E4%B8%BA%E6%9C%AC%EF%BC%8C%E5%AE%83%E5%8F%AF%E4%BB%A5%E6%8F%90%E4%BE%9B%E6%B4%BB%E5%8A%9B%E7%9A%84%E6%BA%90%E6%B3%89%3B3%E3%80%81%E9%95%BF%E6%9C%9F%E8%89%B0%E8%8B%A6%E5%A5%8B%E6%96%97%EF%BC%8C%E8%BF%99%E6%98%AF%E5%AF%B9%E4%BA%BA%E4%BF%AE%E8%BA%AB%E7%9A%84%E4%B8%80%E4%B8%AA%E8%BF%87%E7%A8%8B%3B4%E3%80%81%E5%9D%9A%E6%8C%81%E8%87%AA%E6%88%91%E6%89%B9%E5%88%A4%EF%BC%8C%E5%9C%A8%E6%89%B9%E5%88%A4%E4%B8%AD%E8%83%BD%E5%A4%9F%E5%BE%97%E5%88%B0%E4%BF%AE%E5%BF%83%E3%80%82">华为核心价值观</a></p>
<ul>
<li>以客户为中心，以奋斗者为本，长期艰苦奋斗，坚持自我批判</li>
</ul>
<p>说说自己对于艰苦奋斗的看法（精神上的）</p>
<ul>
<li>我认为艰苦奋斗是一种积极向上、不断进取的品质，是为了实现自身价值，努力过上充实且有意义的人生，而不仅仅是为了眼前的利益；</li>
<li>结合我自己的经历来看，虽然中考失利了，但我仍保持努力拼搏的信念，在后续的高考、考研中不断超越自己，才有机会接触到了更多有挑战有意义的事情；</li>
</ul>
<p>科研&amp;项目：</p>
<ul>
<li><p>担任角色；负责的工作；项目背景；前期调研；创新点</p></li>
<li><p>项目有哪些难点</p></li>
<li><p>开发过程中遇到问题；如何解决</p></li>
<li><p>科研过程中遇到问题；如何解决</p>
<ul>
<li>一开始对科研内容一窍不通，通过不断的学习试错总结慢慢积累了经验</li>
</ul></li>
</ul>
<p>接下来的一年里有什么计划</p>
<ul>
<li>专利修改，秋招找工作，写大论文+毕业答辩</li>
<li>学习大数据技术栈（Hadoop、Map-Reduce、Hbase），出国旅行</li>
</ul>
<p>未来职业规划</p>
<ul>
<li>进入优秀的团队中工作学习；</li>
<li>前四年深耕技术，不断学习，沉淀技术栈，拓宽视野；</li>
<li>抓住机遇，第六、七年应聘管理层，接业务，带团队，一个人的力量终究是有限的，只有激发团队的力量才能办成大事；</li>
</ul>
<p>为了达成这些规划具体会做些行动</p>
<ul>
<li>学习大数据相关的技术栈；</li>
<li>抓住现有机会，积极投身工作中，不断提升技术能力，扩大人脉。耐心地等待机遇，当机遇来临时果断抓住它；</li>
</ul>
<p>绩点排名</p>
<ul>
<li>大一只有中游水平，后面几年排名逐年上升，大三拿到了学业奖学金并考研成功。在读研期间也能有中上游的绩点，拿到了学业奖学金；</li>
</ul>
<p>如何看待华为公司？为什么想来华为公司进行实习？</p>
<ul>
<li>无论是在芯片、操作系统还是在手机、汽车等领域，华为都是中国的一线品牌，华为当下在做的事情相当于五十年前的核武器研究；</li>
<li>参加华为举办的竞赛感受到华为的人文关怀做得很好，比赛场地布置的很用心，比赛结束后还举办了活动，吃了大餐，临走还送和一袋纪念品，包括所有人的合照；</li>
<li>体验大厂的氛围和管理制度，和优秀的团队一起成长，努力工作，争取毕业留在华为；</li>
</ul>
<p>能够实习多长时间？</p>
<ul>
<li>半年，立刻到岗</li>
</ul>
<p>对什么感兴趣并做了什么努力？</p>
<ul>
<li>对大语言模型很感兴趣；LLM
的训练和微调对硬件和数据集的要求高，但实验室只有 A6000，更加适合 LLM
的应用开发，看了很多论文、开源项目和技术博客，最终让基于大语言模型实现一个具体需求的过程非常有成就感；</li>
</ul>
<p>科研期间最大的困难</p>
<ul>
<li>对语言模型没有任何了解，实验室也是第一次接语言模型的项目，没有任何沉淀，一开始上手很艰难，只能不断重复去看网课和教程；</li>
</ul>
<p>如何获取资料</p>
<ul>
<li>论文、技术博客、开源项目、社群宣讲会</li>
</ul>
<p>什么东西起了很大的作用</p>
<ul>
<li>技术博客，因为它更加贴近实际落地的工作，大佬们留下的经验往往给我灵感</li>
</ul>
<p>重大的挫折</p>
<ul>
<li>人生中最大的挫折应该是中考，我当初冲重高保底优高，最后发挥失常只考上了职高；</li>
<li>高中
保持学习的劲头，稳扎稳打，高考超重点线；这段经历让我任何时候都不会轻言放弃，即使失败了也没事，总结反思之后再出发，家人和朋友一直都在，成功与否只是我自己的选择；</li>
</ul>
<p>压力特别大的时候</p>
<ul>
<li>跑步、爬山、骑行</li>
</ul>
<h2 id="科研内容">科研内容</h2>
<p>应用背景：将知识图谱应用在大模型领域，提升 LLM
响应的准确性和逻辑性；</p>
<p>创新点：不同于目前流行 RAG架构 思想，并不是通过 Prompt
帮助模型获取外部知识，而是将知识图谱中的数据训练到模型中，微调后的模型不仅得到了图谱中的外部知识，还获取了图谱中节点之间的逻辑性（对话过程中的）；</p>
<p>具体实现：</p>
<p>（1）
提出了动态策略模型，跟踪历史对话中用户语句多类特征的动态变化，抽取对话中深层次的关系和属性。</p>
<p>（2）设计了一个基于注意力机制的异构图网络，将用户的意图、历史策略和上下文对话进行交互，选择最优的支持策略以生成有效的支持响应。</p>
<p>（3）考虑到全局策略控制着整个对话流，DSA设计了监控全局策略信息的子任务和上下文到全局状态和全局状态到上下文的门限控制网络。</p>
<p>实验：应用于情感支持对话领域，将情感支持策略视作一种类型的知识图谱，同时引入常识性知识图谱，微调
BlenderBot 模型学习知识图谱的节点特征，提高模型的在 ESConv
数据集上的指标；</p>
<p><strong>步骤</strong></p>
<p>【3】</p>
<p>3 Method【2】</p>
<ul>
<li>3.1 overall
<ul>
<li>提出xxx，有效解决xxx，比别人好在哪xxx。包含了三个模块，介绍xxx，数据流xxx，提高了哪些xxx；由于这三个特征不能有效表示xxx，所以用异构图网络xxx，可得到两个状态，xxx。因此，提出的模型，有一样也有有不一样【总分总】</li>
</ul></li>
<li>3.2 archieve</li>
<li>3.3</li>
<li>3.4</li>
</ul>
<p>4 实验【3】</p>
<ul>
<li></li>
<li>指标，解释，为什么好，好在哪</li>
</ul>
<p>5 结果【1】</p>
<p>6 总结【3】</p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>论文阅读 AugESC</title>
    <url>/-2023/AugESC/</url>
    <content><![CDATA[<p><strong>Title:</strong> Large-scale Data Augmentation for Emotional
Support Conversation with Pre-trained Language Models</p>
<blockquote>
<p>研究开放式对话数据增强，采用大语言模型 GPT-3 拓展了 ESConv
数据集大小</p>
</blockquote>
<span id="more"></span>
<h1 id="论文速览">论文速览</h1>
<h2 id="abstract">Abstract</h2>
<ul>
<li>利用LLM进行数据增强，使用公开的对话帖子触发各种主题的对话</li>
</ul>
<h2 id="introduction">Introduction</h2>
<ul>
<li><p>目前工作的缺陷</p>
<ul>
<li>成本高、耗时长</li>
<li>预算限制，所收集的对话规模小，主题少</li>
</ul></li>
<li><p>本文主要贡献</p>
<ul>
<li>关键发现</li>
<li>使用 GPT-J 和公开对话帖子触发各种主题的对话</li>
<li>构建机器增强数据集AUGES，具有更广泛和多样化的主题覆盖范围，可以提供更有效的情感支持
## Related Work</li>
</ul></li>
<li><p>预训练模型</p></li>
<li><p>预训练模型的数据增强 ## Key Findings</p></li>
<li><p>语言模型优于对话模型</p>
<ul>
<li>语言模型存储了从大规模训练语料库中学习到的更丰富的知识，有助于更好地泛化到各种对话主题</li>
<li>与会话模型 BlenderBot
相比，gpt生成的对话具有更好的对话连贯性和一致性</li>
</ul></li>
<li><p>语言模型比交互式仿真更适合开放式对话数据增强</p></li>
<li><p>提示GPT不如微调GPT模型</p>
<ul>
<li>提示型GPT-3生成可控性差</li>
<li>只有微调才能掌握任务场景和所需特征</li>
</ul></li>
<li><p>少样本（Few-shot）微调导致更好的泛化和更高的多样性</p>
<ul>
<li>保持语言模型的内在知识</li>
<li>增加调优样本或训练步骤会导致对域外主题的泛化能力差</li>
<li>在大规模自动数据增强的帮助下，训练对话模型可能只需要少量手动策划的对话样本</li>
</ul></li>
<li><p>信息性查询（第一个对话帖子）是触发主题对话的必要条件</p>
<ul>
<li>泛型和无信息的查询往往导致离题和肤浅的对话 ## Methodology</li>
</ul></li>
<li><p>主干模型：GPT-3，微调后的GPT-J</p></li>
<li><p>提示模板：对话场景+情感支持</p></li>
<li><p>将第一个对话框作为触发查询，模型生成后续的对话</p></li>
<li><p>不采用Prompt提示，使用ESConv微调GPT-J</p></li>
<li><p>触发Query</p>
<ul>
<li>数据来源：EmpatheticDialogues（移情对话数据集）Reddit（心理健康相关的帖子）</li>
<li>保留带有负面情绪的Query</li>
</ul></li>
<li><p>过滤结果，删除非法对话 ## AUGESC
相比ESConv对话轮次更少，内容更长。语料库规模的扩大导致唯一二元分词的数量</p></li>
<li><p>ESConv中的对话话题与数据收集时期(如covid, pandemic,
christmas)密切相关</p></li>
<li><p>AUGESC-ED
涵盖了更多关于日常生活的主题(例如，汽车、狗、房子、邻居)</p></li>
<li><p>AUGESC-Reddit 涵盖了关于心理健康的主题(例如，抑郁、焦虑、治疗师)
## Quality Evaluation 在信息一致性、话题一致性和对话基础等方面存在问题
## Interactive Evaluation &gt;
AUGESC是对ESConv的一种补充，用AUGESC+ESConv训练出来的模型表现优于只使用ESConv的模型</p></li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>AUGESC能够显著增强对话模型提供情感支持的能力</p>
]]></content>
      <categories>
        <category>读论文</category>
      </categories>
      <tags>
        <tag>情绪支持对话</tag>
        <tag>对话数据集增强</tag>
      </tags>
  </entry>
  <entry>
    <title>论文阅读 Control Globally, Understand Locally</title>
    <url>/-2023/Control%20Globally,%20Understand%20Locally/</url>
    <content><![CDATA[<p>《Control Globally, Understand Locally. A Global-to-Local
Hierarchical Graph Network for Emotional Support Conversation.》</p>
<p>创新点：</p>
<ul>
<li>在 Encoder 和 Decoder 之间加了一层 GCNConv 和 RGCNConv</li>
</ul>
<img data-src="/-2023/Control%20Globally,%20Understand%20Locally/image-20240414083742062-17138602623661-17138606243731.png" class="" title="image.png">
<span id="more"></span>
<h1 id="论文速览">论文速览</h1>
<h2 id="abstract">Abstract</h2>
<ul>
<li><p>目前研究的缺陷</p>
<ul>
<li>关注序列上下文信息，忽略了全局原因和局部心理意图与其的层次关系</li>
</ul></li>
<li><p>本文</p>
<ul>
<li>提出了一个全局到局部的<strong>层次图网络</strong>来捕获多源信息(全局原因、局部意图和对话历史)并建模它们之间的层次关系，该网络由一个多源编码器、一个层次图推理器和一个全局引导解码器组成</li>
<li>设计了一个新的训练目标来监测全局的语义信息 ## Introduction</li>
</ul></li>
<li><p>探索求助者情绪问题的原因：<strong>全局</strong>地控制情感支持对话的整个流程</p></li>
<li><p>了解求助者的心理意图：帮助系统<strong>局部</strong>了解求助者当前时的心理状态</p></li>
<li><p>本文目标</p>
<ul>
<li>捕获全局原因和局部心理意图</li>
<li>建模全局与局部之间的关系</li>
</ul></li>
<li><p>解决方法【全局到局部层次图网络GLHG】</p>
<ul>
<li>多源编码器：COMET提取局部心理意图</li>
<li>层次图推理机：全局原因(对话级)、局部心理意图(句子级)和对话历史之间的层次关系进行建模</li>
<li>解码器中设计了一个新的训练目标来监控全局原因的语义信息 ## Related
Work</li>
</ul></li>
<li><p>图建模对话</p>
<ul>
<li>GCN 利用自我和对话者间依赖性来模拟会话上下文</li>
<li>EGAE 使用图网络捕获面向任务对话中的对话模式</li>
</ul></li>
<li><p>常识性知识</p>
<ul>
<li>与本人有关的心理状态：xReact、xIntent ## Approach</li>
</ul></li>
<li><p>问题定义</p></li>
<li><p>多源编码器</p>
<ul>
<li>BlenderBot Encoder + Max-pooling</li>
<li>上下文 + 全局原因 + 局部原因</li>
</ul></li>
<li><p>分层图推理机</p>
<ul>
<li>GAT
图注意力网络：其他邻域信息的特征传播到当前节点，具有确定节点之间重要性和相关性的优点</li>
<li><img data-src="/-2023/Control%20Globally,%20Understand%20Locally/1701777471738-5656cb06-b30d-458c-9dd1-432cf59fc949.png" class="" title="img">
注意力函数（2017出版)</li>
<li><img data-src="/-2023/Control%20Globally,%20Understand%20Locally/1701777606138-33d97b8c-8966-4a59-9359-ce99195ba4db.webp" class="" title="image.png">
<img data-src="/-2023/Control%20Globally,%20Understand%20Locally/1701777482262-fd172bc6-5f7f-4b43-b667-c12cd9b52505.png" class="" title="img">
注意力机制</li>
<li><img data-src="/-2023/Control%20Globally,%20Understand%20Locally/1701777489757-3d64bf9e-8b95-4298-a754-239e59ec6e7b.png" class="" title="img"></li>
<li><img data-src="/-2023/Control%20Globally,%20Understand%20Locally/1701777519559-801ad4da-0c7f-47f2-8ab6-ed20e4e19101.png" class="" title="img">
注意力机制</li>
<li><img data-src="/-2023/Control%20Globally,%20Understand%20Locally/1701777507833-1ff3f1f2-17cb-4ba0-991b-a61b42818cfc.png" class="" title="img"></li>
</ul></li>
<li><p>Global-guide 解码器</p>
<ul>
<li>响应生成<img data-src="/-2023/Control%20Globally,%20Understand%20Locally/1701777873314-d88aa900-555f-40b2-8a87-4589351ce738.png" class="" title="img">，v表示图神经网络得到的全局变量</li>
<li>监督全局语义信息：预测问题类型<img data-src="/-2023/Control%20Globally,%20Understand%20Locally/1701777996376-86594b70-a6b5-4f21-90e2-e6bbdbc222b0.png" class="" title="img"></li>
</ul></li>
<li><p>联合训练</p>
<ul>
<li>对数似然损失+交叉熵损失</li>
<li><img data-src="/-2023/Control%20Globally,%20Understand%20Locally/1701778036470-9378fc9b-a533-40a9-9990-69ffe0036656.png" class="" title="img">
<img data-src="/-2023/Control%20Globally,%20Understand%20Locally/1701778063569-1fc4c281-c256-4804-ba39-785ddd2e4b1e.png" class="" title="img">
<h2 id="experiments">Experiments</h2></li>
</ul></li>
<li><p>指标：plexity (PPL), BLEU-n (B-n), ROUGE-L (R-L),
Distinct-1(D-1), and Distinct-2 (D-2)</p></li>
<li><p>由于有了意图特征，提出建议更具体有效 ## Conclusion</p></li>
<li><p>全局到局部的层次图网络(Global-to-Local Hierarchical Graph
network, GLHG)来捕获多源信息并从全局到局部的角度建模层次关系</p></li>
<li><p>新的训练目标“预测Seeker遇到问题的类型” # 关注的问题 /
本文的优势</p></li>
</ul>
<h1 id="解决方法-创新点">解决方法 / 创新点</h1>
<ul>
<li><strong>多源编码器</strong>利用情境信息并将心理意图与COMET结合，捕获全局原因和局部意图</li>
<li><strong>分层图推理机</strong>在全局原因、局部心理意图和对话历史之间进行交互，建模不同层次的关系（hierarchical
graph reasoner） # 实验结论</li>
</ul>
<h1 id="有待提升的部分">有待提升的部分</h1>
]]></content>
      <categories>
        <category>读论文</category>
      </categories>
      <tags>
        <tag>情绪支持对话</tag>
        <tag>异构图神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>论文阅读 DQ-HGAN</title>
    <url>/-2023/DQ-HGAN/</url>
    <content><![CDATA[<p><strong>Title:</strong> A heterogeneous graph attention network based
deep Q-learning for emotional support conversation generation</p>
<span id="more"></span>
<h1 id="论文速览">论文速览</h1>
<h2 id="abstract">Abstract</h2>
<ul>
<li>关注的问题
<ul>
<li>动态建模对用户状态，包含个体的意图和情感</li>
<li>综合各类因素选择最合适的支持策略</li>
</ul></li>
<li>提出的方法【基于异构图注意力网络的深度Q-learning情感支持对话生成】
<ul>
<li>为了捕获用户意图、情感和历史对话之间的交互关系，基于意图词典和情感分类器，构建了异构图注意力网络</li>
<li>采用基于DQN的最优响应策略以指导响应生成，优于传统的基于规则或启发式方法
## Introduction</li>
</ul></li>
<li>目前研究
<ul>
<li>ESC任务要求能够确定求助者的心理意图和情绪状态，以便提供适当的支持。因此整合意图识别和情感识别对于提高情感支持对话的质量至关重要，且目前的方法对用户状态建模不充分。</li>
</ul></li>
<li>关注的问题
<ul>
<li>建模用户状态</li>
<li>选择最优策略，以产生有效的保障响应</li>
</ul></li>
<li>提出的方法
<ul>
<li>设计了基于注意力的<strong>异构图网络</strong>，与用户的意图、情感和历史对话交互，可以有效地捕获和建模图中不同类型的节点和边</li>
<li>构建<strong>意图词典</strong>和<strong>情感分类器</strong>来捕捉求助者在语境中的细微情感表达</li>
<li><strong>DQN算法</strong>对用户未来反馈的期望值进行估计，帮助系统选择获得最优长期值的策略。其允许系统从用户的反馈中学习，调整其策略，以提供最有效的支持响应。</li>
</ul></li>
<li>主要贡献
<ul>
<li>提出了一种新的方法DQ-HGAN，将<strong>意图和情感识别与策略生成相结合</strong>，以提高情感支持对话系统的质量和个性化</li>
<li>构建<strong>意图词典和情感分类器</strong>，捕捉求助者在语境中的细微情感表达并跟踪其状态</li>
<li>设计了一种基于注意力机制的<strong>异构图网络</strong>，与用户的意图、情感和历史对话进行交互，并选择最优的支持策略以生成有效的支持响应</li>
<li>ESC生成中使用ESC生成中使用<strong>强化学习</strong>，具体来说，使用DQN算法（Deep
Q-Network）估计用户未来反馈的期望值，动态调整策略以提供最有效的支持响应
## Related Work</li>
</ul></li>
<li>对话中的意图和情感识别【在模型中融合了“意图”这个特征】
<ul>
<li>多头注意力机制
<ul>
<li>多头注意力机制来捕捉用户的意图和情感。缺点：缺乏有效捕捉用户细微情感表达的能力</li>
<li>使用预训练模型，增强PLM对话相关性，识别对话意图、推断对话情感。缺点：不是专门为ESC任务定制的，性能差</li>
</ul></li>
<li>词典
<ul>
<li>词典包含特定意图或情感相关的词汇和短语，利用基于规则的算法将context与意图词典进行匹配，并分配相应的意图标签。缺点：只将单个单词与标签匹配，可能会忽略整个句子的意图或情感含义</li>
</ul></li>
</ul></li>
<li>图建模【捕获会话系统中用户意图、情感和对话历史之间的复杂关系】
<ul>
<li>同构图【忽略了用户意图和情感的异构性】
<ul>
<li>GAT
图注意力网络，利用自注意力机制来捕获对话图中意图和情感节点之间的交互</li>
<li>GCN
图卷积网络，利用图结构在节点之间传播信息，并捕获对话数据中的上下文依赖</li>
</ul></li>
<li><strong>异构图注意力网络是专为表示图中不同类型的节点和边而设计的</strong>，它擅长对<strong>不同的节点</strong>类型进行建模，如用户话语、系统响应、情感状态和意图，从而更全面地了解用户的情感状态；还擅长捕捉<strong>不同类型的边</strong>，包括顺序依赖、自依赖和状态依赖，从而能够更准确地表示用户的情感状态。此外，它还包含了一种<strong>注意力机制</strong>来进行重要性加权，允许它在聚合过程中专注于最相关的信息，从而更全面地了解用户的状态。</li>
</ul></li>
<li>策略选择
<ul>
<li>基于规则或启发式方法</li>
<li>强化学习方法（如：Q-learning）
<ul>
<li>采用DQN估计不同对话动作的期望值，并学习了一种最大化该值的策略。从用户反馈中学习，并生成更有吸引力和信息量的响应</li>
</ul></li>
</ul></li>
<li>响应生成
<ul>
<li>目前流行的Encoder-Decoder模型往往专注于根据对话历史生成回复，而没有考虑用户的意图、情感以及合适的支持策略
## Preliminaries</li>
</ul></li>
<li>ESConv：标记对话，并将其转换为词嵌入，以将其输入到模型中</li>
<li>COMET：使用COMET初始化模型的词嵌入，并在ESConv数据集上进行微调，以提高其构建意图词典的有效性</li>
<li>ATOMIC：得到意图或目的（xIntent）</li>
<li>NRC VAD
词典：得到情感词典，每个单词对应的效价-觉醒-支配（Valence-Arousal-Dominance）</li>
<li>问题定义：上下文+策略+Query
=&gt;响应Yt。最优策略基于当前状态和期望的长期回报（通过Q-learning预测）
## Method <img data-src="/-2023/DQ-HGAN/1701484543763-403c4648-68f4-4644-bf00-e2356c06841c.jpg" class="" title="88c61f5be72a795a087441904fcd0ad9_3_Figure_2_780332990.png"></li>
</ul>
<h3 id="多源编码器">多源编码器</h3>
<img data-src="/-2023/DQ-HGAN/1701484574764-c5051f60-2b3c-40cf-a161-5848c1d67bc2.png" class="" title="img">
<ul>
<li>transformer编码器（TransformerEncoder）
<ul>
<li>ht = TransformerEncoder(Ht)</li>
</ul></li>
<li>意图词典（COMET）：通过对ATOMIC
微调，同去意图关键词，构建意图词典（意图关键词，对应的词嵌入）
<ul>
<li><span
class="math display">\[g_{t}=TransformerEncoder\left(\sum_{w_{i}\in\mathscr{F}}\operatorname{softmax}\left(c_{i}^{T}
h_{t}\right)c_{i}\right) \]</span></li>
</ul></li>
<li>情感分类器（NRC VAD词典）
<ul>
<li><span
class="math display">\[e_{t}=\text{TransformerEncoder}\left(\sum_{w_{k}
\in \mathscr{Z}}\operatorname{softmax}\left(z_{k}^{T} h_{t}\right)
g_{t}\right) \text { }\]</span></li>
</ul></li>
</ul>
<h3
id="基于异构图的用户状态跟踪">基于异构图的用户状态跟踪<img data-src="/-2023/DQ-HGAN/1701484605842-86e4e5d2-9d20-4ffd-ae60-37220c9258dd.png" class="" title="img"></h3>
<h3 id="dqn强化学习">DQN强化学习<img data-src="/-2023/DQ-HGAN/1701484626201-fde66e58-39a7-40f7-9e6e-fe70a7cd8dd7.png" class="" title="img"></h3>
<h3 id="响应生成解码器">响应生成解码器<img data-src="/-2023/DQ-HGAN/1701484638477-fd1f5c6b-b6f5-43f0-af14-a22d10dfe762.png" class="" title="img"></h3>
<h2 id="experiments">Experiments</h2>
<p>Conclusion</p>
<h1 id="关注的问题-本文的优势">关注的问题 / 本文的优势</h1>
<h1 id="解决方法-创新点">解决方法 / 创新点</h1>
<h1 id="实验结论">实验结论</h1>
<h1 id="有待提升的部分">有待提升的部分</h1>
]]></content>
      <categories>
        <category>读论文</category>
      </categories>
      <tags>
        <tag>情绪支持对话</tag>
        <tag>异构图神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>论文阅读 HEAL</title>
    <url>/-2023/HEAL_%20A%20Knowledge%20Graph%20for%20Distress%20Management%20Conversations/</url>
    <content><![CDATA[<p><strong>Title:</strong> A Knowledge Graph for Distress Management
Conversations</p>
<span id="more"></span>
<h1 id="论文速览">论文速览</h1>
<h2 id="abstract">Abstract</h2>
<ul>
<li><p>相比于seq2seq的不确定性，聊天机器人利用知识图谱进行推理，被视为端到端模型的高效、万无一失的解决方案</p></li>
<li><p>提出HEAL知识图谱</p>
<ul>
<li>基于1M痛苦叙述及其相应的安慰回应而开发的知识图谱</li>
<li>图谱可视化：表现了对话双方的情绪动态和帮助缓解情绪的有效方法</li>
<li>组成部分
<ul>
<li>22k Node 节点：识别不同类型的stressors, speaker expectations,
responses, feedback types</li>
<li>104k Edge 连接：不同类型的节点之间的关系</li>
<li>每个节点和41种情绪状态相关联 ## Introduction</li>
</ul></li>
</ul></li>
<li><p>神经网络架构模型缺乏可控性和黑箱性质，导致其并不可靠</p></li>
<li><p>使用常识推理和知识图结构表示，可以生成适合的、可预测的、多策略的回应</p></li>
<li><p>相关工作</p>
<ul>
<li>ConceptNet、ATOMIC主要是通过捕获事实知识，在开放对话中嵌入常识推理辅助对话，不适用于移情对话</li>
</ul></li>
<li><p>本文，通过子Reddit精心选择的对压力事件叙述和回应，生成了一个压力对话管理知识图谱HEAL</p>
<ul>
<li>五类节点：压力源、期望、回应类型、反馈类型、情感状态</li>
<li>可以准确描述以痛苦为导向对话的潜在背景，使对话模型可以检索到更具体的上下文响应。提取响应会导致的反馈类型和是否能达到期望等信息，从而产生更为合适的反应
## Related Work</li>
</ul></li>
<li><p>知识图谱可以帮助NLP理解用户的输入，拓展用户输入中的事实和常识性知识</p></li>
<li><p>目前工作关注于知识感知和推理对话，不会捕捉情感推理和移情反应 ##
Methodology</p></li>
<li><p>数据集管理</p>
<ul>
<li>采用reddit数据集，通过Pushshift
API，收集和处理8个子reddit对话主题：mentalhealthsupport、offmychest、sad、anxietyhelp、depression、suicidewatch、depressed、depressionhelp</li>
<li>数据预处理</li>
</ul></li>
<li><p>概要</p>
<ul>
<li>针对过长而超出预训练语言模型输入上限的对话，本文采用SMMRY摘要算法保留叙事本质</li>
</ul></li>
<li><p>凝聚聚类</p>
<ul>
<li>自动聚类：区分对话中的压力源、期望、响应和反馈类型</li>
<li>凝聚聚类法：递归地合并增加最小链接距离的簇对</li>
<li>链接距离：对SentenceBERT生成的embedding使用余弦相似度计算</li>
</ul></li>
<li><p>定义压力源</p>
<ul>
<li>每个阈值计算了各种聚类质量指标，结果显示以0.85的相似度阈值区分压力源最合适，将压力源中的4.7%分为了4363个类。</li>
<li>将聚类结果按照TF-IDF建模，可以明显区分压力源，表明聚类结果的可靠性。</li>
</ul></li>
<li><p>期望、回复、反馈类型</p>
<ul>
<li>提取带有❓的句子作为问题，以此问题提取相关的响应和反馈。使用NLTK分离响应和反馈中的单个对话，方便后续对其进行单一种类的聚类。</li>
<li>聚类方法与压力源一致，每个集群至少有两个不同的集群元素。</li>
</ul></li>
<li><p>情感状态建模</p>
<ul>
<li>使用Pu提出的基于BERT的情感分类器，将每一个簇与某一情感状态相关联，共有41种情感状态。先将每一个簇下的每个文本进行分类，再按照情感出现次数和分类置信度排序，选取最相关的情感状态。
## Statistical Analysis</li>
</ul></li>
<li><p>HEAL知识图谱：2.2k集群节点和情感状态，104k连接</p></li>
<li><p>反馈集群中，负面情绪明显减少，证明HEAL中存在帮助人们降低负面情感状态的有用响应
## Visualization and Interpretation</p></li>
<li><p>表示大多数回答都是正向积极反馈 ## Evaluating the Utility of HEAL
in Responding to Distress Prompts</p></li>
<li><p>获取共情响应</p>
<ul>
<li>从测试集中选取和压力源中现有叙述相似性高于0.75的新对话</li>
<li>根据压力源和响应之间边权的权重、响应簇大小进行排序，选择排名高的响应</li>
</ul></li>
<li><p>自动评估</p>
<ul>
<li>HEAL的响应更加多样化，可以根据给定的情况给出特定的响应</li>
<li>在其他自动指标BLEU、METEOR和ROUGE方面表现不佳</li>
</ul></li>
<li><p>人类评估【DOI: 10.18653/v1/d16-1230】</p>
<ul>
<li>HEAL模型变现更好 ## Discussion and Conclusion</li>
</ul></li>
<li><p>HEAL：利用Reddit上约1M个与痛苦相关的对话得出的知识图谱。在不同类型的压力源、说话者期望、求助者反应和求助者反馈类型之间形成联系，同时将每个节点与41种情感状态中的一种联系起来</p></li>
<li></li>
</ul>
<h1 id="关注的问题-本文的优势">关注的问题 / 本文的优势</h1>
<ul>
<li><p>端到端对话经常会产生通用和重复性对话，缺乏可控性。使用常识推理和知识图结构表示，可以生成适合的、可预测的、多策略的回应。</p></li>
<li><p>目前的知识图谱不适用于移情对话。移情领域缺乏数据集和模型帮助产生移情反应，还缺乏具有上下文-相应之间关系的知识图谱。
# 解决方法 / 创新点</p></li>
<li><p>开发大规模知识图谱HEAL，识别不同的压力源、期望、响应、反馈和该对话的情感状态</p></li>
<li><p>统计和可视化分析，识别导致情绪强度降低的有利反应</p></li>
<li><p>评估通过HEAL检索到的回应，在解决情感困扰问题上的共情性、多样性、可靠性
# 实验结论</p></li>
<li><p>与RoBERTa、Blender进行比较，HEAL能够产生更多样化、更移情的反应</p></li>
<li><p>统计和可视化分析证实了在HEAL中存在有用的反应策略，这些策略降低了遭受痛苦的人的负面情感状态</p></li>
<li><p>使用纯生成模型来解决痛苦存在危险，HEAL通过战略性地识别与给定提示相关的特定压力源来避免不适当的反应
# 有待提升的部分</p></li>
<li><p>只使用了压力源与回复的边缘权重，进一步可以通过将边缘权重与说话者的期望和反馈结合起来来开发</p></li>
<li><p>知识图的信息可以用于增强神经反应生成模型，并为这些模型引入更多的可控性和可解释性，从而提高可靠性</p></li>
<li><p>仅限于识别≈4K的压力源，可以从网络上获取更多数据来增强知识图谱，这将帮助其能够处理更大范围的压力源和期望</p></li>
</ul>
]]></content>
      <categories>
        <category>读论文</category>
      </categories>
      <tags>
        <tag>情绪支持对话</tag>
        <tag>知识图谱</tag>
      </tags>
  </entry>
  <entry>
    <title>论文阅读 Feedback-Aware Double</title>
    <url>/-2023/FADO/</url>
    <content><![CDATA[<p><strong>Title:</strong> Feedback-Aware Double COntrolling Network for
Emotional Support Conversation</p>
<img data-src="/-2023/FADO/1701141604157-75101287-52dc-426c-abea-73184a8b8cda.png" class="" title="img">
<span id="more"></span>
<h1 id="论文速览">论文速览</h1>
<h2 id="abstract">Abstract</h2>
<ul>
<li><p>双层反馈策略选择器：通过反馈信息预测策略</p></li>
<li><p>双层控制阅读器：通过策略约束上下文响应</p></li>
<li><p>策略词典：丰富策略的语义信息 ## Introduction ## Related Work ##
Problem Formulation ## Approach</p></li>
<li><p>上下文编码器</p>
<ul>
<li>BlenderBot预训练编码器编码上下文历史对话U，得到Ht</li>
</ul></li>
<li><p>双层反馈策略选择器</p>
<ul>
<li>策略选择
<ul>
<li>输入
<ul>
<li>BlenderBot Encoder 编码上下文历史对话U，得到隐状态Ht</li>
<li>BlenderBot Encoder 编码策略S</li>
<li>EmoBERTa Encoder 编码上下文对话U</li>
</ul></li>
<li>公式
<ul>
<li>上下文编码器（策略S同理）：<span
class="math display">\[\boldsymbol{H}=\operatorname{Enc}_{cxt}\left(\boldsymbol{[CLS]},
\boldsymbol{u}_{1}, \boldsymbol{[SEP]}, \boldsymbol{u}_{2}, ...,
\boldsymbol{u}_{M}\right)\]</span>，M为对话数
<ul>
<li><span
class="math display">\[\boldsymbol{H}=\left(\boldsymbol{u}_{1},...,
\boldsymbol{u}_{T}\right)\]</span>，T为Token数</li>
</ul></li>
<li>情感编码器：<span
class="math display">\[\boldsymbol{E}=\operatorname{EmoBERTa}\left(\boldsymbol{[CLS]},
\boldsymbol{u}_{1}, \boldsymbol{[SEP]}, \boldsymbol{u}_{2}, ...,
\boldsymbol{u}_{M}\right)\]</span>，M为对话数
<ul>
<li><span
class="math display">\[\boldsymbol{E}=\left(\boldsymbol{e}_{1},...,
\boldsymbol{e}_{T}\right)\]</span>，T为Token数</li>
</ul></li>
<li>分类：<span
class="math display">\[\boldsymbol{o}=\operatorname{MLP}\left(\tanh
\left(\boldsymbol{W}_{o}^{T}[\boldsymbol{s} ; \boldsymbol{c} ;
\boldsymbol{r}]+\boldsymbol{b}_{\boldsymbol{o}}\right)\right)\]</span>
<ul>
<li>s、c、r 为策略S、上下文H、情感分类E。编码+平均池化操作后得到</li>
</ul></li>
</ul></li>
</ul></li>
<li>双层反馈
<ul>
<li>回合级反馈：局部变量，当前用户的感受。包含每轮对话Seeker情感Δe和Seeker评分变化Δr</li>
<li>对话级反馈：全局变量Δc，用户的全局状态。包含Seeker在谈话后的情绪压力、Supporter对话题的回应的相关性、Supporter对Seeker感受的理解和共情</li>
<li>融合adapter：整合回合级和会话级反馈的两类语义信息。Δs = Δe + Δr +
uΔc【计算损失时，给予正向或负向的反馈】</li>
</ul></li>
</ul></li>
<li><p>双控读取器（模仿情感聊天机器ECM）</p>
<ul>
<li>context-to-strategy：利用上下文信息来选择上下文相关的策略
<ul>
<li><span class="math display">\[\boldsymbol{g}^{c} =
\operatorname{sigmoid}\left(
\boldsymbol{W}_{c}^{T} \boldsymbol{c} + \boldsymbol{b}_{c}
\right)\]</span></li>
</ul></li>
<li>strategy-to-context：编码阶段可以关注与策略相关的上下文，从而生成策略约束的响应
<ul>
<li><span class="math display">\[\boldsymbol{g}^{o} =
\operatorname{sigmoid}\left(
\boldsymbol{W}_{o}^{T} \boldsymbol{o} + \boldsymbol{b}_{o}
\right)\]</span></li>
</ul></li>
<li>残差连接：在原始信息和更新信息之间进行权衡
<ul>
<li><span class="math display">\[\begin{array}{r}
o^{\prime}=(1-\beta) \cdot o+\beta \cdot g^{c} \otimes o \\
h_{t}^{\prime}=(1-\alpha) \cdot h_{t}+\alpha \cdot g^{o} \otimes h_{t}
\end{array}\]</span></li>
</ul></li>
</ul></li>
<li><p>策略字典</p>
<ul>
<li>输入策略令牌的描述，
而不是策略令牌，以便模型对策略进行更深入的理解</li>
<li>Encoder-Decoder
之间的状态传输类似于MISC，采用cross-attention代替self-attention<a
href="https://www.yuque.com/jinzang/lnx420/wrq82cgnp6p47q59?view=doc_embed">MISC:
A MIxed Strategy-Aware Model Integrating COMET for Emotional Support
Conversation</a></li>
</ul></li>
<li><p>响应生成</p>
<ul>
<li>BlenderBot Decoder：<span
class="math display">\[\boldsymbol{p}\left(y_{z} \mid
\boldsymbol{y}_{&lt;z}, \boldsymbol{h}_{\boldsymbol{t}}^{\prime},
\boldsymbol{V}\right)=\text { Generator }\left(\boldsymbol{W}_{y&lt;z},
\boldsymbol{h}_{\boldsymbol{t}}^{\prime},
\boldsymbol{V}\right)\]</span></li>
</ul></li>
<li><p>联合训练</p>
<ul>
<li>策略预测：反馈感知负对数似然 feedback-aware negative log-likelihood
<ul>
<li><span
class="math display">\[\mathcal{L}_{1}=\left\{\begin{array}{ccc}
-\hat{o} \log
\left(\operatorname{softmax}\left(\boldsymbol{o}^{\prime}\right)\right)
&amp; \text { if } &amp; \Delta s&gt;0 \\
-\hat{o} \log
\left(1-\operatorname{softmax}\left(\boldsymbol{o}^{\prime}\right)\right)
&amp; \text { if } &amp; \Delta s \leq 0
\end{array}\right.\\\]</span></li>
</ul></li>
<li>响应生成：标准交叉熵损失优化 cross-entropy
<ul>
<li><span class="math display">\[\mathcal{L}_{2}=-\sum_{z=1}^{Z} \log
\boldsymbol{p}\left(y_{z} \mid \boldsymbol{y}_{&lt;z},
\boldsymbol{h}_{\boldsymbol{t}}^{\prime}, \boldsymbol{V}\right)\]</span>
## Experiment</li>
</ul></li>
</ul></li>
<li><p>采用EmoBERTa-base作为特征提取器，以获取Seeker的情感得分和情感表征，情感得分由softmax函数使用EmoBERTa-base的[CLS]表示获得
## Experimental Results ## Analyses ## conclusion # 关注的问题</p></li>
</ul>
<ol type="1">
<li><p>预测策略只依靠对话历史，而不考虑求助者反馈，导致预测的结果与用户无关</p></li>
<li><p>建模过程只关注上下文到策略，而不关注策略到上下文和与策略相关的上下文
# 解决方法</p></li>
<li><p>双层反馈策略选择器：利用回合级和会话级反馈信息来激励或惩罚策略</p></li>
<li><p>双层控制阅读器：策略到上下文流来生成策略约束响应 # 创新点 /
本文的优势</p></li>
</ol>
<h1 id="实验结论">实验结论</h1>
<h1 id="有待提升的部分">有待提升的部分</h1>
]]></content>
      <categories>
        <category>读论文</category>
      </categories>
      <tags>
        <tag>情绪支持对话</tag>
      </tags>
  </entry>
  <entry>
    <title>论文阅读 KEMI</title>
    <url>/-2023/Knowledge-enhanced%20Mixed-initiative%20Dialogue%20System%20for%20Emotional%20Support%20Conversations/</url>
    <content><![CDATA[<p><strong>Title:</strong> Knowledge-enhanced Mixed-initiative Dialogue
System for Emotional Support Conversations</p>
<img data-src="/-2023/Knowledge-enhanced%20Mixed-initiative%20Dialogue%20System%20for%20Emotional%20Support%20Conversations/1699406609845-c98dd4cb-e2ae-41f2-99b8-aed67482d60d.png" class="" title="image.png">
<span id="more"></span>
<h1 id="论文速览">论文速览</h1>
<h2 id="abstract">Abstract</h2>
<ul>
<li><p>混和主动性：按照说话者角色和主动类型分为四类</p></li>
<li><p>提出四个情绪支持指标</p></li>
<li><p>提出一种用于 ESC 的知识增强混合主动框架 (KEMI) ##
Introduction</p></li>
<li><p>ESC系统</p>
<ul>
<li>在适当的时候发起讨论，目的是提出建议，并解决问题</li>
</ul></li>
<li><p>相关工作</p>
<ul>
<li>CIS(conversational
information-seeking)可以主动发起对话，澄清交互并探索更多的信息</li>
<li>情感推理用来生成共情反应</li>
<li>identifying the dialogue acts of the utterances</li>
<li>ESC 系统预测下一个对话策略</li>
</ul></li>
<li><p>ESC问题的三个挑战</p>
<ul>
<li>系统应该在对话过程中何时采取主动？</li>
<li>系统发起子对话需要什么样的信息？</li>
<li>系统如何促进混合主动交互？</li>
</ul></li>
<li><p>解决方法</p>
<ul>
<li>策略预测：确定下一回合混合主动策略</li>
<li>知识选择：收集下一回合的必要知识</li>
<li>响应生成：在适当的混合主动策略和知识下产生情感支持响应</li>
</ul></li>
<li><p>提出的新东西</p>
<ul>
<li>混合主动性特征
<ul>
<li>EAFR模式：话语注释为不同类型的说话者角色和主动类型</li>
<li>Expression, Action, Reflection, Feedback</li>
</ul></li>
<li>情感支持指标
<ul>
<li>Proactivity, Information, Repetition, Relaxation</li>
</ul></li>
<li>KEMI
<ul>
<li>使用生成的常识知识作为查询图来扩展用户话语，在知识图谱上执行子图检索</li>
<li>响应生成模块以序列到序列的方式，对策略预测和响应生成进行【多任务学习】，以生成具有外部知识的混合主动响应</li>
</ul></li>
</ul></li>
<li><p>主要贡献</p>
<ul>
<li>EAFR 注释模式和四种情感支持指标</li>
<li>使用用常识知识扩展的查询图，通过子图检索从心理健康知识图谱中检索外部知识
## Related Works</li>
</ul></li>
<li><p>ESC</p>
<ul>
<li>检测用户情绪</li>
<li>将情感信号放入Respond中</li>
<li>情绪感知反应，情感风格转移</li>
<li>共情对话系统
<ul>
<li>情感推理技巧</li>
<li>利用外部知识来提高情绪推理的建模能力：知识图、常识性模型、特定领域知识、常识性知识</li>
</ul></li>
</ul></li>
<li><p>混合主动对话 ## Preliminary Analysis</p></li>
<li><p>EAFR</p>
<ul>
<li>四种注释方法：按照角色和主动类型区分</li>
<li>四种评价指标：【待看】</li>
</ul></li>
<li><p>混合主动性分析</p></li>
<li><p>混和主动性的挑战</p>
<ul>
<li>系统何时采取主动？</li>
<li>系统发起子对话时，需要什么信息？
<ul>
<li>情感识别：识别用户情感状态</li>
<li>因果识别：导致情感状态的压力源</li>
<li>认知识别：解决问题的过程</li>
</ul></li>
<li>根据历史对话，系统自发判断响应的主动或被动</li>
</ul></li>
<li><p>问题定义</p>
<ul>
<li>给定历史对话C和用户情况s，产生相应r
<ul>
<li>策略预测y，细粒度主动性</li>
<li>知识选择k</li>
<li>使用y和k生成混合主动相应r ## Method</li>
</ul></li>
</ul></li>
<li><p>知识获取</p>
<ul>
<li>检索心理健康知识图谱HEAL，弥补常识性知识的不足
<ul>
<li>COMET常识性知识扩展查询：Cp = COMET(p, ut)</li>
<li>构造查询图：û = {ut, {Cp}}
<ul>
<li>expectation：ut</li>
<li>affective：[xReact]</li>
<li>stressor：[xIntent]</li>
<li>responses：[xWant] [xNeed] [xEffect]</li>
</ul></li>
<li>子图检索
<ul>
<li>相似度计算：sentence-BERT</li>
<li>针对每个 ût
中的抽象描述，获取与其最相似的top-K个HEAL中的实体，基于HEAL中的边缘连接，构成候选子图</li>
<li>针对每个 E
中的类型节点，按照子图中的每个节点相似度得分之和排序子图，选择top-N作为检索到的知识K</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>混合主动响应生成</p>
<ul>
<li>使用基于上下文的编码器，编码上下文对话C和知识K</li>
<li>X：[CLS]<context>[know.]&lt;know.&gt;；Y：[strategy]y[response]r</li>
<li>优化损失函数，最大化负对数似然函数L ## Experiment</li>
</ul></li>
<li><p>实验基础</p>
<ul>
<li>数据集：ESConv、MI</li>
<li>评估参数：流利度Perplexity (PPL)、内容保留度BLEU-n
(B-n)、内容保留度ROUGE-L (R-L)</li>
</ul></li>
<li><p>总体表现</p>
<ul>
<li>BlenderBot优于Transformer</li>
<li>GLHG、MISI有效地利用了常识性知识</li>
<li>基于策略的联合学习可以提高性能</li>
<li>KEMI明显优于其他方法：HEAL知识相比常识性知识更有效地支持了预测策略，减轻了对预训练大模型的依赖</li>
</ul></li>
<li><p>人工评价</p>
<ul>
<li>从流畅度、辨识度、舒适度、建议有效性、总体回应五个方面与BlenderBot-joint、MISC进行对比，MISC完胜</li>
</ul></li>
<li><p>消融实验</p>
<ul>
<li>HEAL可以有效提升策略预测准确度</li>
<li>舍弃COMET，可以提高ppl准确度，因为常识性知识不是自然语句；但会降低内容保留度，因为简洁的常识性知识更为精确</li>
<li>认知识别是最有效的</li>
<li>对比Oracle，还有很大的提升空间</li>
</ul></li>
<li><p>混和主动性分析</p>
<ul>
<li>情感支持指标分析
<ul>
<li>KEMI有效的平衡了主动性和非主动性回复</li>
<li>KEMI回复的信息更加丰富</li>
<li>KEMI容易生成重复性回复</li>
<li>KEMI有效地帮助用户解决情绪问题</li>
</ul></li>
<li>会话进度
<ul>
<li>相比BlenderBot和MISC，KEMI在对话过程中，主动性和非主动性的分布更加平衡</li>
<li>KEMI在对话中后期更能主动相应并缓解用户负面情绪</li>
</ul></li>
</ul></li>
<li><p>案例分析 ## Conclusions</p></li>
<li><p>首次提出ESC中混和主动性的特点，并阐述其重要性</p></li>
<li><p>KEMI框架</p>
<ul>
<li>通过查询扩展和子图检索，从大规模心理健康图谱中检索实际病例知识</li>
<li>通过检索到的知识，进行策略预测和响应生成的多任务学习</li>
</ul></li>
<li><p>结合实际案例和分析指标，结果证明KEMI优于现有方法，并在混合主动交互方面具有优势
## Limitations</p></li>
<li><p>评价指标有待改进</p></li>
<li><p>没有考虑不同知识检索方法的不同</p></li>
<li><p>从复杂的KG图中检索知识的方法有待提高</p></li>
<li><p>某些应用的知识图难以获取</p></li>
<li><p>知识库的建立需要具有专业知识的人员 ## Appendix</p></li>
<li><p>混和主动性</p>
<ul>
<li>对话主动性分析
<ul>
<li>主动性分析模型：在ESConv数据集增加混合主动的类型属性，把历史对话和当前话语作为二元输入，判断主动性。微调RoBERTTalarge，分别训练两个模型，判断用户和系统的主动性</li>
<li>情绪强度预测模型：根据用户话语预测负面情绪强度</li>
<li>用户模拟并注释四种评价指标 ：【待看】</li>
</ul></li>
<li>对话流分析
<ul>
<li>ESC在对话中充当主动角色；ED在对话中充当被动角色</li>
</ul></li>
<li>对话过程
<ul>
<li>研究内容：主动性和情绪强度变化的关系</li>
<li>结论
<ul>
<li>交互时间很重要</li>
<li>情绪缓解后才更有利于解决问题</li>
</ul></li>
</ul></li>
<li>ES指标</li>
</ul></li>
<li><p>COMET</p>
<ul>
<li>常识性关系</li>
</ul></li>
<li><p>HEAL</p>
<ul>
<li>情绪压力和安慰回应之间的知识图谱</li>
<li>表现了对话双方的情绪动态，确定缓解情绪的方法 # 解决了什么问题</li>
</ul></li>
<li><p>常识性知识是相当抽象的，没有详细的信息，因此它对ESC系统产生有意义和信息丰富的响应的帮助不大。在这项工作中，我们采用<strong>生成式常识模型</strong>进行查询扩展，从外部知识图中检索实际案例知识。
# 怎么解决的 / 该方法的优势</p></li>
</ul>
<ol type="1">
<li><p>常识知识生成器 COMET：</p></li>
<li><p>常识性知识获取 HEAL： # 有什么创新点</p></li>
<li><p>提出ESC知识增强混合主动框架</p>
<ol type="1">
<li>人类和系统都可以主动引导交互方向</li>
<li>通过子图检索从心理健康知识图谱中检索外部知识</li>
</ol></li>
<li><p>新的分析方法 &gt; 保留评估 和 混合主动性分析
方面均有效优于现有方法</p>
<ol type="1">
<li>按照说话者角色和主动类型将话语注释为不同类型
<ol type="1">
<li>Expression：用户主动</li>
<li>Action：系统主动</li>
<li>Feedback：用户非主动</li>
<li>Reflection：系统非主动</li>
</ol></li>
<li>提出四个情感支持指标来衡量ESC中主动性和非主动性交互的特征
<ol type="1">
<li>Proactivity：系统主动的对话占系统对话的比例</li>
<li>Information：系统首次提出的频繁词占比</li>
<li>Repetition：系统重复用户提出的术语的频次占比</li>
<li>Relaxation：情绪强度的改善 # 实验结果好在哪里，怎么证明的</li>
</ol></li>
</ol></li>
</ol>
<h1 id="相关工作分析">相关工作分析</h1>
<h1 id="可以提升的地方">可以提升的地方</h1>
]]></content>
      <categories>
        <category>读论文</category>
      </categories>
      <tags>
        <tag>情绪支持对话</tag>
      </tags>
  </entry>
  <entry>
    <title>论文阅读 MISC</title>
    <url>/-2023/MISC_%20A%20MIxed%20Strategy-Aware%20Model%20Integrating%20COMET%20for%20Emotional%20Support%20Conversation/</url>
    <content><![CDATA[<p><strong>Title:</strong> A MIxed Strategy-Aware Model Integrating
COMET for Emotional Support Conversation</p>
<img data-src="/-2023/MISC_%20A%20MIxed%20Strategy-Aware%20Model%20Integrating%20COMET%20for%20Emotional%20Support%20Conversation/1699523191286-4f020d4d-6fee-4fc2-b943-e0443b1ca667.png" class="" title="image.png">
<span id="more"></span>
<h1 id="论文速览">论文速览</h1>
<h2 id="abstract">Abstract</h2>
<ul>
<li><p>先前工作的局限性</p>
<ul>
<li>采用对话级别的情感标签，这种标签过于粗粒度，无法捕捉用户的即时精神状态</li>
<li>大多侧重于在回应中表达同理心，而不是逐渐减轻用户的痛苦</li>
</ul></li>
<li><p>本文提出了MISC</p>
<ul>
<li>首先推断用户的细粒度情感状态，然后使用混合策略巧妙地响应</li>
<li>在基准数据集上的实验结果证明了方法的有效性，并揭示了细粒度情感理解和混合策略建模的好处
## Introduction</li>
</ul></li>
<li><p>目前的工作不适用于ESC</p>
<ul>
<li>粗粒度静态的对话级情感标签无法关注到对话过程中用户情感发生的变化</li>
<li>只有移情反应，而不考虑解决求助者的情感问题</li>
</ul></li>
<li><p>本文提出的解决方法</p>
<ul>
<li>有选择地采用COMET（预训练生成式常识推理模型）生成的知识元组进行细粒度情感理解</li>
<li>混合策略，而不是预测单一策略</li>
<li>设计一套注意力机制</li>
</ul></li>
<li><p>实验分析</p>
<ul>
<li>回答策略建模的重要性，能够提高模型的共情能力 ## Related Work</li>
</ul></li>
<li><p>情绪感知响应生成</p></li>
<li><p>NLP中的常识性知识</p></li>
<li><p>策略感知对话模型 ## Preliminaries</p></li>
<li><p>ESConv数据集</p></li>
<li><p>问题设定</p>
<ul>
<li>通过对话历史、场景、求助者最后一句话，预测回复策略和回复内容 ##
Model: MISC</li>
</ul></li>
<li><p>情感状态增强Encoder</p>
<ul>
<li>利用COMET提取场景situation和语句x的常识性知识，将常识性知识输入Encoder得到H's和H'x</li>
</ul></li>
</ul>
<p><span
class="math display">\[\boldsymbol{B}^{s}=\bigcup_{j=1}^{N_{r}}\operatorname{COMET}\left(\mathrm{rel}_{j},\boldsymbol{s}\right)\]</span></p>
<ul>
<li>将H's和H'x分别与历史对话c做cross-attention，得到Hs和Hx</li>
<li>将历史对话c输入Encoder得到C</li>
<li>混合策略学习模块【从VQ-VAE's codebook文章中抄来的】
<ul>
<li>C输入多层感知机+softmax得到Pg（Pg大小是strategy_size）</li>
<li>Pg作为概率分布，hg=Pg*T（T为策略嵌入）
<ul>
<li>长对话回复中可以引入多种策略，且模型学习灵活方便</li>
</ul></li>
</ul></li>
<li>多因素感知Decoder
<ul>
<li>将情绪状态和策略表征传入Decoder里的Cross-attention ##
Experiments</li>
</ul></li>
<li>ESConv中的每十个话语作为一个样本</li>
<li>评价指标
<ul>
<li>策略预测精度：Acc</li>
<li>传统NLP指标：PPL、BLEU、ROUGE-L</li>
<li>相应多样性：Distinct</li>
<li>人类评估</li>
</ul></li>
<li>基准模型
<ul>
<li>MT Transformer、MoEL、MIME、BlenderBot-Joint</li>
</ul></li>
<li>具体实现</li>
<li>实验结果
<ul>
<li>动态细粒度情感标签更能准确给予用户回应</li>
<li>细粒度共情，多策略平稳过渡策略，可以更自然地表达共情并提供帮助</li>
<li>策略作为单独的任务进行预测比单一预测更有利</li>
<li>MISC的知识Know得分最高，成功学习到了COMET中的心理状态知识 ##
Analysis</li>
</ul></li>
<li>消融实验</li>
<li>案例研究</li>
<li>细粒度情感理解
<ul>
<li>用粗粒度的情感标签代替细粒度的心理信息可以显著提高指标</li>
</ul></li>
<li>混合策略感知移情反应
<ul>
<li>混合策略有利于平滑的情感支持</li>
<li>混合策略比单一策略更有效</li>
<li>混合策略适用于ESC框架 ## Conclusions</li>
</ul></li>
<li>引入COMET来捕捉用户的即时心理状态</li>
<li>设计了一个混合策略感知解码器来产生支持响应 # 解决了什么问题 /
怎么解决的</li>
</ul>
<h1 id="该方法的优势">该方法的优势</h1>
<ul>
<li><p>长对话中的过度更加顺畅 # 有什么创新点</p></li>
<li><p>提出seq2seq模型MISC，在ESC中添加了常识性知识和混合反应策略</p></li>
<li><p>提出了不同的策略模型并在对话中给予提示 #
实验结果好在哪里，怎么证明的</p></li>
<li><p>从SOTA延续下来的细粒度情感表现较粗粒度静态情感更好 #
相关工作分析</p></li>
</ul>
<h1 id="可以提升的地方">可以提升的地方</h1>
<ul>
<li>以动态的方式学习混合响应策略</li>
</ul>
]]></content>
      <categories>
        <category>读论文</category>
      </categories>
      <tags>
        <tag>情绪支持对话</tag>
      </tags>
  </entry>
  <entry>
    <title>论文阅读 BlenderBot</title>
    <url>/-2023/Recipes%20for%20building%20an%20open-domain%20chatbot/</url>
    <content><![CDATA[<p><strong>Title:</strong> Recipes for building an open-domain
chatbot</p>
<blockquote>
<p>FaceBook 在本文中提出了 BlenderBot 编解码器模型</p>
</blockquote>
<span id="more"></span>
<h1 id="论文速览">论文速览</h1>
<h2 id="abstract">Abstract</h2>
<ul>
<li><p>开放域聊天机器人需要良好的谈话技巧：提出有吸引力的要点，倾听别人的意见，适当展示知识、同理性和个性，保持前后一致</p></li>
<li><p>本文证实：基于适当的训练数据和生成策略，大模型可以学习上述技巧 ##
Introduction</p></li>
<li><p>研究的主要内容</p>
<ul>
<li>混合技巧：模型专注于个性和吸引力、知识、同理心。采用 Blended Skill
Talk
实现，具体是通过提供训练数据和初始化上下文来实现。这种方法可以减少从大语料库中学习到不良特征。</li>
<li>生成策略：解码算法非常重要，对话长度强相关于对话质量，本文实验表明采样优于束搜索</li>
</ul></li>
<li><p>本文的优势和存在的问题 ## Model architectures</p></li>
<li><p>检索</p>
<ul>
<li>将训练集作为候选响应集，每个可能的候选响应都参与Encoder，并做聚类【poly-encoder】</li>
</ul></li>
<li><p>生成</p>
<ul>
<li>使用标准的Seq2Seq Transformer架构生成响应</li>
</ul></li>
<li><p>检索和提炼</p>
<ul>
<li>帮助模型访问没有嵌入其模型参数的外部知识</li>
<li>对话检索：通过检索模型生成响应，并将其附加到Decoder的输入序列中，并用分隔符分开。使用修改后的输入序列生成正常的响应</li>
<li>知识检索：检索Wiki生成初始候选集，使用上文提到的检索模型，排序候选词并选择条件生成的句子。此外，训练一个分类器，通过上下文判断何时需要检索知识
## Training Objectives</li>
</ul></li>
<li><p>检索排序</p>
<ul>
<li>模型训练使用本文回答作为正例，其他对话回答作为负例</li>
</ul></li>
<li><p>响应生成模型的似然训练</p>
<ul>
<li>建模整个序列的概率分布</li>
</ul></li>
<li><p>α-混合检索和提炼</p>
<ul>
<li>生成模型常常不考虑对话检索语句，为确保其被使用，将检索相应中的α%替换成真实响应，α为超参数</li>
<li>知识检索的数据集里，知识条件和响应之间有明确的对应关系</li>
<li>因此训练阶段只使用知识检索的数据，充实模型参数中学到的知识</li>
</ul></li>
<li><p>响应生成模型的非似然损失</p>
<ul>
<li>使用高于真实数据数量的n元语法中的token作为候选负样本，修正已知的偏差
## Decoding 选择解码方法对给定的历史对话的响应</li>
</ul></li>
<li><p>确定性解码方法</p>
<ul>
<li>束搜索</li>
<li>贪心搜索</li>
</ul></li>
<li><p>采样</p>
<ul>
<li>多项采样：根据预测结果概率分布，定义候选Token被选中的概率。防止采样到低概率Token，可以将采样限制在词汇表的子集内，并根据子集概率重采样</li>
<li>平滑分布采样：Temparature+SoftMax+multinomial</li>
<li>top-k
sampling：Temparature+Top-k+SoftMax+multinomial，将top-k外的token概率置为0</li>
<li>sample-and-rank：多次采样，取最高概率的响应</li>
</ul></li>
<li><p>响应长度</p>
<ul>
<li>约束最小生成长度：在实现最小序列长度之前，强制不生成结束标记</li>
<li>预测长度：根据上下文预测相应长度，这是一个四分类问题</li>
</ul></li>
<li><p>子序列分块</p>
<ul>
<li>n-grams：考虑响应和输入上下文中对于n-grams的重复性 ## Training
Details</li>
</ul></li>
<li><p>预训练排序模型</p></li>
<li><p>预训练生成模型</p></li>
<li><p>微调</p>
<ul>
<li>Fairseq-style混合精度训练</li>
</ul></li>
</ul>
<p>Training Data Safety Characteristics Evaluation Methods Related Work
Results &amp; Analysis Released code and models Discussion # 关注的问题
/ 本文的优势</p>
<ul>
<li>成对比较和人性方面优于Meena # 解决方法 / 创新点</li>
</ul>
<h1 id="实验结论">实验结论</h1>
<h1 id="有待提升的部分">有待提升的部分</h1>
<ul>
<li>如果对话中深入询问某一方面，由于缺乏知识模型没法给出详细的回答</li>
<li>模型倾向于简单的回答</li>
<li>模型倾向于产生重复易混淆的句子</li>
</ul>
]]></content>
      <categories>
        <category>读论文</category>
      </categories>
      <tags>
        <tag>情绪支持对话</tag>
      </tags>
  </entry>
  <entry>
    <title>论文阅读 ESConv</title>
    <url>/-2023/Towards%20Emotional%20Support%20Dialog%20Systems/</url>
    <content><![CDATA[<p><strong>Title:</strong> Towards Emotional Support Dialog Systems</p>
<span id="more"></span>
<h1 id="论文速览">论文速览</h1>
<ul>
<li>Abstract
<ul>
<li>本文关注于情感支持对话，提供了一个带策略的情绪支持数据集</li>
</ul></li>
<li>Introduction
<ul>
<li>情感支持应用广泛</li>
<li>情绪支持数据集应该包括exploration、understand、suggestion三个过程，还包括有用户的情绪强度变化</li>
<li>目前的研究模型中没有具体有效的情绪支持方法；采集数据集时需要训练有素的支持者</li>
<li>ESC框架：三个阶段，多种策略；众包做数据集；在情绪支持方面有提升</li>
</ul></li>
<li>Related Work
<ul>
<li>移情、同感对话</li>
<li>情绪支持的数据集</li>
<li>情绪支持对话
<ul>
<li>任务定义</li>
<li>ESC框架
<ul>
<li>三个阶段：探索、理解、建议</li>
<li>八种策略</li>
</ul></li>
</ul></li>
</ul></li>
<li>Data Collection
<ul>
<li>获取数据集的方法</li>
</ul></li>
<li>Data Characteristics
<ul>
<li>数据展示</li>
</ul></li>
<li>Experiments
<ul>
<li>基准模型：BlenderBot、DialoGPT</li>
<li>模型变种：不带策略：Vanilla；带策略：Random、Joint、Oracle</li>
<li>评估指标：PPL、B-2、R-L、Extrema</li>
<li>实验结果：
<ul>
<li>带策略的Oracle优于不带策略的Vanilla</li>
<li>带策略的Oracle稍微弱于不带策略的Vanilla，因为一旦策略预测错误，respond会完全不同</li>
<li>BlenderBot 变体始终比 DialoGPT 变体表现更好</li>
</ul></li>
<li>人类互动评价结果：
<ul>
<li>微调后ES能力提升</li>
<li>带策略微调后能更加适合用户需求</li>
<li>正确的策略更重要</li>
</ul></li>
</ul></li>
<li>Conclusion
<ul>
<li>三个阶段、多种策略、ESConv</li>
<li>道德评估 # 解决了什么问题</li>
</ul></li>
</ul>
<ol type="1">
<li><p>目前的对话系统没有针对情感支持的任务和语料库，因此ESC方向还没有被探索到，对话场景中缺乏情感支持。</p></li>
<li><p>情感支持（ES）旨在减少个人的情绪困扰，帮助他们理解和应对所面临的挑战。目前的模型大都只能表示共情而不能解决问题。</p></li>
<li><p>通过社交而不是专业咨询的方式提供情感支持。 #
怎么解决的/该方法的优势</p></li>
<li><p>基于Hill的帮助技能理论，提出了ESC框架</p>
<ol type="1">
<li>情感支持过程
<ol type="1">
<li>理解遇到的困难，exploration</li>
<li>表达理解和同情，insight/comforting</li>
<li>提出解决问题的方法，action</li>
</ol></li>
</ol></li>
<li><p>构建ESConv数据集，有丰富的注释（支持策略）</p>
<ol type="1">
<li>每个聊天会都会标记：
<ol type="1">
<li>问题类别</li>
<li>用户情绪类别</li>
<li>用户情绪强度</li>
<li>遇到困难的简介</li>
</ol></li>
</ol></li>
<li><p>ESC系统</p>
<ol type="1">
<li>选择支持策略，生成策略约束Respond</li>
<li>情绪状态建模，跟踪用户情绪变化【待分析】</li>
<li>提出了评估ES实验效果的新方法 # 有什么创新点</li>
</ol></li>
</ol>
<h1 id="实验结果好在哪里怎么证明的">实验结果好在哪里，怎么证明的</h1>
<h1 id="相关工作分析">相关工作分析</h1>
<ol type="1">
<li>表达情感
<ol type="1">
<li>ECM：情感对话，可以生成情感反应。有情商而不只是智商</li>
<li>ES：有情绪支持的能力，可以减少用户情绪困扰</li>
</ol></li>
<li>共情能力
<ol type="1">
<li>反应出同情心，不能做情绪支持</li>
</ol></li>
<li>数据集
<ol type="1">
<li>数据集中的对话短，不适合ES任务</li>
</ol></li>
<li>ESC系统
<ol type="1">
<li>大多研究都人为预先规定好的规则和回复词典 # 可以提升的地方</li>
</ol></li>
</ol>
]]></content>
      <categories>
        <category>读论文</category>
      </categories>
      <tags>
        <tag>情绪支持对话</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发锁</title>
    <url>/-developer/JUC-Lock/</url>
    <content><![CDATA[<p>Java.util.concurrent 中有很多 Java 并发相关工具，例如 锁
<code>ReentrantLock</code>、线程 <code>Callable</code>
<code>FutureTask</code>、信号量 <code>Semaphore</code>、共享锁
<code>CountDownLatch</code></p>
<p>此外 Java 原生的 <code>volatile</code> 和 <code>synchronized</code>
关键字也是并发编程的关键。</p>
<span id="more"></span>
<p>简单的 CAS 实现：<code>AtomicInteger.compareAndSet(1, 2)</code></p>
<h1 id="synchronized-关键字">synchronized 关键字</h1>
<p><strong>属性：可重入锁、独占锁、非公平锁</strong></p>
<p>每个对象都有一个 <code>monitor</code>
对象于之关联，<code>synchronized</code> 通过对象监视器
<code>monitor</code> 和操作系统的 <code>Mutex Lock</code>
实现加锁和解锁，被锁住的区域是<code>临界区</code>：临界区内被锁保护，线程间只能串行访问的代码；</p>
<p><strong>作用域</strong>：</p>
<ul>
<li>修饰实例方法，锁当前对象实例。
<ul>
<li>修饰的方法在编译成字节码的时候，在 flag 上标记 ACC_SYNCHRONIZED</li>
</ul></li>
<li>修饰静态方法，锁当前类，会作用于所有实例。</li>
<li>修饰同步语句块，程序指定 Object / .class。
<ul>
<li>通过 monitorenter 和 monitorexit 指令实现</li>
</ul></li>
</ul>
<p><strong>锁粗化和锁消除</strong>：</p>
<ul>
<li>锁粗化：将多次锁请求合并成一个请求，以降低短时间内大量锁请求、同步、释放带来的性能损耗</li>
<li>锁消除：Java 虚拟机在 JIT
编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过锁消除，可以节省毫无意义的请求锁时间</li>
</ul>
<blockquote>
<p>.java -&gt; .class 字节码：Javac</p>
<p>字节码 -&gt; 机器码：JIT（Just-in-time）动态（即时）编译；AOT（Ahead
Of Time）运行前编译</p>
</blockquote>
<h2 id="锁升级策略"><a
href="https://www.cnblogs.com/yescode/p/14474104.html#autoid-0-0-0">锁升级策略</a></h2>
<ul>
<li><p>偏向锁：只有一个线程持有锁，无竞争情况时，线程可以直接获得锁，没有额外的开销。CAS
修改 Markword 头信息，该操作一般不会撤销，以避免 CAS 开销。</p></li>
<li><p>轻量级锁：多个线程都是在不同的时间段来请求同一把锁时，JVM
会使用轻量级锁：通过 CAS
尝试获取锁，不阻塞线程。如果竞争失败直接会升级成重量级锁，升级过程会自旋尝试获取锁。</p></li>
<li><p>重量级锁：加锁的过程中，采用自适应自旋，避免直接阻塞线程。自旋失败才会阻塞线程并入队，阻塞操作<code>LockSupport.park</code>由操作系统来实现，性能消耗高。唤醒线程的策略见下图：（waitset
环形双向链表；cxq 栈；entrylist 双向链表）</p></li>
</ul>
<img data-src="/-developer/JUC-Lock/1240-17140467896205.webp" class="" title="img">
<p>下图是<strong>对象头中的 MarkWord</strong>：MarkWord
结构之所以搞得这么复杂，是因为需要节省内存，让同一个内存区域在不同阶段有不同的用处（图有误，hashcode
占 32 位）</p>
<ul>
<li>指向线程栈中锁记录的指针 = 持有锁线程的 lockRecord 的指针</li>
<li>指向重量级锁的指针 = 指向 monitor 的指针</li>
</ul>
<img data-src="/-developer/JUC-Lock/3230688-20231101142351434-473719587.png" class="" title="img">
<h1 id="reentrantlock">ReentrantLock</h1>
<p><strong>属性：可重入锁、独占锁、公平锁 or 非公平锁</strong></p>
<p><strong>特点：可限时等待、可响应中断、可实现选择性通知</strong></p>
<p>使用场景：阻塞队列 <code>ArrayBlockingQueue</code>
<code>LinkedBlockingDeque</code> 通过 Condition
实现队列满插入和队列空取出的阻塞；作为读写锁
<code>ReentrantReadWriteLock</code> 的父类</p>
<p>源码结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">    <span class="comment">// 同步控制器（指向公平锁或非公平锁）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;...&#125;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不公平锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 公平锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现 Lock 接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.lock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ReentrantLock</code>独占锁运行过程（可重入锁的
<code>state</code> 表示==重入的次数==，会大于1）</p>
<style>.orcosxkounuv{}</style>
<img data-src="/-developer/JUC-Lock/aqs-exclusive-mode-acquire-lock.png" class="orcosxkounuv" alt="AQS 独占模式获取锁">
<h2 id="加锁失败时阻塞">加锁失败时阻塞</h2>
<p><code>ReentrantLock</code>在 CAS 加锁失败之后会将 Thread
封装成一个<code>Node</code>类型的对象加入<code>CLH</code>队列中</p>
<p>然后调用<code>LockSupport.park(this)</code>进行阻塞（<code>LockSupport</code>是一个
native 方法实现的工具类，在 hotspot
源码中通过<code>mutex</code>来实现的）</p>
<h2 id="与-synchronized-对比">与 synchronized 对比</h2>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 38%" />
<col style="width: 41%" />
</colgroup>
<thead>
<tr class="header">
<th>比较</th>
<th style="text-align: left;">ReentrantLock</th>
<th>synchronized</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>如何实现任务的等待-唤醒？</td>
<td style="text-align: left;">Condition 类
<code>await/signal</code>，可以有选择性的进行线程通知</td>
<td>Object 的 <code>wait/notify</code>，被通知的线程是由 JVM 选择的</td>
</tr>
<tr class="even">
<td>如何释放锁？</td>
<td style="text-align: left;">需要手动释放锁</td>
<td>出代码块后自动释放</td>
</tr>
<tr class="odd">
<td>底层如何实现？</td>
<td style="text-align: left;">API 实现</td>
<td>JVM 内部锁升级策略</td>
</tr>
<tr class="even">
<td>是否可实现可中断锁、公平锁？</td>
<td style="text-align: left;">可以</td>
<td>不可以</td>
</tr>
<tr class="odd">
<td>占用资源大不大？</td>
<td
style="text-align: left;">通过自旋<code>CAS</code>和<code>Unsafe.park/unpark</code>挂起唤醒线程</td>
<td>锁升级策略：轻量级锁<code>CAS</code>不会阻塞挂起；重量级锁才会和<code>ReentrantLock</code>一样<code>park/unpark</code></td>
</tr>
</tbody>
</table>
<p>可中断锁：获取锁的过程中可以被中断，不需要一直等到获取锁之后才能进行其他逻辑处理。</p>
<p>不可中断锁：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。</p>
<h1 id="abstractqueuedsynchronizer-抽象类">AbstractQueuedSynchronizer
抽象类</h1>
<p>ReentrantLock、倒计时器、信号量的 Sync 和线程池的 worker 都是基于 AQS
实现的。AQS
封装了线程的入队与出队、状态更新以及阻塞与唤醒等底层细节，通过重写<code>tryAcquire(int)</code>、<code>tryRelease(int)</code>等方法，实现类可以实现具体的资源控制逻辑。</p>
<p>AQS
核心思想：如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将<strong>共享资源设置为锁定状态</strong>。如果被请求的共享资源被占用，通过
CLH 锁实现<strong>线程阻塞等待以及被唤醒时锁分配</strong>。</p>
<p>CLH 锁：自旋锁的一种改进，利用 ==FIFO 双端队列== 和 ==Node 节点==
维护等待获取资源的线程队列，==state
成员变量==表示同步状态，每个节点中包括了线程的引用、
当前节点在队列中的状态、前驱节点和后继节点。</p>
<p>源码结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span> &#123;</span><br><span class="line">    <span class="comment">// 表示锁的持有数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line">    <span class="comment">// 双向队列（链表实现）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line">    <span class="comment">// 本地方法 eg:unsafe.compareAndSwapInt</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line">    <span class="comment">// 封装线程的节点</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="comment">// 标识当前节点对应的等待状态（不非负数时，仅作为普通标识，下文有详细介绍）</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">        <span class="comment">// 共享锁：Semaphore、CountDownLatch</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        <span class="comment">// 独占锁：ReentrantLock</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 条件队列中，表示下一个节点</span></span><br><span class="line">        <span class="comment">// 同步队列中，表示当前节点想要获取的是排他锁还是共享锁</span></span><br><span class="line">        Node nextWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 条件队列，保存有触发条件的 Node，实现选择性通知</span></span><br><span class="line">    <span class="comment">// 作用类似于 Object 内置的监视器方法：wait notify notifyAll</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionObject</span> <span class="keyword">implements</span> <span class="title class_">Condition</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 超时中断</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">spinForTimeoutThreshold</span> <span class="operator">=</span> <span class="number">1000L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>waitStatus 状态枚举值（初始值为 0，表示初始化状态）【使用情况】
<ul>
<li><code>CANCELLED</code> 表示线程已经被<u>取消</u>【响应中断】</li>
<li><code>SIGNAL</code> 表示后继节点的线程需要被唤醒【同步队列】</li>
<li><code>CONDITION</code>
表示线程在条件队列中等待某个<u>条件</u>满足【条件队列】</li>
<li><code>PROPAGATE</code> 表示共享模式下的资源传播【共享锁】</li>
</ul></li>
</ul>
<p><strong>实现类可以是独占锁或者共享锁</strong></p>
<ul>
<li>独占锁：tryAcquire-tryRelease</li>
<li>共享锁：tryAcquireShared-tryReleaseShared</li>
</ul>
<p><strong>线程调度逻辑</strong>：
当线程尝试获取资源失败时，会创建一个==Node节点==并将当前线程包装进去，然后利用==CAS算法==将其安全地加入到==等待队列的尾部==，并阻塞。<a
href="https://www.bilibili.com/video/BV1mP4y1i7Vm/?p=6&amp;spm_id_from=pageDriver">Link</a></p>
<style>.bleowjvvxjnr{zoom:67%;}</style>
<img data-src="/-developer/JUC-Lock/image-20240415164535374.png" class="bleowjvvxjnr" alt="image-20240415164535374">
<p>在释放资源时，AQS会根据资源管理策略从队列中选择合适的节点并唤醒对应线程。</p>
<h2 id="clh-锁">CLH 锁</h2>
<blockquote>
<p>Craig, Landin, and Hagersten locks
实现线程<u>阻塞等待</u>以及<u>被唤醒时锁分配</u>的机制</p>
</blockquote>
<p>CLH 锁是对自旋锁的一种改良，是一种隐式的链表队列</p>
<img data-src="/-developer/JUC-Lock/clh-queue-state.png" class="" title="CLH 队列">
<p>采用<strong>模板方法设计模式</strong></p>
<p>模板方法：抽象出步骤的执行顺序作为抽象方法，具体的实现方法交给子类实现。</p>
<p>自定义 <code>Synchronizer</code> 时需要重写几个 AQS
提供的钩子方法（通过钩子方法控制 <code>state</code>
为何值时代表加锁成功/失败、解锁成功/失败）：tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared、isHeldExclusively</p>
<ul>
<li>解释一下信号量、倒计时器、可重入锁的 state 的含义</li>
</ul>
<h2 id="locksupport-类">LockSupport 类</h2>
<p>操作 Node 中的 thread，实现线程的阻塞 <code>park</code> 和解除阻塞
<code>unpark</code> 。<a
href="https://juejin.cn/post/7023021536231555086">Link</a></p>
<p>具体来说，操作”许可“（多次 unpark
也只能获取一次许可，不可叠加），底层通过<code>mutex</code>（互斥量）和<code>condition</code>（条件变量）实现。【<code>mutex</code>存在用户态和内核态的切换】</p>
<blockquote>
<table>
<colgroup>
<col style="width: 37%" />
<col style="width: 62%" />
</colgroup>
<thead>
<tr class="header">
<th>Java 线程中断方法</th>
<th>方法意义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>Thread.currentThread().interrupt()</code></td>
<td>将线程的状态置为"中断"</td>
</tr>
<tr class="even">
<td><code>Thread.interrupted()</code></td>
<td>获取当前线程的中断状态，并且会清除线程的状态标记，静态方法</td>
</tr>
<tr class="odd">
<td><code>Thread.isInterrupted()</code></td>
<td>获取调用该方法的对象所表示的线程，不会清除线程的状态标记，实例方法阻塞和中断的区别？</td>
</tr>
</tbody>
</table>
<p>阻塞和中断的区别？</p>
</blockquote>
<h2 id="lock-接口">Lock 接口</h2>
<table>
<colgroup>
<col style="width: 45%" />
<col style="width: 54%" />
</colgroup>
<thead>
<tr class="header">
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>lock(): void</td>
<td>加锁（ReentrantLock 默认不可响应中断）</td>
</tr>
<tr class="even">
<td>lockInterruptibly(): void</td>
<td>加锁，阻塞等待锁的过程中，可以相应中断</td>
</tr>
<tr class="odd">
<td>tryLock(): boolean</td>
<td>非阻塞获取锁</td>
</tr>
<tr class="even">
<td>tryLock(long, TimeUnit): boolean</td>
<td>时间段内获取锁</td>
</tr>
<tr class="odd">
<td>unlock(): void</td>
<td>解锁</td>
</tr>
<tr class="even">
<td>newCondition(): Condition</td>
<td>获取条件等待队列</td>
</tr>
</tbody>
</table>
<h2 id="公平锁-非公平锁">公平锁 &amp; 非公平锁</h2>
<p><code>AbstractQueuedSynchronizer.hasQueuedPredecessors()</code>
线程在获取锁前，先判断一下自己在不在队列的首位，只有队首线程能被运行</p>
<h1 id="reentrantreadwritelock">ReentrantReadWriteLock</h1>
<p>继承自 ReentrantLock</p>
<p>读锁是共享锁，写锁是独占锁；读读不互斥、读写互斥、写写互斥；写锁可以升级成读锁</p>
<ul>
<li><strong>共享锁</strong>：一把锁可以被多个线程同时获得。</li>
<li><strong>独占锁</strong>：一把锁只能被一个线程获得。</li>
</ul>
<h1 id="stampedlock">StampedLock</h1>
<p>不是直接实现 <code>Lock</code>或
<code>ReadWriteLock</code>接口，而是基于 <strong>CLH 锁</strong>
实现的</p>
<h1 id="semaphore">Semaphore</h1>
<p>信号量，可选择公平 / 非公平锁。</p>
<p>控制同时访问特定资源的线程数量，通常用于那些资源有明确访问数量限制的场景，比如限流（仅限于单机模式，实际项目中推荐使用
Redis +Lua 来做限流）</p>
<h1 id="countdownlatch">CountDownLatch</h1>
<p>倒计时器：<code>await()</code>阻塞当前线程，当
<code>count</code>为零（即 state）时，唤醒所有被阻塞的线程。</p>
<p><code>CountDownLatch</code>
是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当
<code>CountDownLatch</code> 使用完毕后，它不能再次被使用</p>
<h1 id="cyclicbarrier">CyclicBarrier</h1>
<p>循环栅栏：让==一组线程==到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程都会继续干活。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java并发</tag>
        <tag>Java并发锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发基础</title>
    <url>/-developer/JUC/</url>
    <content><![CDATA[<img data-src="/-developer/JUC/image-20240516133953621.png" class="" title="image-20240516133953621">
<h1 id="threadlocal">ThreadLocal</h1>
<p>每一个线程都有自己的专属本地变量，通过空间换时间的方式避免并发下线程安全问题</p>
<ul>
<li>完整的一次请求处理，于唯一一个线程中执行，可以通过 ThreadLocal
共享数据</li>
<li>ThreadLocal.set 方法是将值存储到 <strong>Thread 线程本身的
ThreadLocalMap</strong> 里面</li>
</ul>
<p><strong>原理</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">            Object value;</span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="built_in">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存放数据</span></span><br><span class="line">        <span class="keyword">private</span> Entry[] table;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体结构图</p>
<style>.bjhadvicqbtf{zoom:50%;}</style>
<img data-src="/-developer/JUC/v2-ce5b8a32cd1245c7c8af5fc15ffcc39f_1440w.webp" class="bjhadvicqbtf" alt="img">
<p>引用关系图</p>
<style>.qnrwpxryqfdq{zoom:50%;}</style>
<img data-src="/-developer/JUC/v2-6875e31029e2c834cce5feb04bc22474_1440w.webp" class="qnrwpxryqfdq" alt="img">
<h2 id="qa">Q&amp;A</h2>
<p><strong>Entry的key为什么设计成弱引用？</strong></p>
<p>ThreadLocal 变量生命周期结束后，ThreadLocal 对象就可以被回收；</p>
<p><strong>ThreadLocal为什么会导致内存泄露，如何解决？</strong></p>
<p>虽然 get、set 或 remove 方法会回收 key 为 null 的 value
值，但是如果没有调用这些方法，Entry 和ThreadLocalMap
将会长期存在下去，会导致内存泄露；</p>
<p>使用完 ThreadLocal 对象之后，调用 remove 方法；</p>
<p><strong>ThreadLocal 是如何定位数据的？</strong></p>
<p><code>int i = key.threadLocalHashCode &amp; (len-1);</code></p>
<p>如果有冲突就通过线性探测再散列，直到找到空 bin；</p>
<blockquote>
<p>其他Hash冲突解决方法：开放寻址法（再散列）、拉链法</p>
</blockquote>
<p><strong>ThreadLocal 是如何扩容的？</strong></p>
<p><strong>父子线程如何共享数据？</strong></p>
<p>InheritableThreadLocal：初始化时会拷贝一份父线程中 ThreadLocal
值，到子线程 InheritableThreadLocal 中；</p>
<p><strong>ThreadLocal 作为成员变量时，为什么定义成 static
更好？</strong></p>
<p>将 ThreadLocal 定义为 static 可以确保所有线程都访问同一个 ThreadLocal
实例，但它们各自存储的数据是独立的；</p>
<p>确保它们的生命周期与线程的生命周期一致，而不是与类的实例的生命周期一致；</p>
<p><strong>使用 InheritableThreadLocal
时，如果父线程中重新set值，在子线程中能够正确的获取修改后的新值吗？</strong></p>
<p>不会影响到已经存在的子线程中 InheritableThreadLocal
的值，子线程将保持它在创建时从父线程中继承的原始值；</p>
<h1 id="jmm">JMM</h1>
<ul>
<li><p>抽象了 happens-before
原则来解决这个指令重排序问题，保证多线程环境下数据的一致性和可见性。</p></li>
<li><p>抽象了线程和主内存之间的关系，提供一套内存模型以屏蔽系统差异</p></li>
</ul>
<h2 id="概念">概念</h2>
<p>CPU 高速缓存：为解决 CPU 处理速度和内存不匹配的问题；</p>
<p>指令重排序【编译器优化重排 —&gt; 指令并行重排 —&gt;
内存系统重排】：指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致；</p>
<blockquote>
<p>内存屏障可以禁止处理器指令发生重排序，从而保障指令执行的有序性。此外，还能保证指令执行的可见性。</p>
</blockquote>
<h2 id="happens-before-原则">happens-before 原则</h2>
<p>前一个操作的结果对于后一个操作是可见的，无论这两个操作是否在同一个线程里</p>
<ul>
<li>只要不改变程序的执行结果，编译器和处理器怎么进行重排序优化都行；</li>
<li>会改变程序执行结果的重排序，JMM
要求编译器和处理器必须禁止这种重排序；</li>
</ul>
<h2 id="并发的三大特性">并发的三大特性</h2>
<p>原子性：一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行</p>
<ul>
<li>synchronized、各种 Lock 以及各种原子类；</li>
</ul>
<p>可见性：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值</p>
<ul>
<li>synchronized、Volatile 以及各种 Lock 实现可见性；</li>
</ul>
<p>有序性：代码的执行顺序未必就是编写代码时候的顺序</p>
<ul>
<li><p>Volatile
关键字：<strong>保证变量的可见性和代码执行的有序性</strong>，但无法在多线程读写变量时保证操作原子性；</p></li>
<li><p>内存屏障：<code>Unsafe</code> 类的 <code>fullFence()</code>
可以避免代码重排序；</p></li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java并发</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadPoolExecutor 和 CompletableFuture 实践</title>
    <url>/-developer/JUC-ThreadPool/</url>
    <content><![CDATA[<p>池化思想，维护一个池子，减少创建/销毁的开销，合理分配系统资源，但会增加调度开销。<a
href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">参考美团技术博客</a>：底层设计思想、业务实现</p>
<h1 id="threadpoolexecutor-线程池实现类">ThreadPoolExecutor
线程池实现类</h1>
<p><strong>执行流程图</strong></p>
<img data-src="/-developer/JUC-ThreadPool/77441586f6b312a54264e3fcf5eebe2663494.png" class="" title="图2 ThreadPoolExecutor运行流程">
<p><strong>线程池生命周期</strong></p>
<img data-src="/-developer/JUC-ThreadPool/582d1606d57ff99aa0e5f8fc59c7819329028.png" class="" title="图3 线程池生命周期">
<p><strong>任务调度流程</strong></p>
<p>所有任务的调度都是由execute方法完成的，这部分完成的工作是：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。其执行过程如下：</p>
<ol type="1">
<li>首先检测线程池运行状态，如果不是<code>RUNNING</code>，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。</li>
<li>如果<code>workerCount &lt; corePoolSize</code>，则创建并启动一个线程来执行新提交的任务。</li>
<li>如果<code>workerCount &gt;= corePoolSize，且线程池内的阻塞队列未满</code>，则将任务添加到该阻塞队列中。</li>
<li>如果<code>workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满</code>，则创建并启动一个线程来执行新提交的任务。</li>
<li>如果<code>workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满</code>,
则根据<u>拒绝策略</u>来处理该任务, 默认的处理方式是直接抛异常。</li>
</ol>
<img data-src="/-developer/JUC-ThreadPool/31bad766983e212431077ca8da92762050214.png" class="" title="图4 任务调度流程">
<h2 id="底层结构">底层结构</h2>
<p><strong>ThreadPoolExecutor 构造函数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> corePoolSize,  //线程池的核心线程数量</span></span><br><span class="line"><span class="params">    <span class="type">int</span> maximumPoolSize,  //线程池的最大线程数</span></span><br><span class="line"><span class="params">    <span class="type">long</span> keepAliveTime,  //当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span></span><br><span class="line"><span class="params">    TimeUnit unit,  //时间单位</span></span><br><span class="line"><span class="params">    BlockingQueue&lt;Runnable&gt; workQueue,  //任务队列，用来储存等待执行任务的队列</span></span><br><span class="line"><span class="params">    ThreadFactory threadFactory,  //线程工厂，用来创建线程，一般默认即可</span></span><br><span class="line"><span class="params">    RejectedExecutionHandler handler  //拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span></span><br><span class="line"><span class="params">)</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>核心线程数：CPU 密集型任务(N+1) I/O 密集型任务(2N) CPU 核心数 N</p>
<h3 id="阻塞队列-blockingqueue">阻塞队列 BlockingQueue</h3>
<p><a href="https://juejin.cn/post/6999798721269465102">Link</a></p>
<p>阻塞队列中保存即将运行的任务，BlockingQueue 与 Queue
的主要区别是：</p>
<ul>
<li>通过在入队和出队时进行加锁，保证了队列线程安全</li>
<li>支持阻塞的入队和出队方法：当队列满时，会阻塞入队的线程，直到队列不满；当队列为空时，会阻塞出队的线程，直到队列中有元素。</li>
</ul>
<p>底层实现</p>
<ul>
<li>采用 ReentrantLock 同步队列实现加锁解锁、阻塞释放</li>
<li>队列为空或已满的情况，采用条件队列 Condition</li>
</ul>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 74%" />
</colgroup>
<thead>
<tr class="header">
<th>阻塞队列</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ArrayBlockingQueue</td>
<td>有界队列</td>
</tr>
<tr class="even">
<td>LinkedBlockingQueue</td>
<td>不设置大小的话，默认无界队列</td>
</tr>
<tr class="odd">
<td>SynchronousQueue</td>
<td>如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务</td>
</tr>
<tr class="even">
<td>DelayedWorkQueue</td>
<td>内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序</td>
</tr>
<tr class="odd">
<td>PriorityBlockingQueue</td>
<td>优先级阻塞队列</td>
</tr>
</tbody>
</table>
<h3 id="创建线程工厂类-threadfactory">创建线程工厂类 ThreadFactory</h3>
<blockquote>
<p>参数可以设定线程名</p>
</blockquote>
<ul>
<li>java rt包：原生 ThreadFactory 类</li>
<li>hutool： ThreadFactoryBuilder</li>
<li>google guava.jar： ThreadFactoryBuilder</li>
</ul>
<p>自定义线程工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">testThreadPoolFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">threadIdx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String threadNamePrefix;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">testThreadPoolFactory</span><span class="params">(String Prefix)</span> &#123;</span><br><span class="line">        threadNamePrefix = Prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">        thread.setName(threadNamePrefix + <span class="string">&quot;-xxljob-&quot;</span> + threadIdx.getAndIncrement());</span><br><span class="line">        <span class="keyword">return</span> thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="任务拒绝策略">任务拒绝策略</h3>
<blockquote>
<p>在使用线程池并且使用有界队列的时候，如果队列满了，任务添加到线程池的时候就会拒绝，具体的拒绝策略可以设定</p>
</blockquote>
<table>
<colgroup>
<col style="width: 24%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="header">
<th>拒绝策略</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>AbortPolicy</td>
<td>线程池队列满了丢掉这个任务并且抛出 RejectedExecutionException
异常</td>
</tr>
<tr class="even">
<td>DiscardPolicy</td>
<td>如果线程池队列满了，会直接丢掉这个任务并且不会有任何异常</td>
</tr>
<tr class="odd">
<td>DiscardOldestPolicy</td>
<td>如果队列满了，会将最早进入队列的任务删掉腾出空间，再尝试加入队列</td>
</tr>
<tr class="even">
<td>CallerRunsPolicy</td>
<td>如果添加到线程池失败，那么主线程会自己去执行该任务</td>
</tr>
</tbody>
</table>
<p>自定义拒绝策略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRejectPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> &#123;</span><br><span class="line">        <span class="comment">//Sender是我的Runnable类，里面有message字段</span></span><br><span class="line">        <span class="keyword">if</span> (r <span class="keyword">instanceof</span> Sender) &#123;</span><br><span class="line">            <span class="type">Sender</span> <span class="variable">sender</span> <span class="operator">=</span> (Sender) r;</span><br><span class="line">            <span class="comment">//直接打印</span></span><br><span class="line">            System.out.println(sender.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程池实现接口">线程池实现接口</h2>
<img data-src="/-developer/JUC-ThreadPool/912883e51327e0c7a9d753d11896326511272.png" class="" title="图1 ThreadPoolExecutor UML类图">
<p>ExecutorService接口：（1）扩充执行任务的能力，补充可以为<strong>一个或一批异步任务</strong>生成
Future
的方法；（2）提供了<strong>管控线程池</strong>的方法，比如停止线程池的运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ExecutorService</span> <span class="keyword">extends</span> <span class="title class_">Executor</span> &#123;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//不再接受新任务，待所有任务执行完毕后关闭 ExecutorService  </span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//不再接受新任务，直接关闭 ExecutorService，返回没有执行的任务列表  </span></span><br><span class="line">    List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span>;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//判断ExecutorService是否关闭  </span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isShutdown</span><span class="params">()</span>;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//判断ExecutorService是否终止  </span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isTerminated</span><span class="params">()</span>;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//等待ExecutorService到达终止状态  </span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">awaitTermination</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当task执行成功的时候future.get()返回执行结果</span></span><br><span class="line">    &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//当task执行成功的时候future.get()返回result  </span></span><br><span class="line">    &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span>;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//当task执行成功的时候future.get()返回null  </span></span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//批量提交任务并获得他们的future，Task列表与Future列表一一对应  </span></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> <span class="keyword">throws</span> InterruptedException;  </span><br><span class="line"> </span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//批量提交任务并获得一个已经成功执行的任务的结果  </span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;  </span><br><span class="line">  </span><br><span class="line">    &lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>顶层接口 Executor
：==将任务提交和任务执行进行解耦==。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="comment">// 在未来的某个时间执行 command （方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否）</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="executors-线程池工厂类">Executors 线程池工厂类</h1>
<p><strong>FixedThreadPool 固定线程数</strong></p>
<p>运行中的 FixedThreadPool（未执行 shutdown()或
shutdownNow()）不会拒绝任务，在任务比较多的时候会导致
OOM（内存溢出）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img data-src="/-developer/JUC-ThreadPool/91ghx5ru0n.jpeg" class="" title="img">
<p><strong>SingleThreadExecutor
只有一个线程的线程池</strong>（FixedThreadPool 的特例）</p>
<p><strong>CachedThreadPool 根据需要创建新线程的线程池</strong></p>
<img data-src="/-developer/JUC-ThreadPool/ongsgtlllq.jpeg" class="" title="img">
<h1 id="completablefuture-异步执行结果类">CompletableFuture
异步执行结果类</h1>
<blockquote>
<p>RxJava、Reactor 比 CompletableFuture
增加了操作融合、延迟执行、回压等特性</p>
</blockquote>
<p>CompletableFuture实现 Future、CompletionStage 接口。</p>
<ul>
<li>Future
表示异步<strong>计算的结果</strong>，可以通过<code>Future</code>
类获取到耗时任务的执行结果</li>
<li>CompletionStage
用于表示异步执行过程中的一个<strong>步骤</strong>（Stage），这个步骤可能是由另外一个
CompletionStage 触发的，随着当前步骤的完成，也可能会触发其他一系列
CompletionStage
的执行。从而我们可以根据实际业务对这些步骤进行多样化的<strong>编排组合</strong>，CompletionStage
接口正是定义了这样的能力，我们可以通过其提供的 thenAppy、thenCompose
等函数式编程方法来组合编排这些步骤。</li>
</ul>
<p><code>FutureTask</code>相当于对<code>Callable</code>
进行了封装，管理着任务执行的情况，存储了 <code>Callable</code> 的
<code>call</code> 方法的任务执行结果</p>
<h2 id="注意事项">注意事项</h2>
<ul>
<li>Future 需要获取返回值，才能获取异常信息（即线程需要实现
<code>Callable</code> 接口，而 <code>Runnable</code>
接口创建线程不会返回结果或抛出检查异常）</li>
<li>CompletableFuture 的 get() 方法是阻塞等待的</li>
<li>异步调用强制传自定义线程池，做好线程池隔离</li>
<li>自定义线程池时，仔细考虑延迟队列满时，应采取什么拒绝策略</li>
</ul>
<p><strong>Q1</strong>：程序执行在哪个线程上？</p>
<p><strong>A1</strong>：</p>
<p>同步方法（即不带Async后缀的方法）有两种情况。</p>
<ul>
<li><p>如果注册时被依赖的操作已经执行完成，则直接由当前线程执行。</p></li>
<li><p>如果注册时被依赖的操作还未执行完，则由回调线程（按照当前 CF
运行情况区分）执行。</p></li>
</ul>
<p>异步方法（即带Async后缀的方法）：可以选择是否传递线程池参数Executor运行在指定线程池中；当不传递Executor时，会使用ForkJoinPool中的共用线程池CommonPool</p>
<p><strong>Q2</strong>：同步回调和异步回调的区别</p>
<p><strong>A2</strong>：</p>
<p>同步回调：把函数 b 传递给函数 a。执行 a 的时候，回调了 b，a
要一直等到 b 执行完才能继续执行；</p>
<p>异步回调：把函数 b 传递给函数 a。执行 a 的时候，回调了 b，然后 a
就继续往后执行，b 独自执行。</p>
<h3 id="线程池循环引用会导致死锁">线程池循环引用会导致死锁</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">doGet</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">ExecutorService</span> <span class="variable">threadPool1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">100</span>));</span><br><span class="line">  <span class="type">CompletableFuture</span> <span class="variable">cf1</span> <span class="operator">=</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">  <span class="comment">//do sth</span></span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;child&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;child&quot;</span>;</span><br><span class="line">      &#125;, threadPool1).join();<span class="comment">//子任务</span></span><br><span class="line">    &#125;, threadPool1);</span><br><span class="line">  <span class="keyword">return</span> cf1.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>threadPool1 大小为 10，当同一时刻有 10 个请求到达，则 threadPool1
被打满，子任务请求线程时进入阻塞队列排队，但是父任务的完成又依赖于子任务，这时由于子任务得不到线程，父任务无法完成。主线程执行
cf1.join() 进入阻塞状态，并且永远无法恢复。</p>
<h3
id="异步rpc调用注意不要阻塞io线程池">异步RPC调用注意不要阻塞IO线程池</h3>
<p>如果是使用基于 NIO（比如Netty）的异步 RPC，则返回结果是由 IO
线程负责设置的，即==回调方法由 IO 线程触发==，CompletableFuture
同步回调（如thenApply、thenAccept等无Async后缀的方法）如果依赖的异步 RPC
调用的返回结果，那么这些==同步回调将运行在IO线程==上，而整个服务只有一个IO线程池，这时需要==保证同步回调中不能有阻塞等耗时过长的逻辑==，否则在这些逻辑执行完成前，IO线程将一直被占用，影响整个服务的响应。</p>
<h2 id="实际使用场景">实际使用场景</h2>
<blockquote>
<p><a
href="https://tech.meituan.com/2022/05/12/principles-and-practices-of-completablefuture.html">美团技术博客</a></p>
</blockquote>
<p>服务端和客户端信息交换频繁，提升系统吞吐量</p>
<p>I/O密集型任务，对内<strong>调度</strong>各个下游服务获取数据进行<strong>聚合</strong></p>
<p>对业务流程进行编排，降低任务依赖导致的阻塞</p>
<p>避免 guava 的 ListenableFuture 回调所导致的回调地狱</p>
<h3 id="零依赖-构造方法">零依赖-构造方法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//1、使用runAsync或supplyAsync发起异步调用</span></span><br><span class="line">CompletableFuture&lt;String&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;result1&quot;</span>;</span><br><span class="line">&#125;, executor);</span><br><span class="line"><span class="comment">//2、CompletableFuture.completedFuture()直接创建一个已完成状态的CompletableFuture</span></span><br><span class="line">CompletableFuture&lt;String&gt; cf2 = CompletableFuture.completedFuture(<span class="string">&quot;result2&quot;</span>);</span><br><span class="line"><span class="comment">//3、先初始化一个未完成的CompletableFuture，然后通过complete()、completeExceptionally()，完成该CompletableFuture</span></span><br><span class="line">CompletableFuture&lt;String&gt; cf = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line">cf.complete(<span class="string">&quot;success&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="一元依赖-异步回调">一元依赖-异步回调</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; cf3 = cf1.thenApply(result1 -&gt; &#123;</span><br><span class="line">  <span class="comment">//result1为CF1的结果</span></span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;result3&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">CompletableFuture&lt;String&gt; cf5 = cf2.thenApply(result2 -&gt; &#123;</span><br><span class="line">  <span class="comment">//result2为CF2的结果</span></span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;result5&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="二元依赖-多任务">二元依赖-多任务</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; cf4 = cf1.thenCombine(cf2, (result1, result2) -&gt; &#123;</span><br><span class="line">  <span class="comment">//result1和result2分别为cf1和cf2的结果</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;result4&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="多元依赖">多元依赖</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; cf6 = CompletableFuture.allOf(cf3, cf4, cf5);</span><br><span class="line">CompletableFuture&lt;String&gt; result = cf6.thenApply(v -&gt; &#123;</span><br><span class="line">  <span class="comment">//这里的join并不会阻塞，因为传给thenApply的函数是在CF3、CF4、CF5全部完成时，才会执行 。</span></span><br><span class="line">  result3 = cf3.join();</span><br><span class="line">  result4 = cf4.join();</span><br><span class="line">  result5 = cf5.join();</span><br><span class="line">  <span class="comment">//根据result3、result4、result5组装最终result;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;result&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="使用方法">使用方法</h2>
<p><a href="https://zhuanlan.zhihu.com/p/647743286">方法汇总</a></p>
<h3 id="构造方法">构造方法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用默认内置线程池ForkJoinPool.commonPool()，根据supplier构建执行任务  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span>  </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 自定义线程池，根据supplier构建执行任务  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span>  </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 使用默认内置线程池ForkJoinPool.commonPool()，根据runnable构建执行任务  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 自定义线程池，根据runnable构建执行任务  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable, Executor executor)</span>  </span><br></pre></td></tr></table></figure>
<h3 id="获取结果方法">获取结果方法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span>  </span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span>  </span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">getNow</span><span class="params">(T valueIfAbsent)</span>  </span><br><span class="line"><span class="comment">// 不抛出异常 </span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">join</span><span class="params">()</span>  </span><br></pre></td></tr></table></figure>
<h3 id="异步回调方法"><strong>异步回调方法</strong></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行第二个任务时，则第二个任务和第一个任务是共用同一个线程池</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenRunAsync</span><span class="params">(Runnable action)</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 执行第二个任务时，使用给定的线程池</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenRunAsync</span><span class="params">(Runnable action, Executor executor)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个回调方法任务，会将该任务的执行结果，作为入参，传递到回调方法中，但是回调方法是没有返回值的</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action, Executor executor)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行第二个回调方法任务，会将第一个任务的执行结果，作为入参，传递到回调方法中，并且回调方法是有返回值的</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApplyAsync</span><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn)</span>;</span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApplyAsync</span><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn, Executor executor)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="异常处理方法"><strong>异常处理</strong>方法</h3>
<p>由于异步执行的任务在其他线程上执行，而异常信息存储在线程栈中，因此当前线程除非阻塞等待返回结果，否则无法通过try。CompletableFuture提供了异常捕获回调exceptionally，相当于同步调用中的try。使用方法如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> WmOrderAdditionInfoThriftService wmOrderAdditionInfoThriftService;<span class="comment">//内部接口</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Integer&gt; <span class="title function_">getCancelTypeAsync</span><span class="params">(<span class="type">long</span> orderId)</span> &#123;</span><br><span class="line">    CompletableFuture&lt;WmOrderOpRemarkResult&gt; remarkResultFuture = wmOrderAdditionInfoThriftService.findOrderCancelledRemarkByOrderIdAsync(orderId);<span class="comment">//业务方法，内部会发起异步rpc调用</span></span><br><span class="line">    <span class="keyword">return</span> remarkResultFuture</span><br><span class="line">          .thenApply(result -&gt; &#123;<span class="comment">//这里增加了一个回调方法thenApply，如果发生异常thenApply内部会通过new CompletionException(throwable) 对异常进行包装</span></span><br><span class="line">      <span class="comment">//这里是一些业务操作</span></span><br><span class="line">        &#125;)</span><br><span class="line">      .exceptionally(err -&gt; &#123;<span class="comment">//通过exceptionally 捕获异常，这里的err已经被thenApply包装过，因此需要通过Throwable.getCause()提取异常</span></span><br><span class="line">         log.error(<span class="string">&quot;WmOrderRemarkService.getCancelTypeAsync Exception orderId=&#123;&#125;&quot;</span>, orderId, ExceptionUtils.extractRealException(err));</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionUtils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Throwable <span class="title function_">extractRealException</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">          <span class="comment">//这里判断异常类型是否为CompletionException、ExecutionException，如果是则进行提取，否则直接返回。</span></span><br><span class="line">        <span class="keyword">if</span> (throwable <span class="keyword">instanceof</span> CompletionException || throwable <span class="keyword">instanceof</span> ExecutionException) &#123;</span><br><span class="line">            <span class="keyword">if</span> (throwable.getCause() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> throwable.getCause();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> throwable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 CompletableFuture 的任务不论是正常完成还是出现异常它都会调用
<code>whenComplete</code> 这回调函数。</p>
<ul>
<li>正常完成：<code>whenComplete</code> 返回结果和上级任务一致，异常为
null；</li>
<li>出现异常：<code>whenComplete</code> 返回结果为
null，异常为上级任务的异常；</li>
</ul>
<h3 id="多任务组合回调方法"><strong>多任务组合回调方法</strong></h3>
<p>thenCompose
可以用于组合多个CompletableFuture，将前一个任务的返回结果作为下一个任务的参数，它们之间存在着<strong>业务逻辑</strong>上的先后顺序，前后线程执行是同步的，前面阻塞后面不会执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenCompose</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span>;</span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenComposeAsync</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span> ;</span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenComposeAsync</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn, Executor executor)</span> ;</span><br></pre></td></tr></table></figure>
<p>thenCombine 第一个入参 CompletionStage
是异步的，合并结果的BiFunction是同步的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U,V&gt; CompletionStage&lt;V&gt; <span class="title function_">thenCombine</span> <span class="params">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> U,? extends V&gt; fn)</span>;</span><br></pre></td></tr></table></figure>
<p>applyToEither方法返回一个新的CompletionStage，当此阶段或另一个给定阶段正常完成时，将使用相应的结果作为所提供函数的参数来执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletionStage&lt;U&gt; <span class="title function_">applyToEither</span> <span class="params">(CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="built_in">super</span> T, U&gt; fn)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="底层代码">底层代码</h2>
<img data-src="/-developer/JUC-ThreadPool/82aa288ea62d74c03afcd2308d302b6910425.png" class="" title="图10 CF基本结构">
<p>result
用于存储当前CF的结果，stack（Completion）表示当前CF完成后需要触发的依赖动作（Dependency
Actions），去触发依赖它的CF的计算，依赖动作可以有多个（表示有多个依赖它的CF），以栈（Treiber
stack）的形式存储，stack表示栈顶元素。</p>
<p><strong>观察者模式</strong>：依赖动作（Dependency
Action）都封装在一个单独Completion子类中。CompletableFuture
中的每个方法都对应了图中的一个 Completion
的子类，Completion本身是<strong>观察者</strong>的基类。</p>
<img data-src="/-developer/JUC-ThreadPool/5a889b90d0f2c2a0f6a4f294b9094194112106.png" class="" title="图11 CF类图">
<p>一元依赖中的 thenApply 为例，举例“观察者模式”的设计思想</p>
<img data-src="/-developer/JUC-ThreadPool/f45b271b656f3ae243875fcb2af36a1141224.png" class="" title="图12 thenApply简图">
<p><strong>被观察者</strong></p>
<ol type="1">
<li>每个CompletableFuture都可以被看作一个被观察者，其内部有一个Completion类型的链表成员变量stack，用来存储注册到其中的所有观察者。当被观察者执行完成后会弹栈stack属性，依次通知注册到其中的观察者。上面例子中步骤fn2就是作为观察者被封装在UniApply中。</li>
<li>被观察者CF中的result属性，用来存储返回结果数据。这里可能是一次RPC调用的返回值，也可能是任意对象，在上面的例子中对应步骤fn1的执行结果。</li>
</ol>
<p><strong>观察者</strong></p>
<p>CompletableFuture支持很多回调方法，例如thenAccept、thenApply、exceptionally等，这些方法接收一个函数类型的参数
f，生成一个 Completion 类型的对象（即观察者），并将入参函数 f 赋值给
Completion 的成员变量 fn，然后检查当前 CF 是否已处于完成状态（即result
!= null），如果已完成直接触发 fn，否则将观察者 Completion 加入到 CF
的观察者链 stack
中，再次尝试触发，如果被观察者未执行完则其执行完毕之后通知触发。</p>
<ol type="1">
<li>观察者中的 dep 属性：指向其对应的 CompletableFuture，在上面的例子中
dep 指向 CF2。</li>
<li>观察者中的 src 属性：指向其依赖的 CompletableFuture，在上面的例子中
src 指向 CF1。</li>
<li>观察者 Completion 中的 fn
属性：用来存储具体的等待被回调的函数。这里需要注意的是<u>不同的回调方法</u>（thenAccept、thenApply、exceptionally等）<u>接收的函数类型也不同</u>，即fn的类型有很多种，在上面的例子中fn指向fn2。</li>
</ol>
<p><strong>Q1</strong>：为什么要在入栈前和入栈后都检查<code>result == null</code></p>
<p><strong>A1</strong>：因为查 result 和判断 result==null
是两个操作，CompletableFuture
没有对其加锁，若被观察者在这两个操作数之间完成，会导致观察者得不到通知</p>
<p><strong>Q2</strong>：当依赖多个CF时，观察者会被压入所有依赖的CF的栈中，每个CF完成的时候都会进行，那么会不会导致一个操作被多次执行呢
？如下图所示，即当CF1、CF2同时完成时，如何避免CF3被多次触发。</p>
<img data-src="/-developer/JUC-ThreadPool/316ff338f8dab2826a5d32dfb75ffede4158.png" class="" title="图15 多次触发">
<p><strong>A2</strong>：CompletableFuture的实现是这样解决该问题的：观察者在执行之前会先通过CAS操作设置一个状态位，将status由0改为1。如果观察者已经执行过了，那么CAS操作将会失败，取消执行。</p>
<p>CompletableFuture 处理并行问题的整体流程图：</p>
<img data-src="/-developer/JUC-ThreadPool/606323a07fb7e31cb91f46c879d99b8d735272.gif" class="" title="图16 完整流程">
<p><strong>二元依赖</strong></p>
<p>thenCombine 操作表示依赖两个 CompletableFuture。其观察者实现类为
BiApply，如上图所示，BiApply 通过 src 和 snd 两个属性关联被依赖的两个
CF，fn 属性的类型为
BiFunction。与单个依赖不同的是，在依赖的CF未完成的情况下，thenCombine
会尝试将 BiApply 压入这两个被依赖的 CF 的栈中，每个被依赖的 CF
成时都会尝试触发观察者 BiApply，BiApply
会检查两个依赖是否都完成，如果完成则开始执行。这里为了解决重复触发的问题，同样用的是上一章节提到的
CAS 操作，执行时会先通过 CAS 设置状态位，避免重复触发。</p>
<img data-src="/-developer/JUC-ThreadPool/b969e49a7eedbd52b014f86e86dcd3fc49634.png" class="" title="图17 二元依赖数据结构">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 状态位 Status 定义于 ForkJoinTask 类中</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Completion</span> <span class="keyword">extends</span> <span class="title class_">ForkJoinTask</span>&lt;Void&gt; <span class="keyword">implements</span> <span class="title class_">Runnable</span>, AsynchronousCompletionTask&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ForkJoinTask</span>&lt;V&gt; <span class="keyword">implements</span> <span class="title class_">Future</span>&lt;V&gt;&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>多元依赖</strong></p>
<p>依赖多个CompletableFuture的回调方法包括<code>allOf</code>、<code>anyOf</code>，区别在于<code>allOf</code>观察者实现类为BiRelay，需要所有被依赖的CF完成后才会执行回调；而<code>anyOf</code>观察者实现类为OrRelay，任意一个被依赖的CF完成后就会触发。二者的实现方式都是将多个被依赖的CF构建成一棵平衡二叉树，执行结果层层通知，直到根节点，触发回调监听。</p>
<img data-src="/-developer/JUC-ThreadPool/cef5469b5ec2e67ecca1b99a07260e4e22003.png" class="" title="图18 多元依赖结构树">
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java并发</tag>
        <tag>Java线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 虚拟机</title>
    <url>/-developer/JVM/</url>
    <content><![CDATA[<blockquote>
<p>《深入理解 <a
href="https://link.zhihu.com/?target=http%3A//www.shaoqun.com/s/Java.aspx">Java</a>
虚拟机 - <a
href="https://link.zhihu.com/?target=http%3A//www.shaoqun.com/s/JVM.aspx">JVM</a>
高级特性与最佳实践》</p>
</blockquote>
<p>TODO虚拟机器执行子系统、GC、内存区域、调优</p>
<h1 id="内存结构">内存结构</h1>
<p><a
href="https://blog.csdn.net/xiaojin21cen/article/details/104267301">方法区、永久代（PermGen
space）、元空间（Metaspace）的关系</a></p>
<img data-src="/-developer/JVM/image-20240429094145753.png" class="" title="image-20240429094145753">
<p>方法区</p>
<ul>
<li>主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出</li>
<li>方法区是 JVM 的规范，元空间是 HotSpot 虚拟机在 Java8
具体实现的方法区（JDK8 之前是永久代）</li>
</ul>
<p>Metaspace（元空间）替换 PermGen（永久代）的原因 &gt;
永久代存储在虚拟机堆中，元空间存储在本地内存中</p>
<ul>
<li>字符串存在永久代中，不方便管理维护，需要单独进行垃圾管理</li>
<li>类及方法的信息等比较难确定其大小，因此难以指定永久代的大小，太小容易出现永久代溢出，太大则容易导致老年代溢出</li>
<li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低</li>
<li>和其他虚拟机架构看齐，方便合并</li>
</ul>
<p>静态变量和基本数据类型包装类的常量池存在哪里？</p>
<ul>
<li>jdk1.6 及之前静态变量和 String Table 在永久代方法区</li>
<li>jdk1.8后
运行时常量池和静态变量在元空间，<strong>字符串常量池在堆空间</strong></li>
</ul>
<p>运行时常量池</p>
<ul>
<li>存储常量、引用、整数和浮点数等内存区域，是类加载后的第一个创建的内存区域，并且在整个
JVM 进程中共享</li>
<li>常量池中的内容是不可变的，可以通过符号引用进行共享，从而避免内存浪费</li>
</ul>
<p>方法区：全局，所有栈都可以访问</p>
<ul>
<li>static、ClassLoader</li>
</ul>
<h2 id="jvm-内存区域">JVM 内存区域</h2>
<p>线程私有的</p>
<ul>
<li>程序计数器（当前线程执行位置；依次读取代码）</li>
<li>本地方法栈（存储栈帧：局部变量表【值、引用指针、句柄】、操作数栈、动态链接【当一个方法要调用其他方法，将常量池中指向方法的符号引用转化为其在内存地址中的直接引用】、方法返回地址）</li>
<li>虚拟机栈</li>
</ul>
<p>线程共享的</p>
<ul>
<li>方法区（元空间、永久代）当虚拟机要使用一个类时，它需要读取并解析
Class
文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的
<strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等数据。（运行时常量池：即各种字面量和符号引用【解析阶段：JVM
将符号引用转为直接引用】）</li>
<li>堆（字符串常量池【<a
href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html">String#intern</a>】、静态变量）</li>
<li>本地内存</li>
</ul>
<h2 id="对象的创建过程">对象的创建过程</h2>
<img data-src="/-developer/JVM/1161857-20200427141816383-595743373.png" class="" title="img">
<p><strong>对象的创建过程</strong></p>
<ol type="1">
<li>查找常量池中是否有类的符号引用</li>
<li>分配内存：指针碰撞 OR 空闲列表（保证线程安全：CAS + 失败重试 OR
TLAB）</li>
<li>初始化零值</li>
<li>设置对象头：元数据信息、对象的哈希码、对象的 GC
分代年龄、是否启用偏向锁</li>
<li>执行 init 方法</li>
</ol>
<img data-src="/-developer/JVM/1161857-20200427171615978-465618542.png" class="" title="img">
<h2 id="对象访问定位">对象访问定位</h2>
<p>通过栈上的 引用指针 Reference
来操作堆上的具体对象：句柄、直接指针</p>
<ul>
<li>Java 堆中将会划分出一块内存来作为句柄池，reference
中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。在对象被移动时（垃圾收集时移动对象是非常普遍的行为）只会改变句柄中的实例数据指针。</li>
</ul>
<style>.vwpqxudtlcdy{zoom:50%;}</style>
<img data-src="/-developer/JVM/image-20240429100643112.png" class="vwpqxudtlcdy" alt="image-20240429100643112">
<ul>
<li>直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销，HotSpot
采用的是直接指针</li>
</ul>
<style>.mnjgsoepkleo{zoom:50%;}</style>
<img data-src="/-developer/JVM/image-20240429100908916.png" class="mnjgsoepkleo" alt="image-20240429100908916">
<h2 id="对象的内存布局">对象的内存布局</h2>
<p>Mark Word
是一个具有动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。</p>
<img data-src="/-developer/JVM/1161857-20200427173120968-675206595.png" class="" title="img">
<h1 id="gc-堆">GC 堆</h1>
<p>新生代 Young Generation</p>
<ul>
<li>Eden 区【新建对象分配地址】</li>
<li>两个 Survivor 区 S0 和 S1 【survivor 的阈值年龄取小（占用超过一半 s
区的年龄，MaxTenuringThreshold）】</li>
</ul>
<p>老生代 Old Generation</p>
<p>HotSpot VM 的实现里的 GC 其实准确分类只有两大种：</p>
<p>部分收集 (Partial GC)：</p>
<ul>
<li>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</li>
<li>老年代收集（Major GC / Old
GC）：只对老年代进行垃圾收集。需要注意的是 Major GC
在有的语境中也用于指代整堆收集；
<ul>
<li>触发条件：老年代空间不足、方法区空间不足</li>
</ul></li>
<li>混合收集（Mixed GC）：</li>
</ul>
<h1 id="垃圾回收">垃圾回收</h1>
<h2 id="gc-root">GC Root</h2>
<p>虚拟机栈、本地方法栈、方法区中类静态属性、方法区中常量、JNI
引用的对象</p>
<p>被同步锁持有的对象</p>
<p><strong>记忆集与卡表</strong>：</p>
<p>记忆集是一种用于记录从<strong>非收集区域指向收集区域的指针集合</strong>的抽象数据结构。在垃圾收集的场景中，收集器只需要通过记忆集判断出<strong>某一块非收集区域是否存在有指向了收集区域的指针</strong>，并不需要了解这些跨代指针的全部细节。老年代划分为若干个小块，标识出老年代哪一块内存会存在跨代引用。当发生
Minor GC 时，只有包含了跨代引用的小块内存中的老年代对象才会加入到 GC
Roots 扫描中，避免整个老年代加入到 GC Roots 中</p>
<h2 id="垃圾收集算法">垃圾收集算法</h2>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 38%" />
<col style="width: 38%" />
<col style="width: 9%" />
</colgroup>
<thead>
<tr class="header">
<th>垃圾收集算法</th>
<th>优点</th>
<th>缺点</th>
<th>适用范围</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>标记清除法</td>
<td>不需要移动对象，简单高效</td>
<td>标记效率低（访问全部内存）内存碎片</td>
<td>老年代</td>
</tr>
<tr class="even">
<td>标记复制算法</td>
<td>无内存碎片</td>
<td>频繁复制；内存使用率低</td>
<td>新生代</td>
</tr>
<tr class="odd">
<td>标记整理法</td>
<td>结合了上面两个优点</td>
<td>移动局部对象</td>
<td>老年代</td>
</tr>
<tr class="even">
<td>分代收集算法</td>
<td>根据对象存活概率，选择垃圾收集算法</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="垃圾回收器">垃圾回收器</h2>
<p>GCRoot：栈帧中引用的对象、静态变量、常量、本地方法栈中对象 STW：Stop
the World</p>
<table>
<thead>
<tr class="header">
<th>Young GC</th>
<th>Old GC</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Serial 串行、标记-复制</td>
<td>Serial Old 标记-整理（STW）</td>
</tr>
<tr class="even">
<td>PawNew 并行、标记-复制</td>
<td>CMS 降低单次垃圾收集时间</td>
</tr>
<tr class="odd">
<td>Parallel Scavenge 吞吐率</td>
<td>Parallel Old</td>
</tr>
</tbody>
</table>
<img data-src="/-developer/JVM/1712545820562-e5255e3e-762c-44b8-a179-1cca4068b847.png" class="" title="image.png">
<h3 id="cms">CMS</h3>
<blockquote>
<p>以获得最短回收停顿时间为目标的收集器</p>
</blockquote>
<p>流程</p>
<ul>
<li>初次标记 STW：标记直接与 root 相连的对象</li>
<li>并发标记：标记可达对象，跟踪更新记录</li>
<li>重新标记 STW：修正并发标记的变动</li>
<li>并发清理：标记-清理（不用 STW，但清理会产生内存碎片，复制不会）</li>
</ul>
<p>优点</p>
<ul>
<li>并发收集、低停顿</li>
</ul>
<p>缺点</p>
<ul>
<li>对 CPU 资源敏感；</li>
<li>无法处理浮动垃圾；</li>
<li>它使用的回收算法“标记-清除”算法会导致收集结束时会有大量空间碎片产生，过量碎片会导致
Full GC；</li>
<li>并发失败：并发清理的时候用户线程没有足够的 JVM 内存，会导致 STW
并产生内存碎片<br />
### <a
href="https://github.com/sunwu51/notebook/blob/master/19.09/java_jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.md">G1</a>
&gt; G1
跟踪每个区域的垃圾大小，在后台维护一个优先级列表，每次根据允许的收集时间，优先回收价值最大的区域，已达到在有限时间内获取尽可能高的回收效率</li>
</ul>
<img data-src="/-developer/JVM/image-20240429095131808.png" class="" title="image-20240429095131808">
<p>内存结构</p>
<ul>
<li>Region 大小 1M~32M、个数大概 2000</li>
<li>&gt;=0.5 Region &lt;1Region：H 区（超大对象存储区）</li>
<li>&gt;1Region：多个连续存储区</li>
</ul>
<p>概念</p>
<ul>
<li>RememberSets，又叫 Rsets 是每个 region
中都有的一份存储空间，用于存储本 region 的对象被其他 region
对象的引用记录</li>
<li>CollectionSets，又叫 Csets 是一次 GC 中需要被清理的 regions
集合，注意G1每次 GC 不是全部 region
都参与的，可能只清理少数几个，这几个就被叫做 Csets</li>
</ul>
<p><a
href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html">Young
GC</a> 复制清理的过程 <img data-src="/-developer/JVM/image-20240429095142614.png" class="" title="image-20240429095142614"> MixGC（没有 Old GC
的概念，新老代一起 GC)类似于 CMS</p>
<ul>
<li>初次标记 STW：标记直接与 GCRoot 相连的对象，和该对象所处的
Region(RootRegion)</li>
<li>扫描 RootRrgion：遍历 old Region，如果 rset 中存在
RootRegion，则标记（即为可达的 Region）</li>
<li>并发标记：同 CMS，但仅遍历标记的 Region</li>
<li>重新标记 STW：SATB 算法</li>
<li>筛选回收 STW：局部的标记整理垃圾收集</li>
</ul>
<img data-src="/-developer/JVM/image-20240429095150787.png" class="" title="image-20240429095150787">
<p>对比CMS，有哪些不同？</p>
<ul>
<li>region化的内存结构，采用复制清理的方式，避免了内存碎片。但是这种清理也造成了STW</li>
<li>SATB速度更快</li>
<li>初始标记，并发标记，重新标记，清理垃圾四个阶段很像，但是G1中有很多标记region的操作，并借助Rset进行了范围的缩小，提高了并发标记的速度。小结下就是初始标记和YGC的STW一起了，提高了效率；并发标记因为rset的设计，扫描范围缩小了，提高了效率；重新标记因为使用了SATB提高了效率；清理虽然造成了STW，但是复制使内存紧凑，避免了内存碎片。同时只清理垃圾较多的region，最大限度的降低了STW时间</li>
</ul>
<img data-src="/-developer/JVM/image-20240429095159588.png" class="" title="image-20240429095159588">
<p>GC 回收，针对堆内存 GC 回收问题：<a
href="https://heapdump.cn/article/1661497">YGC</a>、<a
href="https://heapdump.cn/article/1870333">FGC</a></p>
<h1 id="类加载过程">类加载过程</h1>
<strong>类的生命周期</strong>：加载、连接、初始化、使用、卸载
<style>.fxhndtshshik{zoom:67%;}</style>
<img data-src="/-developer/JVM/image-20240429095206248.png" class="fxhndtshshik" alt="image-20240429095206248">
<ul>
<li>加载：通过全类名获取定义此类的二进制字节流；将字节流所代表的静态存储结构转换为方法区的运行时数据结构；在内存中生成一个代表该类的
<code>Class</code>
对象，作为方法区这些数据的访问入口；【通过类加载器实现加载，通过双亲委派模型决定采用哪个类加载器】</li>
<li>验证：确保 Class 文件的字节流中包含的信息无误</li>
<li>准备：分配内存并设置类变量初始值</li>
<li>解析：将常量池内的<strong>符号引用替换为直接引用</strong>，也就是得到类或者字段、方法在内存中的指针或者偏移量；</li>
<li>初始化：执行字节码中的构造器来初始化类</li>
</ul>
<h1 id="类加载器">类加载器</h1>
<blockquote>
<p>负责加载类的对象，主要作用就是加载 Java 类的字节码（ .class 文件）到
JVM 中（在内存中生成一个代表该类的 Class 对象）；</p>
</blockquote>
<p>将“通过类的全限定名获取描述类的二进制字节流”这件事放在虚拟机外部，由应用程序自己决定如何实现；
<img data-src="/-developer/JVM/image-20240429095212841.png" class="" title="image-20240429095212841">（启动类加载器：虚拟机的一部分)</p>
<h2 id="双亲委派模型">双亲委派模型</h2>
<blockquote>
<p>决定类由哪个类加载器加载
编程思想：在面向对象编程中，有一条非常经典的设计原则：组合优于继承，多用组合少用继承（即双亲委派的实现方法）</p>
</blockquote>
<ul>
<li>ClassLoader
类使用委托模型来搜索类和资源。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。
<ul>
<li>获取该类的类加载器getClassLoader()方法；获取父类的类加载器getParent()</li>
</ul></li>
<li>ClassLoader
实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。</li>
</ul>
<p><strong>为什么用双亲委派？</strong></p>
<ul>
<li>相同二进制名称的类只会被加载一次，已经加载的类会被放在 ClassLoader
中，防止重复加载；</li>
<li>保证了 Java 的核心 API 不被篡改；</li>
</ul>
<p><strong>为什么打破双亲委派？</strong></p>
<ul>
<li>Tomcat 下 Web
应用之间的类需要实现隔离，打破双亲委派可以更好地管理多个Web应用程序的类加载，并避免类加载冲突。</li>
<li>SPI 的接口是由 Java 核心库提供的（BootstrapClassLoader），SPI
的实现是由第三方供应商提供的（AppClassLoader），实现类无法通过接口的加载器加载</li>
</ul>
<p>ClassLoader 抽象类：</p>
<ul>
<li>loadClass(String name, boolean resolve)
：父类的加载器不为空，则通过父类的loadClass来加载该类。如果要打破双亲委派机制，就重写这个方法；</li>
<li>findClass(String
name)：当父类加载器无法加载时，根据类的二进制名称来加载该类；</li>
</ul>
<p><a
href="https://javaguide.cn/java/jvm/classloader.html#%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E6%96%B9%E6%B3%95">线程上下文类加载器</a></p>
<ul>
<li>类加载器保存在线程私有数据里，跟线程绑定。解决了，默认情况下一个类及其依赖类由同一个类加载器加载，而接口的类加载器和子类或实现类的加载器不是同一个加载器。</li>
</ul>
<h1 id="jvm-调优">JVM 调优</h1>
<p>配置Java堆和元空间大小</p>
<p>选择垃圾回收器：CMS 升级到 G1，甚至 ZGC。</p>
<p>JVM性能监控和调试，分析堆内存状态，合理优化代码</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 面试常见问题和知识点</title>
    <url>/-developer/Java-Interview/</url>
    <content><![CDATA[<h1 id="java-basic">Java-basic</h1>
<h1 id="jvm">JVM</h1>
<ol type="1">
<li>了解垃圾回收机制吗？新生代和老年代的垃圾回收是怎么样的</li>
</ol>
<h1 id="juc">JUC</h1>
<ol type="1">
<li>简要描述线程与进程的关系，区别及优缺点？</li>
<li>线程之间哪些资源是共享的，哪些资源是私有的，为什么？</li>
<li>说一下你对于 AQS 原理的理解。</li>
<li>如何实现线程安全？</li>
</ol>
<h1 id="中间件">中间件</h1>
<ol type="1">
<li>了解过消息中间件吗？说一下使用场景</li>
</ol>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 语言</title>
    <url>/-developer/Java/</url>
    <content><![CDATA[<h1 id="基础">基础</h1>
<h2 id="基本数据类型">基本数据类型</h2>
<p>除八个基本类型，Java 的所有数据类型都是引用，Java
中没有指针的概念，所有数据传输都是传值（引用可以看作是地址值，所有引用值都占四个字节）</p>
<p>基本数据类型的包装类 Byte Short Integer Long Character 有常量池</p>
<h2 id="编译运行">编译运行</h2>
<ul>
<li>Java 编译器 Javac 是用 Java 实现的，用于将 .java 文件编译成字节码
.class</li>
<li>.class 通过解释器对这些字节码进行解释执行</li>
<li>Java 的运行环境 JVM 如 HotSpot VM，实现了其跨平台的特性</li>
</ul>
<h2 id="三大特性">三大特性</h2>
<p><strong>封装</strong></p>
<p>将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体；</p>
<p><strong>继承</strong></p>
<p>支持类之间的单继承，但支持接口之间的多继承；</p>
<p>类可以实现多个接口，抽象类不能实例化但可以有构造方法，内部类只能通过外部类创建；</p>
<p>Object 是超类，是所有类的父类（无父类的子类默认继承
Object。jdk6之前是编译器处理，jdk7之后是虚拟机处理）；</p>
<p>Java8 之后接口可以有默认方法，允许在接口中声明静态方法；</p>
<p><strong>多态</strong></p>
<p>全面支持动态绑定，动态绑定是实现多态（一个接口，多种实现）的基础；</p>
<ul>
<li>多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法（A
a=new B()，A是父类，B是子类）</li>
<li><strong>静态绑定</strong>：对象属性和 static private final
修饰的对象方法（构造函数），哪里声明，哪里使用</li>
<li><strong>动态绑定</strong>：运行时 JVM
实现绑定。若子类实现了这个方法，则调用子类的内存地址，若没有则调用当前对象（父类）的方法。只能调用父类的属性，虽然实际实现的是子类，如果父类没有这个属性，那就无法调用。如果要获取子类属性，就要重写子类方法获取该属性，前提是这个方法在父类中同样存在。</li>
</ul>
<h2 id="关键字">关键字</h2>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 83%" />
</colgroup>
<thead>
<tr class="header">
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>final</td>
<td>常量</td>
</tr>
<tr class="even">
<td>static</td>
<td>静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝；静态方法，不能使用类的非静态变量，类名直接调用，不需要进行实例化对象。</td>
</tr>
<tr class="odd">
<td>native</td>
<td>本地、原生方法（非 Java 实现）</td>
</tr>
<tr class="even">
<td>strictfp</td>
<td>严格浮点、精准浮点</td>
</tr>
<tr class="odd">
<td>synchronized</td>
<td>线程、同步</td>
</tr>
<tr class="even">
<td>transient</td>
<td>修饰的成员属性变量不被序列化，仅存于调用者的内存中而不会写到磁盘里持久化，防止敏感信息泄露（与Serilizable接口一同使用）当对象被反序列化时，被
transient 修饰的变量值不会被持久化和恢复，直接设置为默认值。static
不属于任何对象，因此永远不会被序列化。</td>
</tr>
<tr class="odd">
<td>volatile</td>
<td>变量在 CPU
的寄存器中是不确定的，必须从主存中读取。保证多线程环境下变量的可见性；禁止指令重排序。</td>
</tr>
<tr class="even">
<td>instanceof</td>
<td>实例</td>
</tr>
</tbody>
</table>
<h2 id="运算符优先级">运算符优先级</h2>
<img data-src="/-developer/Java/image-20240516125841876.png" class="" title="image-20240516125841876">
<h2 id="自动装箱拆箱">自动装箱/拆箱</h2>
<blockquote>
<p>jdk1.5 i = Integer.valueOf(3) -128-127</p>
</blockquote>
<p>自动装箱通常也不会通过显式的 valueOf
方法调用实现。<strong>编译器</strong>生成的字节码可能直接使用内部指令或方法来处理装箱和拆箱，而不是通过Java方法调用机制。因此，在
valueOf 方法上设置断点通常不会捕获到自动装箱的过程。
<code>new String("abc")</code> 和 <code>String.valueOf("abc")</code>
的区别：前者在堆中创建了新的对象，后者返回字符串常量池对象的引用。拆箱：xxxValue()；装箱：valueOf()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">zhuangXiang</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a3</span> <span class="operator">=</span> <span class="number">256</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a4</span> <span class="operator">=</span> a1 + a2;</span><br><span class="line">    System.out.println(a1 == a2); <span class="comment">// false</span></span><br><span class="line">    System.out.println(a4 == a3); <span class="comment">// false</span></span><br><span class="line">    System.out.println(a1 + a2 == a3); <span class="comment">// true 发生拆箱</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NPE 问题</p>
<ul>
<li>数据库查询返回结果为 Null，无法拆箱</li>
<li>三目运算符可能出现问题：flag ? 0 : i（应使用 flag ? new Integer(0) :
i）</li>
</ul>
<h2 id="动态代理">动态代理</h2>
<p>静态代理：编译时完成 动态代理：运行时动态生成类字节码，并加载到 JVM
中</p>
<ul>
<li>JDK
动态代理：通过生成一个实现被代理类接口的对象来拦截被代理类的方法调用
<ul>
<li>封装：Proxy.newProxyInstance() 指定 ClassLoader 对象和一组
interface</li>
<li>调用：InvocationHandler 接口 invoke 方法</li>
</ul></li>
<li>CGLIB
动态代理：通过生成一个被代理类的子类来拦截被代理类的方法调用（字节码实现，不能被
final 修饰，编译速度慢，运行速度快）
<ul>
<li>封装：Enhancer 类</li>
<li>调用：MethodInterceptor 接口 intercept 方法</li>
</ul></li>
</ul>
<p>二者的具体实现</p>
<ul>
<li>JDK：运行时动态解析，无法应用一些 JVM 优化</li>
<li>CGLib：ASM 开源包，代理对象类的 class
文件加载时，修改其字节码生成代理子类（ASM
是在编译期处理字节码的，可以认为是一种编译期的 AOP 技术）</li>
</ul>
<p>为什么 JDK 动态代理，要求被代理对象必须实现一个接口？</p>
<ul>
<li>因为 JDK 动态代理类已经继承了 Proxy
这个类，所以只能通过接口来与被代理类建立联系（两个类建立起联系，一是继承的关系【jdk已经不能通过这个方式了，因为java仅支持单继承】，另一种就是实现同一个接口【JDK动态代理选这种】），所以必须要求被代理类也得实现一个接口</li>
</ul>
<h2 id="原生工具类">原生工具类</h2>
<p>Collections 集合操作类</p>
<ul>
<li>sort(list)</li>
<li>reverse(list)</li>
<li>binarySearch(list, target)</li>
</ul>
<p>Arrays 数组操作类</p>
<ul>
<li>max(list)</li>
<li>sort(array, (o1, o2)-&gt;o1-o2)</li>
<li>copyOf(array, Length)</li>
<li>binarySearch(array, value)</li>
<li>fill(array, value)</li>
</ul>
<p>比较器 集合排序工具</p>
<ul>
<li>Comparator 类级别
<ul>
<li>针对不同的比较，单独定义一个比较类</li>
<li>int compare(T o1, T o2);
<ul>
<li>返回值为正数，交换 o1 o2 的顺序</li>
<li>返回值为负数或零，不需要调整</li>
<li>返回升序 o1-o2，降序 o2-o1</li>
</ul></li>
</ul></li>
<li>Comparable 方法级别
<ul>
<li>若一个类实现了Comparable接口，就意味着“该类支持排序”，可以用Arrays.sort()排序</li>
<li>public int compareTo(T o);</li>
</ul></li>
</ul>
<h2 id="接口实现">接口实现</h2>
<p>接口和抽象类的关系</p>
<ul>
<li>共同点
<ul>
<li>都不能被实例化</li>
<li>都可以包含抽象方法</li>
<li>方法可以有<a
href="https://liushiming.cn/article/java-default-methods.html">默认实现</a>的</li>
</ul></li>
<li>区别
<ul>
<li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是从属关系。</li>
<li>一个类只能继承一个类，但是可以实现多个接口。</li>
<li>接口中的成员变量只能是 public static final
类型的，不能被修改且必须有初始值，而抽象类的成员变量默认
default，可在子类中被重新定义，也可被重新赋值。</li>
</ul></li>
<li>接口中的所有成员变量都默认是由public static final修饰的</li>
<li>接口中的所有方法都默认是由public abstract修饰的</li>
<li>接口没有构造方法</li>
<li>实现接口的类中必须提供接口中所有方法的具体实现内容</li>
<li>多个无关的类可以实现同一个接口</li>
<li>一个类可以实现多个无关的接口</li>
<li>与继承关系类似，接口与实现类之间存在多态性</li>
<li>接口可以继承多个接口，使用extends关键字</li>
<li>Java8
后，接口可以拥有普通方法，实现类不需要重写，可以被实现类继承</li>
</ul>
<h2 id="构造器">构造器</h2>
<p>this(参数列表)来访问本类构造器需要注意以下几点</p>
<ul>
<li>只能在构造器中使用
this(参数列表)；即在一个构造器中访问本类的另外一个构造器。</li>
<li>显示使用 this() 时，默认的 super() 就被覆盖</li>
<li>this(参数列表)和 super(参数列表)在构造器中有且只能存在一个。</li>
<li>若在构造器中使用 this(参数列表)，则此语句只能位于构造器第一行</li>
</ul>
<h2 id="动态加载">动态加载</h2>
<p>反射（运行时获取类的信息、创建对象、调用方法）</p>
<p>类加载器 ClassLoader</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 常用数据结构的底层实现</title>
    <url>/-developer/Java-DataStructure/</url>
    <content><![CDATA[<h1 id="arraylist">ArrayList</h1>
<p><code>ArrayList</code> 的底层是数组队列，相当于动态数组。</p>
<ul>
<li>与数组相比，它的容量能动态增长。</li>
<li>与 Vector 相比，它的底层使用 Object[]
存储，适用于频繁的查找工作，线程不安全</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, E)</span>;</span><br><span class="line">    E <span class="title function_">set</span><span class="params">(<span class="type">int</span>, E)</span>;</span><br><span class="line">    E <span class="title function_">get</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">    E <span class="title function_">remove</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>List</code> :
表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。</li>
<li><code>RandomAccess</code> ：这是一个标志接口，表明实现这个接口的
<code>List</code> 集合是支持 <strong>快速随机访问</strong>
,可以通过元素的序号快速获取元素对象<code>list.get(i)</code>。</li>
<li><code>Cloneable</code>
：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。</li>
<li><code>Serializable</code> :
表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便。</li>
</ul>
<h2 id="扩容机制">扩容机制</h2>
<p>初始化时默认空数组
<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>。</p>
<p>添加元素时，先判断需要扩容的最小扩容量大小（DEFAULT_CAPACITY 默认是
10）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要扩容，就会进入扩容方法 grow()，扩容效果是小于等于 1.5
倍的（因为 int 取整）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果扩容长度超过定义的数组的最大长度
<code>MAX_ARRAY_SIZE = Integer.MAX_VALUE-8</code>，就会触发最大值限制，防止
size 溢出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将旧数组移动到新数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] copyOf(<span class="type">int</span>[] original, <span class="type">int</span> newLength) &#123;</span><br><span class="line">    <span class="type">int</span>[] copy = <span class="keyword">new</span> <span class="title class_">int</span>[newLength];</span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>, Math.min(original.length, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>手动扩容</strong>，可以在需要插入大量数据前手动扩容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minExpand</span> <span class="operator">=</span> (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) ? <span class="number">0</span> : DEFAULT_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="与-linkedlist-的异同">与 LinkedList 的异同</h2>
<ul>
<li><p>都不保证线程安全；</p></li>
<li><p><code>ArrayList</code> 底层使用的是 <code>Object[]</code>
<strong>数组</strong>；<code>LinkedList</code> 底层使用的是
<strong>Node+双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7
取消了循环）</p></li>
<li><p><strong>插入和删除是否受元素位置的影响：</strong></p></li>
<li><ul>
<li><code>ArrayList</code>
将指定的元素<strong>追加到此列表的末尾</strong>，时间复杂度
<strong>O(1)</strong>。但是如果要在<strong>指定位置 i
插入和删除元素</strong>的话（<code>add(int index, E element)</code>），时间复杂度
<strong>O(n)</strong>。</li>
<li><code>LinkedList</code>
<strong>头尾插入或者删除</strong>元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code>、
<code>removeLast()</code>），时间复杂度
<strong>O(1)</strong>；<strong>指定位置 <code>i</code>
插入和删除元素</strong>的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>,<code>remove(int index)</code>），
时间复杂度为 <strong>O(n)</strong> 。</li>
</ul></li>
<li><p><strong>是否支持快速随机访问：</strong> <code>LinkedList</code>
不支持高效的随机元素访问，而 <code>ArrayList</code>（实现了
<code>RandomAccess</code> 接口） 支持。</p></li>
<li><p><strong>内存空间占用：</strong> <code>ArrayList</code>
的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而
LinkedList 的空间花费则体现在它的每一个元素 Node 都需要消耗比 ArrayList
更多的空间</p></li>
</ul>
<h1 id="linkedlist">LinkedList</h1>
<blockquote>
<p>需要用到 <code>LinkedList</code> 的场景几乎都可以使用
<code>ArrayList</code>
来代替，而且性能会更好。头尾插入或者删除元素的时候时间复杂度近似
O(1)，其他情况增删元素的平均时间复杂度都是 O(n) 。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt; </span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.item = element;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">            <span class="built_in">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>List</code> :
表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。</li>
<li><code>Deque</code> ：继承自 <code>Queue</code>
接口，具有双端队列的特性，支持从两端插入和删除元素，方便实现栈和队列等数据结构。</li>
</ul>
<h2 id="常用方法">常用方法</h2>
<ul>
<li>实现 List 接口
<ul>
<li>get、set</li>
</ul></li>
<li>实现 Collection 接口
<ul>
<li>判断是否存在：contains</li>
</ul></li>
<li>实现 Queue 接口（通过 Deque 接口）
<ul>
<li>报错：add、remove、element</li>
<li>不报错：offer、poll、peek</li>
</ul></li>
<li>实现 Deque 接口
<ul>
<li>addFirst [push]、addLast [add]：无返回，容量超出限制会报错</li>
<li>offerFirst、offerLast [offer]：返回 Boolean 表示是否加入成功</li>
<li>removeFirst [remove]、removeLast：队列为空报错</li>
<li>pollFirst [poll]、pollLast：队列为空返回 null</li>
<li>getFirst [element]、getLast：队列为空报错</li>
<li>peekFirst [peek]、peekLast：队列为空返回 null
<ul>
<li>【注意】队列头部为 null 和队列为空时，都会返回 null</li>
</ul></li>
<li>removeFirstOccurrence [remove]、removeLastOccurrence</li>
<li>push、pop、peek：作为栈</li>
</ul></li>
</ul>
<h1 id="hashmap">HashMap</h1>
<blockquote>
<p>JDK1.8 之前 HashMap 采用“拉链法”处理冲突，由 数组+链表 组成； JDK1.8
以后，若Table长度大于 64，会将链表转化为红黑树。</p>
</blockquote>
<style>.drjgjkngcwds{zoom:50%;}</style>
<img data-src="/-developer/Java-DataStructure/image-20240425212527868.png" class="drjgjkngcwds" alt="image-20240425212527868">
<ul>
<li>key 和 value 可以为 null，但 null 作为 key 只能有一个，而 null 作为
value 可以有多个</li>
<li>非线程安全的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">    <span class="comment">// 默认的初始容量是16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 默认的负载因子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">// 当桶上的结点数大于等于这个值时会转成红黑树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 当桶上的结点数小于等于这个值时树转链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 桶中结构转化为红黑树对应的 table 的最小容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 存储桶（bin）的数组，永远是 2 的幂次倍</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;k,v&gt;[] table;</span><br><span class="line">    <span class="comment">// 一个包含了映射中所有键值对的集合视图</span></span><br><span class="line">    <span class="comment">// 先遍历数组 bin，再通过 Entry.next 遍历每个 bin</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;</span><br><span class="line">    <span class="comment">// 存放元素的个数，注意这个不等于数组的长度</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// 阈值=容量*负载因子，当实际大小超过阈值时，会进行扩容</span></span><br><span class="line">    <span class="type">int</span> threshold;</span><br><span class="line">    <span class="comment">// 负载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt;&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        <span class="comment">// 链表的下一个元素</span></span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt;&#123;</span><br><span class="line">        Entry&lt;K,V&gt; before, after;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// 红黑树链</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// 需要在下次删除时解除链接</span></span><br><span class="line">        <span class="type">boolean</span> red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>entrySet</code>
通过<code>Node的next属性</code>遍历元素，<code>keySet()</code>、<code>values()</code>基于<code>entrySet</code>实现，用于遍历访问所有
Node
元素，还支持元素的删除操作【不确定，entrySet不存储数据，只是数据对外的操作接口】。</li>
<li><code>TreeNode</code> 继承了 <code>LinkedHashMap.Entry</code>
，有指向前后节点的指针</li>
</ul>
<p>jdk 1.8 <strong>Key 计算 hash 值的方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩容机制-1">扩容机制</h2>
<p><strong>何时触发 <code>resize()</code> 扩容</strong></p>
<ul>
<li>要插入数据前，发现<code>table</code> 中的 <code>bin</code> 为空</li>
<li>要插入数据后，发现<code>HashMap</code>的 <code>size</code> 超过
<code>threshold</code></li>
<li><code>table</code> 长度小于 <code>MIN_TREEIFY_CAPACITY</code>时，某
<code>Node</code> 上的链长度超过 <code>TREEIFY_THRESHOLD</code></li>
</ul>
<p><code>resize()</code> 扩容，会将 table 中的节点数量 &lt;&lt;
1，并重新 hash 映射所有节点（因为 table 变大了，每个节点对应的 bin
下标发生了变化
<code>newTab[e.hash &amp; (newCap - 1)] = e</code>，<code>newCap</code>为
table 的新大小）</p>
<p>链表何时变成红黑树？</p>
<ul>
<li>该 <code>bin</code> 上的链长度<code>binCount</code>大于等于
<code>TREEIFY_THRESHOLD</code> 且 <code>table</code> 中 <code>bin</code>
数量大于等于 <code>MIN_TREEIFY_CAPACITY</code></li>
</ul>
<p>如果链表转红黑树的时候，又有数据要插入，会发生什么？</p>
<ul>
<li>线程不安全。在树结构替换链表最终阶段会校验树结构，在此过程中的插入会使该树结构不满足红黑树和双链表的特性，导致报异常
<code>assert checkInvariants(root);</code></li>
</ul>
<h1 id="concurrenthashmap">ConcurrentHashMap</h1>
<blockquote>
<p>Java7 中 ConcurrentHashMap 使用的是分段锁，每一个 Segment
上同时只有一个线程可以操作，结构上时 <code>Segment</code> <strong>数组
+</strong> <code>HashEntry</code> <strong>数组 +
链表</strong>。<code>Segment</code>
的个数一旦<strong>初始化就不能改变</strong>，默认 <code>Segment</code>
的个数是 16
个，<code>Segment</code>继承<code>ReentrantLock</code>实现分段锁。</p>
<p>Java8 中的 ConcurrentHashMap 通过 <strong>Synchronized 锁加
CAS</strong> 保证多线程安全，结构上是 <code>Node</code>
<strong>数组</strong> + <strong>链表 / 红黑树</strong>。</p>
</blockquote>
<p>如果链表转红黑树，又有数据要插入，会发生什么。</p>
<ul>
<li><code>treeifyBin</code> 通过 <code>synchronized</code> 把
<code>bin</code> 加锁，后续数据插入会因为无法竞争到资源而阻塞</li>
<li>链表开始转红黑树前，会将 Node 头节点置为
<code>ForwardingNode</code>，<code>ForwardingNode</code> 的 hash 是
<code>Moved</code>
表示正在转换为红黑树，此时会自旋等待转换完成后插入（大概是这样的）</li>
</ul>
<p>如果数组扩容，又有数据要插入，会发生什么。</p>
<ul>
<li>扩容前，会将 Node 头节点置为
<code>ForwardingNode</code>，<code>ForwardingNode</code> 的 hash 是
<code>Moved</code> 表示正在扩容。</li>
<li>扩容时，插入数据的线程若发现 hash
值为负，会去协助扩容，扩容完成后再插入数据。</li>
</ul>
<p><a
href="https://blog.csdn.net/ZOKEKAI/article/details/90051567"><strong>什么时候触发扩容？</strong></a></p>
<ul>
<li>在调用 addCount
方法增加集合元素计数后发现当前集合元素个数到达扩容阈值时就会触发扩容</li>
<li>扩容状态下其他线程对集合进行插入、修改、删除、合并、compute
等操作时遇到 <code>ForwardingNode</code> 节点会触发扩容（帮助扩容）</li>
<li>putAll 批量插入或者插入节点后发现存在链表长度达到 8
个或以上，但数组长度为 64 以下时会触发扩容 。</li>
</ul>
<p>同 HashMap：桶上链表长度达到 8 个或者以上，并且数组长度为 64
以下时只会触发扩容而不会将链表转为红黑树</p>
<h1 id="linkedhashmap">LinkedHashMap</h1>
<p><code>LinkedHashMap</code>
内部维护了一个双向链表，确保其迭代顺序是和插入顺序或访问顺序是一致的，通过重写
get、newNode、afterNodeAccess、afterNodeInsertion、afterNodeRemoval
等方法实现，最近插入或访问的节点位于链表尾部。</p>
<blockquote>
<p>可以按照插入顺序遍历 entry（accessOrder=false）</p>
<p>也可以按照访问顺序遍历 entry（accessOrder=true），即 LRU</p>
</blockquote>
<p>可用于实现 LRU，即 迭代顺序==访问顺序</p>
<ul>
<li>每次修改都将元素删除后重新插入</li>
<li>将 <code>accessOrder</code> 设置为 true 并重写
<code>removeEldestEntry</code> 方法当链表大小超过容量时返回 true</li>
</ul>
<h1 id="copyonwritelist">CopyOnWriteList</h1>
<blockquote>
<p>并发安全的
<code>List</code>，针对读多写少的场景，类比读写锁的思想，实现
<strong>读读不互斥、读写不互斥、写写互斥</strong> 的写时复制
Copy-On-Write 策略。此外还有 <code>Collections.synchronizedList</code>
，可以将任何<code>List</code>包装成一个线程安全的<code>List</code></p>
</blockquote>
<p>add 方法内部用到了 ReentrantLock
加锁，避免了多线程写的时候会复制出多个副本，导致并发问题</p>
<p><strong>写时复制的缺点</strong></p>
<ul>
<li>写操作资源占用多，复制数据时占用内存</li>
<li>数据一致性问题，修改后需要等到赋值给原数组才能访问到修改</li>
</ul>
<p><strong>写多读少的场景下，应该用什么数据结构实现并发数组？</strong></p>
<p>分段读写锁 ReadWriteLock（由于 Arrays.copyOf()
是操作系统实现，数据量少的话依然可用写时复制）</p>
<h1 id="priorityqueue">PriorityQueue</h1>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/-developer/MySQL/</url>
    <content><![CDATA[<h1 id="基础">基础</h1>
<h2 id="sql-查询语句执行过程">SQL 查询语句执行过程</h2>
<ul>
<li>连接器：客户端与 Server 层建立连接，管理连接、校验用户身份；</li>
<li>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行（MySQL
8.0 已删除该模块）</li>
<li>解析 SQL：通过解析器对 SQL
查询语句进行<strong>词法分析</strong>、<strong>语法分析</strong>，然后<strong>构建语法树</strong>，方便后续模块读取表名、字段、语句类型；</li>
<li>执行 SQL：
<ul>
<li>预处理阶段：检查表或字段是否存在；将 select * 中的 *
符号扩展为表上的所有列；</li>
<li>优化阶段：基于查询成本的考虑，
选择查询成本最小的执行计划；查询优化器；</li>
<li>执行阶段：根据执行计划执行 SQL
查询语句，从存储引擎读取记录，返回给客户端；</li>
</ul></li>
</ul>
<h2 id="mysql-数据文件">MySQL 数据文件</h2>
<ul>
<li>db.opt，用来存储当前数据库的默认字符集和字符校验规则。</li>
<li>table.frm ，存放<strong>表结构</strong>，在 MySQL
中建立一张表都会生成一个.frm
文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。</li>
<li>table.ibd，存放<strong>表数据</strong>，<del>表数据既可以存在共享表空间文件（文件名：ibdata1）里</del>，也可以存放在独占表空间文件（文件名：表名字.ibd）。这个行为是由参数
innodb_file_per_table 控制的，若设置了参数 innodb_file_per_table 为
1，则会将存储的<strong>数据、索引等信息单独存储在一个独占表空间</strong>，从
MySQL 5.6.6 版本开始，它的默认值就是 1 了，因此从这个版本之后， MySQL
中每一张表的数据都存放在一个独立的 .ibd 文件。</li>
</ul>
<p><strong>表空间文件的结构</strong></p>
<style>.ramievbhdian{zoom:67%;}</style>
<img data-src="/-developer/MySQL/%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84.drawio.png" class="ramievbhdian" alt="img">
<h2 id="innodb-行格式">InnoDB 行格式</h2>
<p>共有 Redundant、Compact、Dynamic、Compressed 四种，下图时 Compact
行格式的结构</p>
<img data-src="/-developer/MySQL/COMPACT.drawio.png" class="" title="img">
<h2 id="innodb-页格式">InnoDB 页格式</h2>
<p>InnoDB 的数据是按「数据页」为单位来读写的，数据页的默认大小是
16KB</p>
<style>.ychwwmczolth{zoom:50%;}</style>
<img data-src="/-developer/MySQL/243b1466779a9e107ae3ef0155604a17-17146246150216.webp" class="ychwwmczolth" alt="243b1466779a9e107ae3ef0155604a17">
<table>
<thead>
<tr class="header">
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>文件头</td>
<td>页的信息；两个指针指向<u>上一个/下一个数据页</u></td>
</tr>
<tr class="even">
<td>页头</td>
<td>页的状态信息</td>
</tr>
<tr class="odd">
<td>最小和最大记录</td>
<td>两个虚拟伪记录，分别表示页中的最小记录和最大记录</td>
</tr>
<tr class="even">
<td><u>用户记录</u></td>
<td>储存所有的行记录</td>
</tr>
<tr class="odd">
<td>空闲空间</td>
<td>还没被用到的空间</td>
</tr>
<tr class="even">
<td><u>页目录</u></td>
<td>用户记录相对位置，页中所有记录的索引</td>
</tr>
<tr class="odd">
<td>文件尾</td>
<td>校验页是否完整</td>
</tr>
</tbody>
</table>
<p>数据页中的
页目录存储各个槽，用户记录按照「主键」顺序组成单向链表，可以通过二分查找法的方式进行检索。</p>
<h1 id="索引">索引</h1>
<p>索引字段特性分类</p>
<ul>
<li>主键索引</li>
<li>唯一索引</li>
<li>前缀索引</li>
<li>普通索引</li>
</ul>
<p>索引个数分类</p>
<ul>
<li>单例索引</li>
<li>联合索引：最左匹配原则（MySQL 有查询优化器，所以字段在 where
子句的顺序并不重要）</li>
</ul>
<blockquote>
<p>最左匹配原则：按照最左优先的方式进行索引的匹配，范围查询的字段可以用到联合索引，在遇到范围查询（如
&gt;、&lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于
&gt;=、&lt;=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配。</p>
</blockquote>
<h2 id="innodb-采用-btree-作为索引的优势">Innodb 采用 B+Tree
作为索引的优势</h2>
<blockquote>
<p>MySQL 底层实现的 B+ 树在原有的 B+ 树的基础上做了改动</p>
<ul>
<li>叶子节点采用双向链表连接</li>
<li>所有节点都是 16KB 数据页</li>
<li>非叶子节点中有多少个子节点，就有多少个索引</li>
</ul>
<p>nosql 的 MongoDB 采用 B
树实现，适用于大量的单个索引（而不是范围查询）查询的场景；</p>
</blockquote>
<ul>
<li><strong>查询底层节点的磁盘
I/O次数少</strong>。非叶子节点只存放索引，相比 B
树，每个非叶子节点能存储更多的索引，树形结构更加矮胖；</li>
<li><strong>插入和删除效率高</strong>。非叶子节点中的都是冗余索引，所有索引都在叶子节点中又存储了一次；</li>
<li><strong>树层低，磁盘 I/O 次数少</strong>。若每行数据
1KB，三层最多可存放千万级数据量；</li>
<li><strong>范围查询，磁盘 I/O
次数少</strong>。叶子节点采用双向有序链表连接；其他树结构需要中序遍历，磁盘
I/O 次数多；</li>
</ul>
<p>B+Tree 索引结构</p>
<ul>
<li>主键索引/聚簇索引：叶子节点存放实际数据、事务 id、用于事务和 MVCC
的回滚指针；</li>
<li>二级索引：叶子节点存放主键值；</li>
</ul>
<h2 id="explain-执行计划">Explain 执行计划</h2>
<p>数据扫描类型 type</p>
<ul>
<li>All：全表扫描；</li>
<li>index：全索引扫描；</li>
<li>index merge：索引合并。先将使用到的索引先进行求
交集、并集之后在进行回表；</li>
<li>range：索引范围扫描。使用 &lt; 、&gt;、in、between
等关键词，只检索给定范围的行；</li>
<li>ref：非唯一索引等值匹配；</li>
<li>eq_ref：唯一索引 多表联查 等值匹配；</li>
<li>const：主键或唯一索引 常量 等值匹配；</li>
</ul>
<p>额外信息 extra</p>
<ul>
<li>Using filesort ：当查询语句中包含 group by
操作，而且无法利用索引完成排序操作的时候，
这时不得不选择相应的排序算法进行；</li>
<li>Using temporary：使了用临时表保存中间结果，如排序 order by
和分组查询 group by；</li>
<li>Using where：存储引擎层返回行以后在 MySQL 服务层应用 where
过滤条件；</li>
<li>Using
index：所需数据可以直接在二级索引值和主键值中得到，采用覆盖索引，不回表；</li>
<li>Using index condition 索引下推
：可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数；</li>
</ul>
<h2 id="是否需要索引">是否需要索引</h2>
<p>需要索引的情况</p>
<ul>
<li>唯一性字段</li>
<li>范围查询 <code>WHERE</code></li>
<li>排序查询 <code>GROUP BY</code> 、 <code>ORDER BY</code></li>
<li>覆盖索引，全索引扫描优于全表扫描</li>
</ul>
<p>不需要索引的情况</p>
<ul>
<li>不需要范围查询、排序查询</li>
<li>大量重复数据</li>
<li>频繁修改</li>
<li>数据量少</li>
</ul>
<h2 id="索引优化">索引优化</h2>
<p><strong>前缀索引</strong>：减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。</p>
<p><strong>覆盖索引</strong>：联合索引和主键值中包括了查询数据，避免回表</p>
<p><strong>主键索引自增</strong>：追加记录时不需要移动数据；避免页分裂造成内存碎片；</p>
<p><strong>主键字段长度尽可能短</strong>：聚簇索引非叶子节点可以装下更多的索引；二级索引叶子节点可以装下更多的主键值，占用空间更小</p>
<p><strong>索引 NOT NULL</strong>：简化索引统计、值比较过程；减少 1
字节的行格式长度；</p>
<p><strong>联合索引
区分度大的在前</strong>：建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的
SQL 使用到。</p>
<blockquote>
<p>如果索引的区分度很小，假设字段的值分布均匀，那么无论搜索哪个值都可能得到一半的数据（惯用的百分比界线是"30%"）MySQL
查询优化器，会忽略索引，进行全表扫描</p>
</blockquote>
<h2 id="索引失效">索引失效</h2>
<ul>
<li>左或者左右模糊匹配</li>
<li>查询条件中对索引列做了
<ul>
<li>计算</li>
<li>函数</li>
<li>类型转换操作</li>
</ul></li>
<li>联合索引未遵循最左匹配原则</li>
<li>条件语句中 OR 前后子句一个有索引一个没索引</li>
</ul>
<p><strong>Count 计算</strong></p>
<p>遍历索引，优先遍历 key_len
最小的二级索引，只有当没有二级索引的时候，才会采用主键索引来进行统计。</p>
<h1 id="事务">事务</h1>
<p>事务是由存储引擎实现的，InnoDB 支持事务</p>
<h2 id="特性">特性</h2>
<ul>
<li>持久性是通过 redo log （重做日志）保证的；</li>
<li>原子性是通过 undo log（回滚日志） 保证的；</li>
<li>隔离性是通过 MVCC（多版本并发控制） 或锁机制保证的；</li>
<li>一致性则是通过持久性+原子性+隔离性保证的；</li>
</ul>
<p><strong>并行事务会引发的问题</strong></p>
<ul>
<li>脏读：一个事务读到了另一个<u>未提交事务修改过的数据</u></li>
<li>不可重复读：一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样</li>
<li>幻读：一个事务内多次查询某个查询条件的记录数量不同</li>
</ul>
<h2 id="隔离级别">隔离级别</h2>
<table>
<thead>
<tr class="header">
<th>隔离级别（是否会出现xx问题）</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>READ-UNCOMMITTED 读未提交</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr class="even">
<td>READ-COMMITTED 读已提交</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr class="odd">
<td>REPEATABLE-READ 可重复读</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr class="even">
<td>SERIALIZABLE 可串行化</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody>
</table>
<ul>
<li>读未提交：允许读取尚未提交的数据变更。直接读取最新的数据</li>
<li>读已提交：允许读取并发事务已经提交的数据。<strong>「每个 SQL
语句执行前」都会重新生成一个 Read View</strong></li>
<li>可重复读：对同一字段的多次读取结果都是一致的。<strong>「启动事务时」生成一个
Read View，然后整个事务期间都在用这个 Read View</strong></li>
<li>可串行化：所有的事务依次逐个执行，完全服从 ACID
的隔离级别。采用加读写锁的方式来避免并行访问</li>
</ul>
<p>虽然 InnoDB 默认采用可重复读隔离级别，但基本不会出现幻读，因为其采用
next-key lock（记录锁+间隙锁）和 MVCC 来避免幻读的发生</p>
<ul>
<li><strong>快照读</strong>（select）：采用 MVCC
方式解决了幻读。事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，保证事务隔离性；
<ul>
<li>在执行第一个查询语句后，会创建一个 Read View，后续的查询语句利用这个
Read View，通过这个 Read View 就可以在 undo log
版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的</li>
</ul></li>
<li><strong>当前读/共享锁</strong>（select for update）：通过 next-key
lock（记录锁+间隙锁）方式解决了幻读，读到的记录是最新的。如果有其他事务在
Next-Key Lock
范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入；
<ul>
<li>update、insert、delete
都是当前读，这些语句执行前都会<strong>查询最新版本的数据</strong>，然后再做进一步的操作；</li>
<li>如果 update
是已经被锁住的记录，就生成插入意向锁并进入阻塞状态；</li>
<li>当前读给某记录加锁了，那么对该记录已修改但未提交的事物就无法提交这个修改了，直到锁被释放；</li>
<li>Next-Key Lock 对索引记录加上行锁（Record
Lock），对索引记录两边的间隙加上<strong>间隙锁（Gap
Lock）</strong>，是针对事务隔离级别为可重复读或以上级别而设计的；</li>
</ul></li>
</ul>
<h2 id="mvcc-多版本并发控制">MVCC 多版本并发控制</h2>
<p>InnoDB 事务是通过 <strong>Read View 和
聚簇索引中的两个隐藏列</strong> 实现 MVCC 的</p>
<p><strong>Read View 字段</strong></p>
<img data-src="/-developer/MySQL/readview%E7%BB%93%E6%9E%84.drawio.png" class="" title="img">
<p><strong>聚簇索引中的两个隐藏列</strong></p>
<ul>
<li>trx_id，当一个事务对某条聚簇索引记录进行改动时，就会<strong>把该事务的事务
id 记录在 trx_id 隐藏列里</strong>；</li>
<li>roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到
undo
日志中，然后<strong>这个隐藏列是个指针，指向每一个旧版本记录</strong>，于是就可以通过它找到修改前的记录。</li>
</ul>
<p><strong>MVCC 如何实现可重复读？</strong></p>
<p>事务 A 读某字段时，会先读取该字段的 trx_id，如果 Read View 中记录的该
trx_id 是<strong>活跃事务</strong>，则沿着 roll_pointer（即 <strong>undo
log 版本链</strong>）寻找旧版本字段；如果 Read View 中记录的该 trx_id
是<strong>当前事务</strong> 或
<strong>已提交事务</strong>，则返回该记录。【注意，Read View
字段不随活跃事务的提交而改变，它是该事务开启时的数据库事务状态快照】</p>
<h2 id="可重复读下发生幻读">可重复读下发生幻读</h2>
<ol type="1">
<li>事务 A 先对某块记录执行快照读</li>
<li>事务 B 插入数据到该块记录中，并提交事务 B</li>
<li>事务 A 再对该块记录执行当前读或更新记录</li>
<li>会读取到事务 B 插入的数据，因为当前读会读取最新的记录</li>
</ol>
<p><strong>如何避免？</strong></p>
<p>若事务中会对数据采取 当前读，则在事务刚开始时就执行，通过 next-key
lock 避免其他事物再插入数据。</p>
<h1 id="锁">锁</h1>
<blockquote>
<p>MySQL 加锁时，先 生成锁结构，然后
设置锁的状态，即初始化锁再竞争锁；如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁；</p>
</blockquote>
<p><strong>锁的种类</strong></p>
<ul>
<li>全局锁</li>
<li>表级锁
<ul>
<li>表锁</li>
<li>意向表：用于<strong>快速判断表里是否有记录被加锁</strong>。意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（lock
tables ... read）和独占表锁（lock tables ... write）发生冲突</li>
<li>元数据表 MDL 锁：更表结构时需要申请 MDL 写锁</li>
<li>AUTO-INC 锁：配置文件
<code>innodb_autoinc_lock_mode = 2, binlog_format = row</code>，既能提升并发性，又不会出现数据一致性问题</li>
</ul></li>
<li>行级锁
<ul>
<li>Record Lock 记录锁，区分读锁和写锁，锁定存在的记录；</li>
<li>Gap Lock
间隙锁，不区分读锁和写锁；间隙锁用来锁一个范围，间隙锁之间是兼容的；</li>
<li>Next-Key Lock 临键锁，区分读锁和写锁；</li>
<li>插入意向锁，特殊的间隙锁，<strong>用于不同事务的并发控制和冲突检测</strong>；插入意向锁和不同事物的间隙锁之间是冲突的，当某个事务的插入语句遇到间隙锁时，会产生插入意向锁；</li>
</ul></li>
<li>隐式锁
<ul>
<li>延迟加锁机制，特点是只有在可能发生冲突时才加锁</li>
<li>使用场景：事务 B 插入记录的索引 == 事务 A 已插入且未提交的索引，事务
A 插入的记录上的「隐式锁」会变「显示锁」且锁类型为 X
型的记录锁，所以事务 B 想获取 <del>S 型</del>next-key
锁时会遇到锁冲突，事务 B 进入阻塞状态。</li>
</ul></li>
</ul>
<h2 id="行级锁实现">行级锁实现</h2>
<blockquote>
<p>行级锁时 Innodb 实现高效事务的关键</p>
</blockquote>
<p>加锁是加在索引上的【加行级锁时还要加表锁：X 类型的意向锁】</p>
<ul>
<li>全表当前读，<strong>遍历</strong>聚簇索引加临键锁（update
未走索引的情况）</li>
<li>全索引当前读，<strong>遍历</strong>当前索引加临键锁</li>
</ul>
<p><strong>二级索引加锁后，还要在查询到的记录的主键索引项加记录锁</strong></p>
<p><strong>Insert 语句，加行级锁</strong></p>
<ul>
<li>记录被间隙锁，阻塞
<ul>
<li>插入意向锁</li>
</ul></li>
<li>唯一键冲突，执行失败
<ul>
<li>如果主键索引重复，插入新记录的事务会给已存在的主键值重复的聚簇索引记录<strong>添加
S 型记录锁</strong>。</li>
<li>如果唯一二级索引重复，插入新记录的事务都会给已存在的二级索引列值重复的二级索引记录<strong>添加
S 型 next-key 锁</strong>。</li>
</ul></li>
</ul>
<h3
id="临键锁退化成记录锁或间隙锁的情况">临键锁退化成记录锁或间隙锁的情况</h3>
<p>唯一索引查询</p>
<ul>
<li>等值查询
<ul>
<li>（条件值）存在，<strong>该索引加记录锁</strong></li>
<li>（条件值）不存在，<strong>后一索引加间隙锁</strong></li>
</ul></li>
<li>范围查询
<ul>
<li>条件值在表中，非等值查询
<ul>
<li>小于，<strong>该索引加间隙锁</strong></li>
<li>大于，<strong>后一索引加临键锁</strong></li>
</ul></li>
<li>条件值在表中且条件是等值查询
<ul>
<li>小于等于，<strong>该索引加临键锁</strong></li>
<li>大于等于，<strong>该索引加记录锁</strong></li>
</ul></li>
</ul></li>
</ul>
<p>非唯一索引查询</p>
<ul>
<li>等值查询
<ul>
<li>存在，扫描到的索引记录加的是 next-key
锁，而对于第一个不符合条件的索引记录，该索引的 next-key
锁会退化成间隙锁；</li>
<li>不存在，扫描到第一条不符合条件的索引记录，该索引的 next-key
锁会退化成间隙锁；</li>
</ul></li>
<li>范围查询
<ul>
<li>为确保条件值前后都锁住，加锁时不存在临建锁退化为间隙锁和记录锁的情况</li>
</ul></li>
</ul>
<h2 id="死锁">死锁</h2>
<ul>
<li>两个事务分别加了间隙锁（前提）</li>
<li>两个事务分别向对方的间隙锁插入数据，于是都产生插入意向锁</li>
<li>由于插入意向锁和间隙锁冲突，双方都为了获取插入意向锁，会等待对方事务的间隙锁释放，陷入循环等待，造成死锁</li>
</ul>
<p>插入意向锁是对不同事务才产生作用的，对于本身事务的间隙锁是兼容的。</p>
<p>解决方法</p>
<ul>
<li>设置事务等待锁的超时时间 <code>innodb_lock_wait_timeout</code></li>
<li>开启主动死锁检测 <code>innodb_deadlock_detect</code></li>
</ul>
<h1 id="日志">日志</h1>
<blockquote>
<p>目前，很多数据库采用的是 steal（没提交的事务写的脏页也可以马上落盘）+
no force（已提交的事务可以不马上落盘）模式。MySQL 也参考了这个模式，undo
log 变更持久性和数据一样，由 redo log 保证，对 undo log
还没落盘的修改也会写入 redo log。这样不管怎么样基于 undo log
做事务回滚或者做 MVCC都可以保证原子和一致性。</p>
</blockquote>
<ul>
<li>undo log（回滚日志）：是 Innodb
存储引擎层生成的日志，实现了事务中的原子性，主要用于<strong>事务回滚和
MVCC</strong>；</li>
<li>redo log（重做日志）：是 Innodb
存储引擎层生成的日志，实现了事务中的持久性，主要用于<strong>掉电等故障恢复</strong>；</li>
<li>bin log （归档日志）：是 Server
层生成的日志，主要用于<strong>数据备份和主从复制</strong>；</li>
</ul>
<p>回滚日志与重做日志的区别</p>
<ul>
<li>redo log
记录了此次事务「完成后」的数据状态，记录的是更新之后的值；防止已提交事务的修改丢失；</li>
<li>undo log
记录了此次事务「开始前」的数据状态，记录的是更新之前的值；防止未提交事务的修改无法回滚；</li>
</ul>
<p>重做日志和归档日志的区别</p>
<ul>
<li>bin log
是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。</li>
<li>redo log
是循环写，日志空间大小是固定，全部写满就从头开始，保存未被刷入磁盘的脏页日志。</li>
</ul>
<h2 id="回滚日志-undo-log">回滚日志 Undo log</h2>
<ul>
<li><strong>实现事务回滚，保障事务的原子性</strong>。事务处理过程中，如果出现了错误
或者 用户执行了 ROLLBACK 语句，MySQL 可以利用 undo log
中的历史数据将数据恢复到事务开始之前的状态。</li>
<li>实现 MVCC（多版本并发控制）关键因素之一。MVCC 是通过 Read View +
undo log 实现的。<strong>undo log
为每条记录保存多份历史数据</strong>，MySQL 在执行快照读（普通 select
语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log
的版本链找到满足其可见性的记录。</li>
</ul>
<p>持久化方法：开启事务后，InnoDB 层更新记录前，首先要记录相应的 undo
log，如果是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo
log，undo log 会写入 Buffer Pool 中的 Undo 页面，对 undo
页的修改也都会记录到 redo log。redo log
会每秒刷盘，提交事务时也会刷盘，数据页和 undo
页都是靠这个机制保证持久化的。</p>
<h2 id="重做日志-redo-log">重做日志 Redo log</h2>
<blockquote>
<p>防止 Buffer Pool 中的脏页丢失</p>
</blockquote>
<ul>
<li>实现<strong>事务的持久性</strong>，让 MySQL 有
<strong>crash-safe</strong> 的能力，能够保证 MySQL
在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；</li>
<li>将<strong>脏页的写操作</strong>从「随机写」变成了「顺序写」，提升
MySQL 写入磁盘的性能；</li>
</ul>
<p>WAL（Write-Ahead Logging）：MySQL
的写操作并不是立刻写到磁盘上，而是先写 redo log
日志，然后在合适的时间再将脏页写到磁盘上。</p>
<p>redo log
是<strong>物理日志</strong>，记录了某个数据页做了什么修改，即所有未还没持久化的脏页修改。在事务提交时，只要<strong>先将
redo log 持久化到磁盘即可</strong>，可以不需要等到将缓存在 Buffer Pool
里的脏页数据持久化到磁盘。当系统崩溃时，虽然脏页数据没有持久化，但是
redo log 已经持久化，接着 MySQL 重启后，可以根据 redo log
的内容，将所有数据恢复到最新的状态。</p>
<p><strong>redo log 持久化操作</strong>：每当产生一条 redo log
时，会先写入到 redo log buffer，为了在 MySQL
处理大事务时尽可能少写入磁盘，进而提升写 IO 性能。<strong>redo log
buffer 写入磁盘的时机</strong>：</p>
<ul>
<li>MySQL 正常关闭时；</li>
<li>当 redo log buffer 中记录的写入量大于 redo log buffer
<strong>内存空间</strong>的一半时；</li>
<li>InnoDB 的<strong>后台线程</strong>每隔 1 秒，将 redo log buffer
持久化到磁盘。</li>
<li>每次<strong>事务提交</strong>时都将缓存在 redo log buffer 里的 redo
log 直接持久化到磁盘；
<ul>
<li>参数为 0 时，事务提交不会主动触发写入磁盘的操作；<strong>MySQL
进程崩溃</strong>会导致上一秒钟所有事务数据的丢失；</li>
<li>参数为 1 时，每次事务提交都将缓存在 redo log buffer 里的 redo log
直接持久化到磁盘；</li>
<li>参数为 2 时，每次事务提交都只是缓存在 redo log buffer 里的 redo log
写到 redo log 文件（写入到 redo log
文件并不意味着写入到了磁盘，而是存在操作系统里的文件系统中的 Page
Cache）；<strong>操作系统崩溃或者系统断电</strong>会导致上一秒钟所有事务数据的丢失；</li>
</ul></li>
</ul>
<h3 id="重做日志文件组">重做日志文件组</h3>
<p>redo log 是为了防止 Buffer Pool
中的脏页丢失而设计的，<strong>只记录未被刷入磁盘的数据的物理日志</strong>。随着系统运行，Buffer
Pool 的脏页刷新到了磁盘中，redo log
对应的记录也就没用了，这时候我们需要擦除这些旧记录，以腾出空间记录新的更新操作。重做日志文件组由有
2 个 redo log
文件组成，以循环写的方式工作，从头开始写，写到末尾就又回到开头，相当于一个环形。</p>
<style>.xplhnauyqube{zoom: 50%;}</style>
<img data-src="/-developer/MySQL/checkpoint.png" class="xplhnauyqube" alt="img">
<ul>
<li>write pos ～ checkpoint
之间的部分（图中红色部分）：记录新的更新操作；</li>
<li>check point ～ write pos
之间的部分（图中蓝色部分）：待落盘的脏数据页记录；</li>
</ul>
<p>将 Buffer Pool 中的脏页刷新到磁盘中，然后标记 redo log
哪些记录可以被擦除，接着对旧的 redo log
记录进行擦除，等擦除完旧记录腾出了空间，checkpoint
就会往后移动（图中顺时针）。一次 checkpoint
的过程就是脏页刷新到磁盘中变成干净页，然后标记 redo log
哪些记录可以被覆盖的过程。</p>
<h2 id="归档日志-bin-log">归档日志 Bin log</h2>
<p>记录 MySQL 上的所有变化并以二进制形式保存在磁盘上。MySQL
在完成<strong>数据库表结构变更或表数据修改</strong>（增删改）时，Server
层会生成一条
binlog，等之后事务提交的时候，会将该事物执行过程中产生的所有 binlog
统一写入 binlog 文件。</p>
<ul>
<li>binlog 日志只能用于数据备份和主从复制，没有 crash-safe 的能力；</li>
<li>binlog
是全量日志，保存了所有数据变更的情况，可以恢复整个数据库所有数据；</li>
</ul>
<h3 id="主从复制">主从复制</h3>
<style>.ctoivxfjkhxo{zoom:67%;}</style>
<img data-src="/-developer/MySQL/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B.drawio.png" class="ctoivxfjkhxo" alt="MySQL 主从复制过程">
<ul>
<li>写入 Binlog：数据修改 -&gt; 主库写 binlog 日志 -&gt; commit 事务
-&gt; 持久化本地数据 -&gt; 提交事务成功；</li>
<li>同步 Binlog：从库会创建一个专门的 I/O 线程，连接主库的 log dump
线程，来接收主库的 binlog 日志，再把 binlog 信息写入 relay log
的中继日志里，再返回给主库“复制成功”的响应。</li>
<li>回放 Binlog：读 relay log 中继日志，回放
binlog，并更新从库中的数据。</li>
</ul>
<p>主从复制模型</p>
<ul>
<li>同步复制：MySQL
主库提交事务的线程要等待所有从库的复制成功响应，才返回客户端结果；</li>
<li>异步复制（默认模型）：MySQL 主库提交事务的线程并不会等待 binlog
同步到各从库，就返回客户端结果；</li>
<li>半同步复制：只要数据成功复制到任意一个从库上，主库的事务线程就可以返回给客户端；</li>
</ul>
<h3 id="binlog-刷盘">binlog 刷盘</h3>
<style>.bjisgudbtfjw{zoom: 67%;}</style>
<img data-src="/-developer/MySQL/binlogcache.drawio.png" class="bjisgudbtfjw" alt="binlog cach">
<ul>
<li>图中的 write，把<strong>日志写入到 binlog 文件（文件系统的 page
cache 里）</strong>，但是并没有把数据持久化到磁盘；</li>
<li>图中的 fsync，把数据持久化到磁盘的操作，这里就会涉及磁盘
I/O，所以频繁的 fsync 会导致磁盘的 I/O 升高；</li>
</ul>
<p>MySQL 提供一个 sync_binlog 参数来控制数据库的 binlog
刷到磁盘上的频率：</p>
<ul>
<li>sync_binlog = 0 的时候，表示每次提交事务都只 write，不
fsync，后续交由操作系统决定何时将数据持久化到磁盘；</li>
<li>sync_binlog = 1 的时候，表示每次提交事务都会 write，然后马上执行
fsync；</li>
<li>sync_binlog =N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N
个事务后才 fsync。</li>
</ul>
<h2 id="两阶段提交">两阶段提交</h2>
<p>binlog 主从复制和 redo log
崩溃恢复需要保持一致，不然会出现<strong>主从数据不一致、备份数据与真实数据不一致</strong>等问题。MySQL
采用两阶段提交来避免两份日志之间的逻辑不一致，两阶段提交是一种<strong>分布式事务一致性协议</strong>。</p>
<p>两阶段提交：把单个事务的提交拆分成了 2
个阶段，分别是准备阶段和提交阶段（不是 commit
语句），每个阶段都由协调者和参与者共同完成。</p>
<h3 id="内部-xa-事务">内部 XA 事务</h3>
<style>.yslubskpwbxu{zoom:50%;}</style>
<img data-src="/-developer/MySQL/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.drawio.png" class="yslubskpwbxu" alt="两阶段提交">
<p>为了保证这两个日志的一致性，MySQL 使用了内部 XA 事务。内部 XA 事务由
binlog 作为协调者，存储引擎是参与者，可以实现跨数据库事务。将 redo log
的写入拆成了<strong>两个状态：prepare 和
commit</strong>，中间再穿插写入binlog。</p>
<ul>
<li>如果 binlog 中没有当前内部 XA 事务的 XID，说明 redolog
完成刷盘，但是 binlog 还没有刷盘，则<strong>回滚事务</strong>。对应时刻
<strong>A 崩溃恢复</strong>的情况；</li>
<li>如果 binlog 中有当前内部 XA 事务的 XID，说明 redolog 和 binlog
都已经完成了刷盘，则<strong>提交事务</strong>。对应时刻 <strong>B
崩溃恢复</strong>的情况；</li>
</ul>
<p>对于处于 prepare 阶段的 redo
log，即可以提交事务，也可以回滚事务，这取决于是否能在 binlog 中查找到与
redo log 相同的 XID，以 binlog 写成功为事务提交成功的标识。</p>
<h2 id="组提交">组提交</h2>
<p>采用<strong>组提交</strong>策略，减少 redolog 和 binlog
两次刷盘导致的 <strong>I/O
次数高</strong>和<strong>锁竞争激烈</strong>的问题。</p>
<blockquote>
<p>多事务场景下，两阶段提交会导致锁竞争激烈，因为为保证两个日志保存的数据库状态一致，需要加锁操作保证两阶段提交的原子性。</p>
</blockquote>
<p><strong>binlog 组提交机制</strong>：当有多个事务提交的时候，会将多个
binlog 刷盘操作合并成一个，从而减少磁盘 I/O 的次数。prepare
阶段不变，只针对 commit 阶段，将 commit 阶段拆分为三个阶段：</p>
<ul>
<li><strong>flush 阶段</strong>：多个事务按进入的顺序将 binlog 从 cache
写入文件（不刷盘）；5.7 之后在该阶段增加了 redo log 的组提交，即多个事务
redo log 统一刷盘；
<ul>
<li>类似于 XA 事务的 Prepare 阶段，如果在这一步完成后数据库崩溃，由于
binlog 中没有该组事务的记录，所以 MySQL 会在重启后回滚该组事务；</li>
</ul></li>
<li><strong>sync 阶段</strong>：对 binlog 文件做 fsync 操作（多个事务的
binlog 合并一次刷盘）；
<ul>
<li>类似于 XA 事务的 Commit 阶段，如果在这一步完成后数据库崩溃，由于
binlog 中已经有了事务记录，MySQL会在重启后通过 redo log
刷盘的数据继续进行事务的提交。</li>
</ul></li>
<li><strong>commit 阶段</strong>：各个事务按顺序做 InnoDB commit
操作；</li>
</ul>
<p>每个阶段都有一个队列，锁就只针对每个队列进行保护，不再锁住提交事务的整个过程。减小了锁粒度，这样就使得多个阶段可以并发执行，从而提升效率。</p>
<h2 id="总结模拟一次更新流程">总结模拟一次更新流程</h2>
<ul>
<li>MySQL 执行器检查记录是否在 buffer pool 中
<ul>
<li>若不在，将数据页从磁盘读入到 buffer pool；</li>
<li>若更新前与更新后数据不同，调用 存储引擎 执行更新操作；</li>
</ul></li>
<li>开启事务，记录 undo log，同时将 Undo 页的修改记录存在 redo log
中；</li>
<li>存储引擎更新数据，并标记数据页为脏页，同时将数据页的修改记录存在
redo log 中；
<ul>
<li>为了减少磁盘I/O，脏页选择合适时间持久化到硬盘，持久化后删除对应的
redo log；</li>
</ul></li>
<li>记录更新完毕，记录 binlog 至 binlog cache；</li>
<li>事务提交，将 redolog binlog 持久化到硬盘（两阶段提交；组提交）
<ul>
<li>prepare 阶段</li>
<li>commit 阶段</li>
</ul></li>
</ul>
<p>脏页刷盘的时机</p>
<ul>
<li>Redo log 满了；</li>
<li>BufferPool满了；</li>
<li>MySQL空闲；</li>
<li>后台线程定时 checkpoint；</li>
<li>事务提交时（一般不选）；</li>
</ul>
<h1 id="内存">内存</h1>
<p><strong>Buffer Pool 缓存</strong>的内容包括：索引页、数据页、Undo
页、插入缓存页、自适应哈希索引、锁信息等。<code>innodb_buffer_pool_size</code>
默认 128MB。</p>
<p>为了管理这些在 Buffer Pool 中的缓存页，InnoDB
为每一个缓存页都创建了一个<strong>控制块</strong>，控制块信息包括：缓存页的表空间、页号、缓存页地址、链表节点等等。用三种链表管理不同状态的缓存块：</p>
<ul>
<li>Free List （空闲页链表），管理空闲页；</li>
<li>Flush List （脏页链表），管理脏页；</li>
<li>LRU
List，管理脏页+干净页，将经常查询或可能将要查询的数据缓存在其中，而不常查询的数据就淘汰出去；</li>
</ul>
<p><strong>Free 链表</strong>：使用链表结构，快速找到空闲的缓存页；</p>
<p>每当需要从磁盘中加载一个页到 Buffer Pool 中时，就从
Free链表中取一个空闲的缓存页，并且把该缓存页对应的控制块的信息填上，然后把该缓存页对应的控制块从
Free 链表中移除</p>
<style>.hgoshqfanpmg{zoom: 67%;}</style>
<img data-src="/-developer/MySQL/freelist.drawio.png" class="hgoshqfanpmg" alt="img">
<p><strong>Flush 链表</strong>：使用链表结构，快速找到脏页；（结构类似于
Free 链表）</p>
<p>脏页落盘时，后台线程遍历 Flush 链表</p>
<h2 id="提高缓存命中率">提高缓存命中率</h2>
<p>Buffer Pool 有三种页和链表用来管理数据</p>
<style>.ifpgpjushojx{zoom:67%;}</style>
<img data-src="/-developer/MySQL/bufferpoll_page.png" class="ifpgpjushojx" alt="img">
<ul>
<li>Free Page（空闲页），表示此页未被使用，位于 Free 链表；</li>
<li>Clean Page（干净页），表示此页已被使用，但是页面未发生修改，位于LRU
链表。</li>
<li>Dirty
Page（脏页），表示此页「已被使用」且「已经被修改」，其数据和磁盘上的数据已经不一致。当脏页上的数据写入磁盘后，内存数据和磁盘数据一致，那么该页就变成了干净页。脏页同时存在于
LRU 链表和 Flush 链表。</li>
</ul>
<p>普通的LRU 算法会出现以下<strong>两个问题</strong></p>
<ul>
<li>预读失效：加载访问数据页时，提前加载进来的<strong>相邻数据</strong>页，即预读页，但后续并没有访问预读页；</li>
<li>Buffer Pool 污染：某一个 SQL 语句扫描了大量的数据时，将 Buffer Pool
里的所有页都替换出去，导致<strong>大量热数据被淘汰</strong>了，后续热数据被访问时会产生大量磁盘
I/O；
<ul>
<li>索引失效批量扫描的时候会出现污染</li>
</ul></li>
</ul>
<p><strong>解决办法</strong></p>
<ul>
<li>将 LRU 划分了 2 个区域：old 区域 和 young
区域。划分这两个区域后，预读的页就只需要加入到 old
区域的头部，当页被真正访问的时候，才将页插入 young 区域的头部。</li>
<li>只有同时满足<strong>被访问</strong>与在 <strong>old 区域停留时间超过
<code>innodb_old_blocks_time</code> 秒</strong>两个条件，才会被插入到
young 区域头部</li>
<li>young 区域优化：为了防止 young 区域节点频繁移动到头部。young
区域前面 1/4 被访问不会移动到链表头部，只有后面的 3/4被访问了才会</li>
</ul>
<h1 id="优化">优化</h1>
<p>磁盘IO、索引、<a
href="https://www.cnblogs.com/yanggb/p/11058707.html">数据分页（查询大量数据）</a>、锁竞争、内存使用下·</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/-developer/Redis/</url>
    <content><![CDATA[<p>Redis 的特性：单线程、原子性、基于内存、优化数据结构、I/O
多路复用的非关系型数据库；</p>
<p>6.0 版本前网络 I/O 和命令处理都是单线程，6.0 版本后网络 I/O
改用多个线程处理</p>
<ul>
<li>大部分操作都在内存中完成（制约 Redis 性能的瓶颈并不是
CPU，而是内存和网络带宽）</li>
<li>避免了多线程之间的竞争</li>
<li>I/O 多路复用机制</li>
</ul>
<h1 id="数据结构">数据结构</h1>
<p>5
种基础数据类型：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）
3 种特殊数据类型：HyperLogLog（基数统计）、Bitmap （位图）、Geospatial
(地理位置)</p>
<h1 id="持久化">持久化</h1>
<p>保证即使在服务器重启的情况下也不会丢失数据（或少量损失）</p>
<h2 id="aof-日志">AOF 日志</h2>
<p>将每条执行成功的<strong>写操作命令</strong>追加到日志文件中，持久化代码命令在主进程上执行</p>
<p>写回策略（防止AOF日志在持久化过程中丢失）：</p>
<style>.ijoldbpbtfbg{zoom:67%;}</style>
<img data-src="/-developer/Redis/98987d9417b2bab43087f45fc959d32a.png" class="ijoldbpbtfbg" alt="img">
<p>重写机制（防止AOF日志文件过大）：</p>
<ul>
<li><p>删去已经无意义的日志；</p></li>
<li><p>重写操作由后台子进程完成，子进程共享父进程内存（为什么不用线程？父子进程以只读的方式共享数据，如果任意一方修改了该共享内存，父子进程会有独立的数据副本，即<strong>写时复制</strong>，注意这里只会复制主进程修改的物理内存数据，没修改物理内存还是与子进程共享的。而线程共享内存需要加锁）；</p></li>
<li><p>AOF
重写缓冲区用于保存重写子进程启动后，新产生的AOF日志，并在重写结束后追加到新的AOF文件中；</p></li>
</ul>
<h2 id="rdb-快照">RDB 快照</h2>
<p>某一时刻内存数据的快照（二进制数据），恢复时直接读入内存即可</p>
<p>执行 bgsave 时，想要修改数据，需采用<a
href="https://xiaolincoding.com/redis/storage/rdb.html#%E6%89%A7%E8%A1%8C%E5%BF%AB%E7%85%A7%E6%97%B6-%E6%95%B0%E6%8D%AE%E8%83%BD%E8%A2%AB%E4%BF%AE%E6%94%B9%E5%90%97">写时复制</a>（Copy-On-Write,
COW），以减少性能损耗</p>
<h2 id="混合持久化">混合持久化</h2>
<p>在AOF日志重写过程中，将新的含有 RDB 格式和 AOF 格式的 AOF
文件替换旧的的 AOF 文件，前半部分是 RDB 格式的全量数据，后半部分是 AOF
格式的增量数据，即重写缓冲区数据。</p>
<h1 id="策略">策略</h1>
<h2 id="过期删除策略">过期删除策略</h2>
<p>惰性删除+定期删除</p>
<h2 id="内存淘汰策略">内存淘汰策略</h2>
<p>仅淘汰过期数据：random、ttl、lru、lfu</p>
<p>淘汰所有数据：lru、lfu</p>
<h1 id="高可用">高可用</h1>
<h2 id="主从复制">主从复制</h2>
<p>模式一：全量复制【多用于初始化】</p>
<img data-src="/-developer/Redis/ea4f7e86baf2435af3999e5cd38b6a26.png" class="" title="图片">
<ul>
<li>bgsave 命令创建子进程来做生成 RDB 文件的工作，是异步工作的</li>
</ul>
<p>为了避免过多的从服务器和主服务器进行数据同步（全量复制），可以把一部分从服务器升级成分发节点，利用从节点分担读取操作的压力</p>
<p>模式二：基于长连接的命令传播【多用于保持同步】</p>
<p>主从服务器在完成第一次同步后，双方之间就会维护一个 TCP
连接，保证第一次同步后的主从服务器的数据一致性。</p>
<p>模式三：<strong>连接恢复</strong>时可以采用<strong>增量复制</strong>：repl_backlog_buffer
环形缓冲区保存了最近传播的写命令，若其中存着从服务器请求的
offset，就采用增量复制；否则采用<strong>全量复制</strong>。若想降低主从服务器断开后全量同步的概率，需要增大
repl_backlog_buffer</p>
<h3 id="qa">QA</h3>
<p><strong>如何应对异步复制导致的主从数据不一致？</strong></p>
<p>外部程序来监控主从节点间的复制进度</p>
<p><strong>主从切换如何减少数据丢失？</strong></p>
<ul>
<li>设置复制延迟限制 <code>min-slaves-max-lag</code></li>
<li>客户端降级措施，当 master 不可写，就把数据存到本地或 kafka
中等待主节点正常后再消费</li>
</ul>
<p><strong>集群脑裂导致数据丢失</strong></p>
<p>主节点必须要有至少 <code>min-slaves-to-write</code>
个从节点连接，主从数据复制和同步的延迟不能超过
<code>min-slaves-max-lag</code>
秒。否则原主节点就会被限制接收客户端写请求，客户端也就不能在原主节点中写入新数据，等到新的主节点上线一切恢复正常。</p>
<h2 id="哨兵机制">哨兵机制</h2>
<blockquote>
<p>自动完成故障发现和故障转移，并通知给应用方，从而实现高可用性</p>
</blockquote>
<p>哨兵之间建立连接</p>
<style>.iysnsooivxss{zoom:50%;}</style>
<img data-src="/-developer/Redis/a6286053c6884cf58bf397d01674fe80.png" class="iysnsooivxss" alt="img">
<p>哨兵与从节点建立连接</p>
<style>.gljuwksyqhpc{zoom:50%;}</style>
<img data-src="/-developer/Redis/fdd5f695bb3643258662886f9fba0aab.png" class="gljuwksyqhpc" alt="img">
<h3 id="第一轮投票判断主节点下线">第一轮投票：判断主节点下线</h3>
<p>主观下线：主节点或者从节点没有在规定的时间内响应哨兵的 PING 命令</p>
<p>客观下线：一个哨兵判断主节点为「主观下线」后，就会向其他哨兵发起命令，通过多个哨兵节点一起判断主节点是否下线。哨兵的赞同票数达到哨兵配置文件中的
quorum 配置项设定的值则判断主节点客观下线</p>
<h3 id="第二轮投票选出哨兵-leader">第二轮投票：选出哨兵 leader</h3>
<ul>
<li>哪个哨兵节点判断主节点为「客观下线」，这个哨兵节点就是候选者，所谓的候选者就是想当
Leader 的哨兵。</li>
<li>候选者会向其他哨兵发送命令，表明希望成为 Leader
来执行主从切换，并让所有其他哨兵对它进行投票。Raft 算法选择哨兵 Leader：
<ul>
<li>第一，拿到半数以上的赞成票；</li>
<li>第二，拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值。</li>
</ul></li>
</ul>
<h3 id="由哨兵-leader-进行主从故障转移">由哨兵 leader
进行主从故障转移</h3>
<ul>
<li>第一步：在已下线主节点（旧主节点）属下的所有「从节点」里面，挑选出一个从节点，并将其转换为主节点，选择的规则：
<ul>
<li>过滤掉已经离线的从节点；</li>
<li>过滤掉历史网络连接状态不好的从节点；</li>
<li>将剩下的从节点，进行三轮考察：优先级、复制进度、ID
号。在每一轮考察过程中，如果找到了一个胜出的从节点，就将其作为新主节点。</li>
</ul></li>
<li>第二步：让已下线主节点属下的所有「从节点」修改复制目标，修改为复制「新主节点」；</li>
<li>第三步：将新主节点的 IP
地址和信息，通过「发布者/订阅者机制」通知给客户端；</li>
<li>第四步：继续监视旧主节点，当这个旧主节点重新上线时，将它设置为新主节点的从节点；</li>
</ul>
<h2 id="集群">集群</h2>
<img data-src="/-developer/Redis/d1b889b9039f4f2f9853d44e3aa258fctplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" class="" title="img">
<ul>
<li>同一个分区内的 Redis
节点之间的数据完全一样，多个节点保证了数据有多份副本冗余保存，且可以提供高可用保障；</li>
<li>不同分片之间的数据不相同；</li>
<li>通过水平增加多个分片的方式，可以实现整体集群容量的扩展；</li>
</ul>
<h3 id="集群数据分布策略">集群数据分布策略</h3>
<p><strong>Hash 槽</strong></p>
<ul>
<li>切片 slot 槽，共有16384个槽位；</li>
<li>数据 key 通过 “CRC16 算法 + 16384 取模”，得到对应存储的哈希槽；</li>
<li>数据存储在该槽位对应的 Redis
分区中，每个分区都有独立的主从哨兵保证高可用；</li>
</ul>
<p><strong>一致性Hash</strong></p>
<p>虚拟节点</p>
<h1 id="缓存">缓存</h1>
<h2 id="缓存雪崩击穿穿透">缓存雪崩、击穿、穿透</h2>
<p>缓存穿透：大量请求了缓存和数据库里都没有的数据，请求穿透缓存和数据库</p>
<ul>
<li>参数校验：参数不合法直接抛出异常</li>
<li>缓存无效 key：适用于 key 变化不频繁</li>
<li>布隆过滤器：校验 Key
是否合法（有误差，可能会把未存的值当作已有，即不合法的 key
当作合法的）</li>
<li>接口限流：固定窗口算法、滑动窗口算法、漏桶算法、令牌桶算法</li>
</ul>
<p>缓存击穿：瞬间大量请求未缓存的数据库数据，请求击穿缓存直接打到数据库上</p>
<ul>
<li>热点数据永不过期或过期时间长</li>
<li>预热热点数据：定时任务预热（定时触发缓存预热的逻辑，将数据库中的热点数据查询出来并存入缓存中）、kafka
异步预热（将数据库中的热点数据的主键或者 ID
发送到消息队列中，然后由缓存服务消费消息队列中的数据，根据主键或者 ID
查询数据库并更新缓存）</li>
<li>访问数据库互斥锁</li>
</ul>
<p>缓存雪崩：缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上</p>
<ul>
<li>Redis 集群</li>
<li>限流</li>
<li>多级缓存：本地缓存+Redis</li>
<li>热点数据失效时间长</li>
<li>预热热点数据</li>
</ul>
<h2 id="如何保证数据库和缓存一致性">如何保证数据库和缓存一致性</h2>
<blockquote>
<p>采用 Cache Aside
旁路缓存策略：以数据库中的数据为准，缓存中的数据是按需加载的；缺点：数据写入频繁时，缓存中的数据会被频繁的清理，降低缓存命中率；</p>
</blockquote>
<p>更新数据库+删除缓存：延迟双删</p>
<p>更新数据库+更新缓存：分布式锁</p>
<p>更新数据库+不更新缓存：较短的缓存有效期</p>
<p><strong>删除缓存的时候失败了怎么办？</strong></p>
<p>采用异步删除：</p>
<ul>
<li>消息队列确保缓存删除成功</li>
<li>订阅 MySQL 的 binlog，数据修改时删除缓存</li>
</ul>
<h2 id="缓存预热">缓存预热</h2>
<p>提高访问速度，平滑流量峰值，减少后端压力，保证数据的时效性</p>
<p>Redis 缓存预热的方法：系统启动时加载；定时任务加载；</p>
<h1 id="实战">实战</h1>
<h2 id="分布式锁">分布式锁</h2>
<blockquote>
<p>Redis + Lua
脚本，可以以原子性的方式执行一组命令，可用于保证锁释放操作的原子性（Lua
脚本在处理的过程中不会被任意其它请求打断），但无法用于事务执行失败的回滚。Redisson
采用的就是这种方法保证分布式锁的原子性。</p>
</blockquote>
<p><strong>SET 命令的 NX 参数</strong>可以实现：key
不存在才插入，可以用于实现分布式锁</p>
<p>优点：性能高效、实现方便、分布式高可用</p>
<p>缺点：不好设置超时时间（解决方法：守护线程定期续约）、主从异步复制可能导致不可靠性（解决方法如下）</p>
<p>提高可靠性（Redlock 算法）：客户端和多个独立的 Redis
节点依次请求申请加锁，如果客户端能够和半数以上的节点成功地完成加锁操作，那么就认为，客户端成功地获得分布式锁，否则加锁失败，所有的
redis 实例都会进行解锁；</p>
<ul>
<li>单机的 redis 是 cp 的，但是集群情况下 redis 是 ap 的，所以运行
Redisson
的节点必须是主节点，不能有从节点，防止主节点加锁成功未同步从节点就宕机，而客户端却收到加锁成功，导致数据不一致。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redisson;</span><br></pre></td></tr></table></figure>
<h2 id="延迟队列">延迟队列</h2>
<p>有序集合 Zset；score 存储延迟执行的时间</p>
<h2 id="大-key-问题">大 Key 问题</h2>
<p>会导致的问题</p>
<ul>
<li>由于 Redis 单线程处理，大 Key
的增删改查都很耗时，会导致<strong>工作线程阻塞、客户响应超时、网络传输阻塞</strong>；</li>
<li><strong>内存分布不均</strong>，集群场景下 slot 槽数据量不均；</li>
<li><strong>持久化阻塞主线程</strong>，会主线程的两个阶段耗时增加：创建子进程复制页表结构、修改共享数据写时复制；</li>
</ul>
<p>解决办法</p>
<ul>
<li>拆分大 key；</li>
<li>及时/定时清理大 key，unlink 异步删除代替 del 同步删除；</li>
</ul>
<h2 id="发布者订阅者">发布者/订阅者</h2>
<blockquote>
<p>订阅命令：subscribe channel [channel ... ]</p>
</blockquote>
<style>.tktfkebqwmjz{zoom:40%;}</style>
<img data-src="/-developer/Redis/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAwrfmooXoirHljYHkuIk=,size_20,color_FFFFFF,t_70,g_se,x_16.png" class="tktfkebqwmjz" alt="img">
<p><a
href="https://blog.csdn.net/w15558056319/article/details/121490953">Link</a></p>
<h2 id="事务回滚">事务回滚</h2>
<p>Redis 不支持回滚，事务没有原子性（要么全部成功要么全部失败）</p>
<h2 id="管道">管道</h2>
<p>批处理技术，可以一次处理多个 Redis
命令，减少多个命令执行时的网络等待</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/-developer/SpringMVC/</url>
    <content><![CDATA[<h1 id="tomcat">Tomcat</h1>
<p>Tomcat 是基于 HTTP 协议的 Web 服务器，工作流程图 <a
href="https://blog.csdn.net/qq_19782019/article/details/80292110">Link</a></p>
<img data-src="/-developer/SpringMVC/2018120522281643.gif" class="" title="img">
<h2 id="servlet">Servlet</h2>
<p>Servlet 接口定义了 Servlet 与 servlet容器
之间的契约。这个契约是：Servlet容器将Servlet类载入内存，并产生 Servlet
实例和调用它具体的方法。但是要注意的是，<strong>在一个应用程序中，每种
Servlet 类型只能有一个实例</strong>。类比 SpringMVC 中每一个 Mapping
对应一个控制层方法【不确定】</p>
<p>对于每一个应用程序，Servlet容器还会创建一个ServletContext对象。这个对象中封装了上下文（应用程序）的环境详情。每个应用程序只有一个ServletContext。每个Servlet对象也都有一个封装Servlet配置的ServletConfig对象。</p>
<h1 id="springmvc">SpringMVC</h1>
<p>流程图</p>
<img data-src="/-developer/SpringMVC/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5q2i5q2l5YmN6KGM,size_20,color_FFFFFF,t_70,g_se,x_16.png" class="" title="SpringMVC流程图">
<ul>
<li>由<code>DispatcherServlet</code>
从<code>HandlerMappings</code>中匹配对应的<code>Handler</code>。此时只是获取到了对应的<code>Handler</code>，然后拿着这个<code>Handler</code>去寻找对应的适配器，即：<code>HandlerAdapter</code>：让固定参数的
Servlet 处理方法调用灵活的 Handler 来处理；</li>
<li>执行 <code>Controller</code> 处理业务逻辑， 执行完成之后返回一个
<code>ModeAndView</code> 或 Json 格式数据；</li>
</ul>
<p>HandlerMapping/HandlerAdapter 的<strong>适配器模式</strong>：</p>
<p>SpringMVC 的 Handler 有多种实现方式（如继承 Controller 接口、继承
HttpRequestHandler 接口、基于注解 <span class="citation"
data-cites="Controller">@Controller</span>
的控制器）。由于实现方式不一样，调用方式就不确定，就需要适配器模式将所有实现方式都统一成同一个接口。把任何一个
Handler
都适配成一个HandlerAdapter，从而可以做统一的流程处理，不用耦合具体的处理器，模糊掉具体的实现。</p>
<p>Spring MVC会为每一个标记了 <span class="citation"
data-cites="Controller">@Controller</span>
的类创建一个控制器实例（bean），并且根据这些类中的 <span
class="citation" data-cites="RequestMapping">@RequestMapping</span>
注解来配置 URL 到方法的映射。这些映射信息通常会被存储在一个叫做
<code>HandlerMapping</code> 的组件中</p>
<h1 id="系统权限">系统权限</h1>
<p>JWT 是无状态的，适合在分布式系统中使用</p>
]]></content>
      <categories>
        <category>Java开发</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Rpc 中间件</title>
    <url>/-developer/Rpc/</url>
    <content><![CDATA[<img data-src="/-developer/Rpc/A5B6F28E3286E3F920698A1D904CE4B0.png" class="" title="图片说明">
<p>分布式系统的 CAP 理论</p>
<ul>
<li>一致性（Consistency）：所有节点访问同一份最新的数据副本</li>
<li>可用性（Availability）：非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）</li>
<li>分区容错性（Partition
Tolerance）：分布式系统出现网络分区的时候，仍然能够对外提供服务。</li>
</ul>
<p>分布式保证服务高并发稳定性</p>
<ul>
<li>缓存：缓存是一种提高数据读取性能的技术，通过在内存中存储经常访问的数据，可以减少对数据库或者其他存储系统的访问，从而提高系统的响应速度。缓存可以应用在多个层次，例如浏览器缓存、CDN
缓存、反向代理缓存、应用缓存等。</li>
<li>降级：降级是在系统压力过大或者部分服务不可用的情况下，暂时关闭一些非核心的服务，以保证核心服务的正常运行。降级可以在多个层次进行，例如页面降级、功能降级、服务降级等。</li>
<li>限流：限流是一种控制系统处理请求的速率的技术，以防止系统过载。限流可以通过多种算法实现，例如固定窗口、滑动窗口、漏桶算法、令牌桶算法等。</li>
</ul>
<p>Nacos 配置中心 注册中心</p>
<h1 id="rpc-框架">RPC 框架</h1>
<blockquote>
<p>泛指调用远程的函数的方法，对编解码和网络层有特殊的优化，从而有更高的效率。</p>
</blockquote>
<p>RPC 框架主要由 Server、Client、Server Stub、Client Stub 组件组成</p>
<ul>
<li>Client Stub
主要是将客户端的请求参数、请求服务地址、请求服务名称做一个封装，并发送给
Server Stub</li>
<li>Server Stub 主要用于接收 Client Stub 发送的数据并解析，去调用 Server
端的本地方法</li>
</ul>
<p>层次结构：代理曾、注册中心层（服务发现、注册、管理）、</p>
<p>RPC 协议定制化程度高，可以采用体积更小的 Protobuf
或其他序列化协议去保存结构体数据，同时也不需要像 HTTP
那样考虑各种浏览器行为，如 302
重定向跳转。因此性能也会更好一些。其底层不仅可以通过 tcp udp
实现，也可以通过 http 实现。</p>
<p>RPC
协议会建个连接池，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，用完放回去，下次再复用，可以说非常环保。</p>
<p>目前，对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC
协议进行通讯。</p>
<h1 id="dubbo-上线问题">Dubbo 上线问题</h1>
<p>记录、学习、汇总实习和技术博客中看到的 Dubbo 实战遇到的问题</p>
<h2 id="服务端接口不指定通讯协议导致-oom">服务端接口不指定通讯协议导致
OOM</h2>
<p>问题背景：</p>
<p>问题描述：</p>
<ul>
<li><p>开发人员使用方没有配置接口的 protocol
字段，而是写在接口实现类上</p></li>
<li><p><code>dubbo-3.0.4</code> 框架：</p>
<ul>
<li>若没有指定 protocol 字段，会创建服务端提供的所有协议的 invoker</li>
<li>EasyREST 包<code>createClientInvoker</code>创建 REST 协议的 invoker
时需要 HttpMethod 参数</li>
<li>由于注解写在实现类而不是接口上面，导致消费端无法共享相应的 REST
配置信息，即 HttpMethod 为 null，因此 RESTClient 创建失败</li>
<li>在服务更新过程中，客户端每次都是全量更新注册中心的服务端信息，这个过程中如果
invoker
一直注册失败，会不断将失败的<code>Client</code>存到<code>List&lt;ResteasyClient&gt;</code>中，如果有
n 台机器需要依次更新，这时客户端的数组中会存 n*n
个失败的连接实例，从而导致 OOM</li>
</ul></li>
</ul>
<p>解决方法（针对框架，开发人员需要牢记 Dubbo 配置必须在接口上）：</p>
<ul>
<li>ResteasyClient 对象由 RestProtocol 协议对象持有，针对没有创建成功
invoker 的场景应把其对应的 ResteasyClient <u>销毁</u>掉</li>
</ul>
<p>销毁方法</p>
<ul>
<li>用<code>Map&lt;String, ResteasyClient&gt;</code>代替
<code>List&lt;ResteasyClient&gt;</code>，同一个服务端只存一次</li>
<li>用<code>WeakHashMap&lt;String, ResteasyClient&gt;</code>自动回收不用的
ResteasyClient（参考<a
href="https://github.com/apache/dubbo/pull/4629">pr</a>）</li>
</ul>
<p><a
href="https://tech.youzan.com/ji-ci-dubbofu-wu-fa-xian-dao-zhi-de-oom/">参考</a></p>
<h2 id="父子线程并发-rpc-调用死锁">父子线程并发 RPC 调用死锁</h2>
<p>问题描述：</p>
<ul>
<li>直接通过 <code>Executors</code> 构造 固定数量+无限长等待队列
线程池，该线程池在共享的无界队列上操作的固定数量的线程。在任何时候，最多nThreads线程将处于活动处理任务状态。如果在所有线程都处于活动状态时提交额外的任务，它们将在队列中等待，直到有线程可用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>并发调用 Rpc 接口获取返回值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Future&lt;String&gt; future = executor.submit(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> 数据查询任务;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>数据查询任务中存在父子调用关系，数据查询任务同步调用 Redis
查询缓存和 Rpc 调用微服务获得数据。如果本地 Redis
缓存中能获得数据，就直接返回缓存值并取消 Rpc 调用
<code>future.cancel(true)</code>。</li>
</ul>
<p>解决办法</p>
<ul>
<li>父子任务分开并发执行，耗时的异步线程应做好线程池隔离</li>
<li><code>CompletableFuture.anyOf(task1,tsak2)</code>
优先取先完成的那个任务的返回值</li>
</ul>
<p><a href="https://heapdump.cn/article/646639">参考</a></p>
<h1 id="尝试开发基础版-rpc-中间件">尝试开发基础版 Rpc 中间件</h1>
<p><strong>服务发现流程</strong>：使用远程服务的时候首先需要配置一个
dubbo.xml
文件或者在使用的类加上<code>@Reference</code>，二者都是用来对dubbo消费者引用服务进行一些配置，然后应用在启动的时候会将配置信息转化为一个<code>ReferenceBean</code>对象，并调用<code>createProxy</code>方法创建一个远程服务接口的代理对象。</p>
<p>代理对象的 <strong>invoke
创建</strong>：启动时主动订阅注册中心，会显示地调用一次<code>notify</code>接口，这个接口会尝试将远程服务注册的<code>url</code>转换成一个本地的<code>invoker</code>。</p>
<ul>
<li>转换过程中会根据具体的 <code>protocol</code> 创建对应的
<code>invoker</code>，如 Rest 和 Dubbo 需要解析不同的参数。</li>
</ul>
<p>服务注册地址发生改变时：会通知给消费者，dubbo
协议里面明确讲到服务发生改变会全量更新所有客户端的缓存</p>
<h2 id="netty-数据传输">Netty 数据传输</h2>
<blockquote>
<p>在网络通信中，序列化和编码通常是结合使用的。<strong>序列化将对象转换为字节流，编码将字节流转换为网络传输所需的格式</strong>（如按照协议规定的格式进行编码）。在接收端，<strong>解码将网络传输的数据解析为原始的格式（如解码成对象）</strong>，以便进行进一步的处理和使用。</p>
</blockquote>
<p>Netty 是一个高性能<strong>事件驱动型非阻塞 IO 框架</strong>：</p>
<ul>
<li>提供了 ByteBuf 容器，更方便地处理数据。<code>ByteBuf</code>
在重写编解码器的 encoder/decoder 方法中作为参数传入。</li>
<li>channel</li>
</ul>
<p>编码：先序列化，再压缩，最后写进 ByteBuf 对象中</p>
<p>解码：从 ByteBuf 对象中读，然后转成我们需要的对象</p>
<h2 id="代理模式">代理模式</h2>
<p><strong>静态代理</strong></p>
<blockquote>
<p>静态代理中，我们对目标对象的每个方法的增强都是手动完成的（后面会具体演示代码），非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改）且麻烦(需要对每个目标类都单独写一个代理类)。
实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。</p>
</blockquote>
<p>从 JVM 层面来说，
静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class
文件。</p>
<p>静态代理的步骤</p>
<ul>
<li>定义一个接口及其实现类；</li>
<li>创建一个代理类同样实现这个接口</li>
<li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</li>
</ul>
<h2 id="jdk-动态代理">JDK 动态代理</h2>
<ul>
<li>定义一个接口及其实现类；</li>
<li>自定义 InvocationHandler 并重写 invoke 方法，在 invoke
方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li>
<li>通过
<code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code>
方法创建代理对象；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcClientProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 在代理类内，根据传入的类 clazz，获得代理对象</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getProxy</span><span class="params">(Class&lt;T&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(clazz.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;clazz&#125;, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当通过代理类调用的所有方法，实际上调用的是这个invoke（传入的只是服务接口，具体的实现在服务端实现类中）</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么是如何调用服务端实现类的代码的呢？<strong>注入</strong></p>
<ol type="1">
<li>在实例化 bean 之后，postProcessAfterInitialization 方法被调用。</li>
<li>对于每个 bean 类的字段，检查是否标记了 <span class="citation"
data-cites="RpcReference">@RpcReference</span> 注解。</li>
<li>如果发现标记了 <span class="citation"
data-cites="RpcReference">@RpcReference</span>
注解的字段，根据注解中的信息创建相应的 RpcServiceConfig 对象。</li>
<li>通过 RpcClientProxy 创建了一个代理对象
clientProxy，这个代理对象实现了 declaredField.getType()
所表示的接口，这个接口可能就是 HelloService 接口或其它接口，取决于
helloService 字段的类型。</li>
<li>这个代理对象 clientProxy 会在方法调用时委托给 RpcClientProxy 的
invoke 方法，该方法负责处理远程调用的逻辑。</li>
<li>通过反射设置 clientProxy 到 HelloController 类的 helloService
字段上，替换了原来的字段值。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">clientProxy</span> <span class="operator">=</span> rpcClientProxy.getProxy(declaredField.getType());</span><br><span class="line">declaredField.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    declaredField.set(bean, clientProxy);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="传输协议">传输协议</h2>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">*   0     1     2     3     4        5     6     7     8         9        10     11     12   13   14 15 16</span><br><span class="line">*   +-----+-----+-----+-----+--------+----+----+----+------+-----------+-------+-------+-----+---+-----+----+</span><br><span class="line">*   |   magic   code        |version | full length         | messageType| codec|compress|    RequestId       |</span><br><span class="line">*   +-----------------------+--------+---------------------+-----------+-----------+-----------+------------+</span><br><span class="line">*   |                                         body                                                            |</span><br><span class="line">*   +-------------------------------------------------------------------------------------------------------+</span><br><span class="line">* 4B  magic code（魔法数）   1B version（版本）   4B full length（消息长度）    1B messageType（消息类型）</span><br><span class="line">* 1B compress（压缩类型） 1B codec（序列化类型）    4B  requestId（请求的Id）</span><br></pre></td></tr></table></figure>
<h2 id="注册中心">注册中心</h2>
<p>服务注册：在 zk 里面创建一个对应的持久节点</p>
<p>当我们的服务被<strong>注册进 zookeeper</strong>
的时候，我们将完整的服务名称 rpcServiceName （class
name+group+version）作为根节点
，子节点是对应的服务地址（ip+端口号）。相关代码在
<code>ZkServiceProviderImpl.publishService()</code> 中。</p>
<p>如果我们要<strong>获得某个服务对应的地址</strong>的话，就直接根据完整的服务名称来获取到其下的所有子节点，然后通过具体的负载均衡策略取出一个就可以了。相关代码在
<code>ZkServiceDiscoveryImpl.lookupService()</code> 中。</p>
<h3 id="zookeeper-客户端">Zookeeper 客户端</h3>
<blockquote>
<p>Curator 是 Netflix
公司开源的一套zookeeper客户端框架，解决了很多Zookeeper客户端非常底层的细节开发工作，包括连接重连、反复注册Watcher和NodeExistsException异常等等。项目内采用
CuratorUtils 类调用 Curator。</p>
</blockquote>
<p>重试策略：ExponentialBackoffRetry是指数退避重试策略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// zk的对外接口，后面我们要干什么只需要通过单例模式获得这个类，然后用这个类的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ServiceProvider</span> &#123;</span><br><span class="line">    <span class="comment">// 添加到本地 serviceMap 中（远程Rpc调用，获取本地的调用类）</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addService</span><span class="params">(RpcServiceConfig rpcServiceConfig)</span>;</span><br><span class="line">    Object <span class="title function_">getService</span><span class="params">(String rpcServiceName)</span>;</span><br><span class="line">    <span class="comment">// 注册服务到 zookeeper 中（服务发现与注册）</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">publishService</span><span class="params">(RpcServiceConfig rpcServiceConfig)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="负载均衡">负载均衡</h2>
<p>随机选取策略 轮询策略 加权轮询策略 最少活跃连接策略 一致性 Hash
策略</p>
<h2 id="序列化">序列化</h2>
<ul>
<li>序列化：将数据结构或对象转化为二进制字节流</li>
<li>反序列化：将在序列化过程中生成的二进制字节流转化为数据结构或对象</li>
</ul>
<p><strong>数据传输过程中，可能会出现粘包和半包问题，你是如何解决的？</strong></p>
<p>自定义消息结构（其他的还有固定长度传输、特殊字符分割）：MagicNumber
魔数、ContentLength 请求长度</p>
]]></content>
      <categories>
        <category>Java开发</category>
      </categories>
      <tags>
        <tag>远程过程调用框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 开发框架</title>
    <url>/-developer/Spring/</url>
    <content><![CDATA[<p>SpringCore 主要提供 IoC 依赖注入功能的支持 SpringMVC 快速构建 MVC
架构的 Web 程序 SpringBoot 简化 Spring 开发，减少配置文件，开箱即用</p>
<h1 id="ioc-控制反转">IOC 控制反转</h1>
<blockquote>
<p>当一个对象创建时，它所依赖的对象由外部传递给它，而非自己去创建所依赖的对象（比如通过new操作）。因此，也可以说在对象如何获取它的依赖对象这件事情上，控制权反转了。这便不难理解控制反转和依赖注入这两个名字的由来了。</p>
</blockquote>
<p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC
容器完成对象的注入 Bean 工厂模式</p>
<ul>
<li>单例 Singleton、多例/原型 Prototype Bean</li>
</ul>
<h1 id="aop-面向切面编程">AOP 面向切面编程</h1>
<p>将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。
实现方式：基于动态代理，有接口用 jdk 原生的代理方法，没借口用 CGLib
<img data-src="/-developer/Spring/image-20240521182846989.png" class="" title="image-20240521182846989"></p>
<h1 id="bean-生命周期">Bean 生命周期</h1>
<blockquote>
<p>自动装配：<span class="citation"
data-cites="Component">@Component</span>；<span class="citation"
data-cites="Service">@Service</span>；<span class="citation"
data-cites="Controller">@Controller</span>；<span class="citation"
data-cites="Configure">@Configure</span> + <span class="citation"
data-cites="Bean">@Bean</span></p>
</blockquote>
<img data-src="/-developer/Spring/image-20240521182854337.png" class="" title="image-20240521182854337">
<p>xxx.class --&gt; 默认无参构造方法 --&gt; 普通对象 --&gt;
依赖注入（属性赋值） --&gt; 初始化前 --&gt; 初始化 --&gt; 初始化后
--&gt; 代理对象 --&gt; 得到Bean（<a
href="https://www.cnblogs.com/chengxuxiaoyuan/p/16321716.html">源码</a>）
实例化 Bean
对象：默认调用无参构造器；若使用有参构造器，参数必须是容器中有的Bean【按参数查找
Bean 时，先按照 classname 后按照参数名】 初始化前中后：BeanPostProcessor
的 postProcessAfterInitialization() --&gt; <span class="citation"
data-cites="PostConstruct">@PostConstruct</span> 注解 --&gt;
InitializingBean 的 afterPropertiesSet() 方法 --&gt; BeanPostProcessor
的 postProcessAfterInitialization()（实现了 AOP 代理)</p>
<ul>
<li>Aware 其实就是一个标识；只有满足 Aware
规范或者其子类规范的才能进行相关的赋值操作，这样做的话可以少写很多判断，并且可以在一个地方进行统一的判断赋值；</li>
<li>BeanPostProcessor
前置处理器的关键实现类：ApplicationContextAwareProcessor</li>
<li>BeanPostProcessor
后置处理器的关键实现类：AbstractAutoProxyCreator。这个方法负责帮我们创建代理，底层采用对象cglib
或动态代理【AOP其实就是 IOC
整体流程（Bean生命周期）里的一个扩展点】</li>
<li>InitializingBean 接口中的 afterPropertiesSet
方法：在这个方法里面去编写我们的业务逻辑，以及进行相关的属性赋值等等</li>
</ul>
<p>底层实现</p>
<ul>
<li>AbstractAutowireCapableBeanFactory 内的 initializeBean 调用了所有
BeanPostProcessor 的实现类</li>
<li>ApplicationContext 类型容器的内部维护了一个 BeanFactory
类型的容器（AnnotationConfigApplicationContext 的父类
GenericApplicationContext 维护了一个 Bean
工厂实现类：DefaultListableBeanFactory）</li>
<li>DefaultListableBeanFactory：Spring 默认的 BeanFactory 实现</li>
<li>DefaultSingletonBeanRegistry：DefaultListableBeanFactory
单例模式存储关系的地方 Map&lt;String(BeanName),Object(instance)&gt;</li>
<li>AbstractApplicationContext.refresh() 方法
<ul>
<li>配置了对 BeanFactoryPostProcessor 的实现
postProcessBeanFactory(beanFactory) 和处理
invokeBeanFactoryPostProcessors(beanFactory)。BeanFactoryPostProcessor
可以自定义 ApplicationContext 容器中的 BeanFactory
进行处理，在还没有对任何Bean进行实例化之前（ConfigurationClassPostProcessor
通过注解解析配置类；PropertySourcesPlaceholderConfigurer：xml配置文件中导入的
properties 文件进行解析,并替换bean定义中的占位符）</li>
<li>配置了对 BeanPostProcessor 的实现</li>
</ul></li>
</ul>
<hr />
<ol type="1">
<li>(1-1)依赖注入：<span class="citation"
data-cites="Autowired">@Autowired</span>；<span class="citation"
data-cites="Resource">@Resource</span></li>
<li>事务 <span class="citation"
data-cites="Transactional">@Transactional</span>、<span class="citation"
data-cites="Configuration">@Configuration</span></li>
<li>(1-2)单例 Singleton、多例/原型 Prototype Bean</li>
<li>jvm类加载器classloader：bootstrap ext app <a
href="https://blog.csdn.net/javazejian/article/details/73413292#:~:text=%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B8%BB%E8%A6%81%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%98%AFJVM%E8%87%AA%E8%BA%AB%E9%9C%80%E8%A6%81%E7%9A%84%E7%B1%BB%EF%BC%8C%E8%BF%99%E4%B8%AA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%BD%BF%E7%94%A8C%2B%2B%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8C%E6%98%AF%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%87%AA%E8%BA%AB%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%8C%E5%AE%83%E8%B4%9F%E8%B4%A3%E5%B0%86%20%3CJAVA_HOME%3E%2Flib%20%E8%B7%AF%E5%BE%84%E4%B8%8B%E7%9A%84%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93%E6%88%96,-Xbootclasspath%20%E5%8F%82%E6%95%B0%E6%8C%87%E5%AE%9A%E7%9A%84%E8%B7%AF%E5%BE%84%E4%B8%8B%E7%9A%84jar%E5%8C%85%E5%8A%A0%E8%BD%BD%E5%88%B0%E5%86%85%E5%AD%98%E4%B8%AD%EF%BC%8C%E6%B3%A8%E6%84%8F%E5%BF%85%E7%94%B1%E4%BA%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%98%AF%E6%8C%89%E7%85%A7%E6%96%87%E4%BB%B6%E5%90%8D%E8%AF%86%E5%88%AB%E5%8A%A0%E8%BD%BDjar%E5%8C%85%E7%9A%84%EF%BC%8C%E5%A6%82rt.jar%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%8D%E8%A2%AB%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%86%E5%88%AB%EF%BC%8C%E5%8D%B3%E4%BD%BF%E6%8A%8Ajar%E5%8C%85%E4%B8%A2%E5%88%B0lib%E7%9B%AE%E5%BD%95%E4%B8%8B%E4%B9%9F%E6%98%AF%E6%B2%A1%E6%9C%89%E4%BD%9C%E7%94%A8%E7%9A%84%20%28%E5%87%BA%E4%BA%8E%E5%AE%89%E5%85%A8%E8%80%83%E8%99%91%EF%BC%8CBootstrap%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%AA%E5%8A%A0%E8%BD%BD%E5%8C%85%E5%90%8D%E4%B8%BAjava%E3%80%81javax%E3%80%81sun%E7%AD%89%E5%BC%80%E5%A4%B4%E7%9A%84%E7%B1%BB%29%E3%80%82">博客</a></li>
</ol>
<p>TODO Spring 启动流程 Springboot 和 Spring 最大的区别就是不需要 xml
配置 Springboot 自动配置</p>
<ul>
<li>“约定优于配置”理念</li>
<li><span class="citation"
data-cites="EnableAutoConfiguration">@EnableAutoConfiguration</span></li>
<li>自动将一些配置类的bean注册进ioc容器</li>
</ul>
<p>logback是 slf4j 的官方实现，log4j 是另一个实现，logback 和 log4j
才是二选一，slf4j 是门面日志的 api。</p>
<p>TODO <a
href="https://www.cnblogs.com/tuyang1129/p/12861617.html">https://www.cnblogs.com/tuyang1129/p/12861617.html</a>
<a
href="https://www.cnblogs.com/tuyang1129/p/12866484.html">https://www.cnblogs.com/tuyang1129/p/12866484.html</a></p>
<h1 id="spring-事务">Spring 事务</h1>
<p>Spring 的声明式事务信息是存在 ThreadLocal
中的，所以一个线程永远只能有一个事务，所以 Spring
的事务是无法实现事务一致性（同时提交、同时回滚）的</p>
<p>解决方法：可以通过编程式事务，或者通过分布式事务的思路：二阶段提交方式</p>
<h1 id="如何解决循环依赖">如何解决循环依赖</h1>
<p><a
href="https://juejin.cn/post/6860785780307492871#heading-1">三层缓存设计</a></p>
<ul>
<li>一级缓存，缓存正常的 bean 实例</li>
<li>二级缓存，缓存还未进行依赖注入和初始化方法调用的 bean 实例</li>
<li>三级缓存，缓存 bean 实例的 ObjectFactory，用于解决 BeanPostProcessor
代理类时正确地依赖注入</li>
</ul>
<blockquote>
<p>循环依赖的情况下，不管使用三级缓存还是两级缓存，代理类逻辑都必须提前曝光</p>
</blockquote>
]]></content>
      <categories>
        <category>Java开发</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker</title>
    <url>/-2024/Docker/</url>
    <content><![CDATA[<img data-src="/-2024/Docker/576507-docker1.png" class="" title="img">
<ul>
<li><a href="https://www.runoob.com/docker/docker-compose.html">Docker
Compose</a>：用于定义和运行<strong>多容器 Docker
应用程序</strong>的工具，使多个容器可以在隔离环境中一起运行；</li>
<li><a
href="https://www.runoob.com/docker/docker-dockerfile.html">Dockerfile</a>：用来构建镜像的文本文件，包含了一条条<strong>构建镜像</strong>所需的指令和说明；</li>
<li><a href="https://www.runoob.com/docker/docker-machine.html">Docker
Machine</a>：是一个简化 Docker
安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker；可以集中<strong>管理</strong>所有的
docker 主机，比如快速的给 100 台服务器安装上 docker；</li>
</ul>
<h1 id="常用命令">常用命令</h1>
<p>docker run &lt;IMAGE&gt; [COMMAND]
[ARG...]【创建一个新的容器并运行一个命令】</p>
<ul>
<li>[-d] 后台运行容器</li>
<li>[-p] 指定端口映射</li>
<li>[-v] 映射主机文件卷</li>
<li>[--name &lt;NAME&gt;] 命名容器</li>
<li>[-e] 设置环境变量</li>
</ul>
<p>docker ps [OPTIONS]【列出容器】</p>
<ul>
<li>[-a] 显示所有的容器，包括未运行的</li>
</ul>
<p>docker rm [OPTIONS] &lt;CONTAINER &gt;
【删除一个或多个已经停止的容器】</p>
<ul>
<li>[-f] 强制删除正在运行的容器</li>
<li>[-v] 删除容器挂载的卷</li>
</ul>
<p>docker build [OPTIONS] &lt;PATH&gt; 【创建镜像】</p>
<ul>
<li>[-f] 指定要使用的 Dockerfile 路径</li>
<li>[--rm] 设置镜像成功后删除中间容器</li>
</ul>
<p>docker save [OPTIONS] &lt;IMAGE&gt; 【将指定镜像保存成 tar
归档文件】</p>
<ul>
<li>[-o &lt;xxx.tar&gt;]</li>
</ul>
<p>docker load [OPTIONS] 【导入镜像】</p>
<ul>
<li>[-i &lt;xxx.tar&gt;] 指定导入的文件</li>
</ul>
<p>docker top [OPTIONS] &lt;CONTAINER&gt;
【查看容器中运行的进程信息，支持 ps 命令参数】</p>
<h1 id="实践">实践</h1>
<h2 id="如何容器化-java-应用">如何容器化 Java 应用</h2>
<p>Docker Compose：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span>  </span><br><span class="line"><span class="attr">services:</span>  </span><br><span class="line">  <span class="attr">db:</span>  </span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7</span>  </span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span>  </span><br><span class="line">    <span class="attr">environment:</span>  </span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">example</span>  </span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">mydb</span>  </span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">myuser</span>  </span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">mypassword</span>  </span><br><span class="line">    <span class="attr">ports:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3608:3306&quot;</span>  <span class="comment"># 将宿主机的 3608 端口映射到容器的 3306 端口  </span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">java-app:</span>  </span><br><span class="line">    <span class="attr">build:</span>  </span><br><span class="line">      <span class="attr">context:</span> <span class="string">.</span>  <span class="comment"># 假设 Dockerfile 在当前目录下  </span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span>  </span><br><span class="line">    <span class="attr">depends_on:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span>  </span><br><span class="line">    <span class="attr">environment:</span>  </span><br><span class="line">      <span class="attr">DB_HOST:</span> <span class="string">db</span>  <span class="comment"># Java 程序将连接到名为 &quot;db&quot; 的服务（即 MySQL 容器）  </span></span><br><span class="line">      <span class="attr">DB_PORT:</span> <span class="number">3306</span>  <span class="comment"># 在容器内部，MySQL 仍然监听 3306 端口  </span></span><br><span class="line">      <span class="attr">DB_USER:</span> <span class="string">myuser</span>  </span><br><span class="line">      <span class="attr">DB_PASSWORD:</span> <span class="string">mypassword</span>  </span><br><span class="line">      <span class="attr">DB_NAME:</span> <span class="string">mydb</span>  </span><br><span class="line">    <span class="attr">ports:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span>  <span class="comment"># 假设 Java 程序监听 8080 端口</span></span><br></pre></td></tr></table></figure>
<p>Dockerfile：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础镜像Java 8</span></span><br><span class="line">FROM java:8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制文件到工作目录</span></span><br><span class="line">COPY . /app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置Java环境变量</span></span><br><span class="line">ENV PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br><span class="line">ENV JRE_HOME=<span class="variable">$&#123;JAVA_HOME&#125;</span>/jre</span><br><span class="line">ENV CLASSPATH=.:<span class="variable">$&#123;JAVA_HOME&#125;</span>/lib:<span class="variable">$&#123;JRE_HOME&#125;</span>/lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行</span></span><br><span class="line">ENTRYPOINT [<span class="string">&#x27;/usr/lib/jvm/java-9-openjdk-amd64/bin/javac&#x27;</span>,<span class="string">&#x27;-jar&#x27;</span>,<span class="string">&#x27;app.jar&#x27;</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>容器虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 文档阅读</title>
    <url>/-2024/Git/</url>
    <content><![CDATA[<p><a href="https://git-scm.com/book/zh/v2">Git 中文文档</a></p>
<blockquote>
<p>有空可以看看这个 <a href="https://github.com/xirong/my-git">Git
笔记汇总</a></p>
</blockquote>
<span id="more"></span>
<img data-src="/-2024/Git/1352126739_7909.jpg" class="" title="img">
<h2 id="chapter-1-起步">Chapter 1 起步</h2>
<h3 id="版本控制">版本控制</h3>
<ol type="1">
<li>集中化版本控制（CVCS）缺点
<ol type="1">
<li>中央服务器的单点故障就无法协同工作</li>
<li>本地只有快照，项目整体和其变更历史只保存在服务器上</li>
</ol></li>
<li>分布式版本控制（DVCS）优点
<ol type="1">
<li>代码仓库完整地镜像下来，包括完整的历史记录</li>
<li>用户在本地保存了所有改动，每一次的克隆都是对仓库的完整备份</li>
<li>可以指定和若干不同的远端代码仓库进行交互</li>
</ol></li>
</ol>
<h3 id="git-简史">Git 简史</h3>
<ol type="1">
<li>并行开发</li>
<li>完全分布式</li>
<li>速度快</li>
<li>数据量大</li>
</ol>
<h3 id="git-简介">Git 简介</h3>
<ol type="1">
<li>大多版本控制工具都是基于差异的，存储文件随时间变化的差异，而Git储存项目快照或索引</li>
<li>Git 安全性优，只做增不做删；完整性好，使用SHA-1 哈希算法</li>
<li>文件的四种状态：已提交（committed）、已修改（modified）、已暂存（staged）、未跟踪（untracked）</li>
<li>项目的三个阶段：工作目录、暂存区域以及 Git 仓库</li>
<li>工作流程：修改文件、暂存文件、将暂存区文件快照永久存在Git目录</li>
</ol>
<h3 id="git-配置">Git 配置</h3>
<blockquote>
<p>git config --list --show-origin</p>
</blockquote>
<ol type="1">
<li>/etc/gitconfig 系统通用配置 git config --system</li>
<li>~/.gitconfig 当前用户配置 git config --global</li>
<li>.git/config 当前项目配置 git config --local</li>
</ol>
<h2 id="chapter-2-基础">Chapter 2 基础</h2>
<blockquote>
<p>Git命令只能控制当前文件夹和子文件夹内的修改</p>
</blockquote>
<h3 id="常用命令">常用命令</h3>
<p>git init 【初始化仓库】</p>
<p>git clone [OPTIONS] &lt;url&gt;【克隆仓库】</p>
<ul>
<li>[-b master]克隆指定分支</li>
</ul>
<p>git status [OPTIONS] 【查看文件状态 】</p>
<ul>
<li>[-s] 简要文件状态信息</li>
</ul>
<p>git add &lt;file&gt;
【跟踪新文件、已修改的文件放到暂存区、合并时把有冲突的文件标记为已解决状态
】</p>
<p>git diff [OPTIONS]
&lt;file&gt;【已修改文件与已暂存文件的内容差异】</p>
<ul>
<li>[--staged] 显示暂存区和上一次提交的差异</li>
</ul>
<p>git blame [OPTIONS]【追踪代码提交历史】</p>
<ul>
<li>[ -L 200,300 &lt;file&gt;] 追踪某些行代码修改的历史 commit</li>
</ul>
<p>git rm [OPTIONS] &lt;file&gt; 【删除文件】</p>
<ul>
<li>[-f] 强制移除存在未提交修改的文件</li>
<li>[ --cached] 文件保留在工作区中，从Git仓库和暂存区中删除</li>
</ul>
<p>git commit [OPTIONS] 【提交文件】 - [-m &lt;message&gt;] 提交备注 -
[--amend] 追加提交 - [-a] 直接将工作区和暂存区的所有修改一起提交</p>
<p>git mv &lt;oldfilename&gt; &lt;newfilename&gt; 【移动文件/改名】</p>
<p>git log [OPTIONS] 【回顾提交历史】 - [--stat] 显示每次提交的简要信息
- [-p] 显示每次提交的详细信息 - [--pretty=format:"xxx"] 自定义信息格式 -
[--oneline --graph --all]
显示提交历史、各个分支的指向以及项目的分支分叉情况 - [--since]
限制时间</p>
<p>git reset [OPTIONS]
&lt;HEAD&gt;【回退版本，可以指定退回某一次提交的版本，直接删除某些commit的内容】</p>
<ul>
<li>[--soft] 回退到某个版本</li>
<li>[--mixed]
默认，用于重置暂存区的文件与上一次的提交保持一致（取消暂存），工作区文件内容保持不变</li>
<li>[--hard]
撤销工作区中所有未提交的修改内容，将暂存区与工作区都回到上一次版本，并删除之前的所有信息提交</li>
</ul>
<p>git checkout
[OPTIONS]【在不同的分支之间切换、恢复文件、创建新分支，git switch 和 git
restore 可以代替它】</p>
<ul>
<li>[.] 放弃所有工作区的修改</li>
<li>[-f] 放弃工作区和暂存区的所有修改</li>
<li>[&lt;branch-name&gt;] 从当前分支切换到指定的分支</li>
<li>[-b &lt;local_new_branch_name&gt; &lt;remote_new_branch_name&gt;]
将远程仓库里指定的分支拉取到本地，并在本地创建一个分支与指定远程仓库分支关联起来,并切换到新建的本地分支中</li>
</ul>
<p>git remote [OPTIONS]
【列出当前仓库中已配置的<strong>远程仓库</strong>】</p>
<ul>
<li>[-v] 列出当前仓库中已配置的远程仓库，并显示它们的 URL</li>
<li>[add &lt;remote_name&gt; &lt;remote_url&gt;]
添加远程仓库，指定一个远程仓库的名称和 URL，将其添加到当前仓库中</li>
<li>[remane &lt;old_name&gt; &lt;new_name&gt;]
将已配置的远程仓库重命名</li>
<li>[show &lt;remote_name&gt;] 显示指定远程仓库的详细信息，包括 URL
和跟踪分支</li>
<li>[remove &lt;remote_name&gt;] 从当前仓库中删除指定的远程仓库</li>
<li>[<remote_name> <new_url>] 修改指定远程仓库的 URL</li>
</ul>
<p>git fetch &lt;remote_name&gt; &lt;local_branch_name&gt;
【获取远程仓库的更新，但不自动合并到你的工作】</p>
<ul>
<li>[--all] 获取远程的所有分支</li>
</ul>
<p>git push [OPTIONS]【推送到远程分支】</p>
<ul>
<li><p>[&lt;remote_name&gt;
&lt;local_branch_name&gt;:&lt;remote_branch_name&gt;]</p></li>
<li><p>[&lt;remote_name&gt; --delete &lt;branch_name&gt;]
删除远程分支</p></li>
<li><p>[-u &lt;remote_name&gt; --all]
本地的仓库和远程仓库进行关联</p></li>
<li><p>[--set-upstream &lt;remote_repository&gt;
&lt;local_branch_name&gt;] 将本地分支与远程分支关联</p></li>
<li><p>[--force] 强制提交，会覆盖所有 behind 的提交</p></li>
</ul>
<p>git pull &lt;remote_name&gt; &lt;branch&gt;【<code>git fetch</code>
和 <code>git merge</code> 的组合，拉取到本地分支并合并】</p>
<p>git tag [OPTIONS]【列出已有的标签】</p>
<ul>
<li>[-l &lt;通配符&gt;] 查询某些对应标签</li>
<li>[&lt;version&gt;] 轻量标签（提交校验和存储到一个文件中）</li>
<li>[-a &lt;version&gt; -m &lt;comment&gt;]
创建附注标签（数据库中的一个完整对象， 可以被校验）</li>
<li>[-d] 删除标签</li>
</ul>
<p>git rebase &lt;cur_branch&gt; &lt;target_branch&gt;
【将提交到某一分支上的所有修改都移至另一分支上】</p>
<p>git revert
&lt;commit_id&gt;【生成一次新的commit冲抵原来的commit，不会修改原有的提交历史，而是通过添加新的提交来撤销更改】</p>
<p>git merge &lt;branch&gt; 【合并指定分支到当前分支】</p>
<p>git switch [OPTIONS] &lt;branch-name&gt; 【切换分支，与 git checkout
类似，但提供了更清晰的语义和错误检查】</p>
<ul>
<li>[-c] 创建一个新分支并切换到该分支</li>
</ul>
<p>git show
【对于提交，它显示日志消息和文本差异；对于标签，它显示标签消息和引用对象】</p>
<p>git restore [OPTIONS] 【恢复或撤销文件的更改】 - [.]
还原所有未提交的更改 - [&lt;filename&gt;] 丢弃工作区修改 - [--staged
&lt;filename&gt;] 将暂存区的修改放回工作区 - [--source=&lt;commit&gt;
&lt;file&gt;] 将文件恢复到特定提交的状态</p>
<p>git branch [OPTIONS] 【查看本地分支】</p>
<ul>
<li>[&lt;branch_name&gt;] 创建本地分支</li>
<li>[-b &lt;branch_name&gt;] 创建本地分支并切换</li>
<li>[-v] 每个分支的最后一次提交</li>
<li>[-vv] 跟踪信息</li>
<li>[-r] 查看远程分支</li>
<li>[-D &lt;branch_name&gt;] 删除分支</li>
<li>[--set-upstream-to &lt;remotename&gt;/&lt;remote_branch&gt;
&lt;local_branch&gt;]
跟踪远程分支。在本地新建一个分支后，需要做远程分支关联，目的是在执行git
pull, git push操作时就不需要指定对应的远程分支</li>
<li>[--merged --no-merged] 合并/未合并到当前分支的其他分支</li>
<li>[-m &lt;old_branch_name&gt; &lt;new_branch_name&gt;] 改名</li>
</ul>
<p>git stash [OPTIONS] 【贮藏工作】</p>
<ul>
<li>[list] 列出所有贮藏</li>
<li>[apply] 恢复贮藏</li>
</ul>
<h3 id="忽略不跟踪文件">忽略/不跟踪文件</h3>
<p>.gitignore 正则表达式：<a
href="https://github.com/github/gitignore">官方样例文件</a></p>
<h2 id="chapter-3-分支">Chapter 3 分支</h2>
<blockquote>
<p>相关命令合并到 Chapter2 中</p>
</blockquote>
<ol type="1">
<li>Git 中 HEAD是一个指针，指向当前工作位置</li>
<li>git mergetool 图形化冲突解决工具</li>
<li>有 Git 特性演化出的开发工作流：长期分支、主题分支</li>
</ol>
<h3 id="变基">变基</h3>
<p>如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。只对尚未推送或分享给别人的本地修改执行变基操作清理历史，
从不对已推送至别处的提交执行变基操作。</p>
<p>工作原理：提取&lt;topicbranch&gt;内的修改并存为临时文件，然后将HEAD指向&lt;basebranch&gt;，最后以此将之前另存为临时文件的修改依序应用</p>
<h2 id="chapter-6-github">Chapter 6 GitHub</h2>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>版本管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 使用指南</title>
    <url>/-2024/Hexo/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://hexo.io/docs/">官方文档</a></p>
</blockquote>
<h1 id="常用命令">常用命令</h1>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>代码</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>快速部署</td>
<td>hexo g -d</td>
</tr>
<tr class="even">
<td>清除缓存</td>
<td>hexo clean</td>
</tr>
<tr class="odd">
<td>预览</td>
<td>hexo s</td>
</tr>
<tr class="even">
<td>部署</td>
<td>hexo d</td>
</tr>
<tr class="odd">
<td>生成静态页面</td>
<td>hexo generate</td>
</tr>
</tbody>
</table>
<h1 id="初始化配置">初始化配置</h1>
<p>初始化项目结构</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<p>新增标签页，设置属性（type: "tags"）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
<p>新增分类，设置属性（type: "categories"）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>
<p>配置 next 主题设置</p>
<ul>
<li>设置 menu 菜单栏</li>
<li>打开 code 代码复制</li>
</ul>
<p>Debug</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean --debug</span><br><span class="line">hexo s --debug</span><br></pre></td></tr></table></figure>
<p><strong>Git 上传插件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p><strong>latex 公式</strong></p>
<p>安装 <code>hexo-renderer-markdown-it-plus</code> 后，Katex 与 mathJax
会重复，需要在 next 中配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="string">none</span></span><br><span class="line"><span class="attr">katex:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">copy_tex:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p><strong>本地图片</strong></p>
<p><del>配置本地图片上传 <a
href="https://bkystop.github.io/2022/01/05/hexo-markdown%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/index.html">Link</a>
<a href="https://muxiner.github.io/organize-files/">Link</a></del></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-img --save  // 代替 hexo-asset-image</span><br></pre></td></tr></table></figure>
<p><strong>Markdown 文字高亮</strong></p>
<p><a
href="https://blog.csdn.net/qq_42951560/article/details/123596899">Link</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm un hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-markdown-it-plus --save</span><br></pre></td></tr></table></figure>
<p>_config.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">markdown:</span></span><br><span class="line">    <span class="attr">preset:</span> <span class="string">&quot;default&quot;</span></span><br><span class="line">    <span class="attr">plugins:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">markdown-it-mark</span></span><br></pre></td></tr></table></figure>
<p><strong>添加Sitemap</strong></p>
<p>为自己的网站配置sitemap，可以有效地提升SEO</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>
<p>并在站点配置文件<code>_config.yml</code>的末尾添加：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidusitemap.xml</span></span><br></pre></td></tr></table></figure>
<p><strong>改 blockquote 颜色</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">blockquote</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#d0a7020d</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">4px</span> solid <span class="number">#d0a702</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--blockquote-color);</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">15px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">cite</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">5px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="备份本地博客">备份本地博客</h1>
<p><a
href="https://blog.csdn.net/u014532291/article/details/131805350">利用mklink实现OneDrive自定义文件双向同步</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MKLINK [[/D] | [/H] | [/J]] Link Target</span><br><span class="line"></span><br><span class="line">        /D      创建目录符号链接。默认为文件符号链接。</span><br><span class="line">        /H      创建硬链接而非符号链接。</span><br><span class="line">        /J      创建目录联接。</span><br><span class="line">        Link    指定新的符号链接名称。</span><br><span class="line">        Target  指定新链接引用的路径</span><br><span class="line">                (相对或绝对)。</span><br></pre></td></tr></table></figure>
<p>管理员 PowerShell <code>cmd /c mklink /D 目标地址 源地址</code>
将博客<u>硬链接</u>到 OneDrive 文件夹下备份</p>
<h1 id="更新主题-next">更新主题 Next</h1>
<blockquote>
<p>由于 NexT 以前使用的 swig 模版引擎停止维护，去年迁移到了
Nunjucks，但是
目录下的模版文件后缀名没有更改。原因是修改后缀名影响太广，会使用户在执行
进行更新时产生大量的冲突。这次更换仓库为了解决这些历史遗留问题，没有保留之前的
commit 历史。</p>
</blockquote>
<p>2024.4.23 按照<a
href="https://theme-next.js.org/docs/getting-started/">官网</a>配置</p>
<h1 id="debug">DeBug</h1>
<p><a href="https://blog.csdn.net/liuergo/article/details/102640098">Git
提交文件名全变小写问题</a></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>如何保持专注</title>
    <url>/-2024/Stay-Focused/</url>
    <content><![CDATA[<p>磨刀不误砍柴工，弄明白如何做事比糊里糊涂的做更重要。当下的目标是通过不断<strong>实践试错</strong>并<strong>总结纠错</strong>，从而找到最适合我的高效专注的做事方法。在此，再以高中的座右铭激励自己：当你觉得为时已晚的时候，恰恰是最早的时候。从学生变成社会人、从孩子变成家庭支柱、从做事的变成管人的（总会有那天的啦），我还有很多要改进要学习的地方（如何清楚明确的表达自己的工作内容，如何高效明确的和别人沟通），这些变化不是为了适应社会的表演，而是成年人的责任。<del>（tmd这文字像是初中生写出来的，文化沙漠了属于是，有时间还是得多看看书捏）</del></p>
<blockquote>
<p>Thought is already is late, exactly is the earliest time.</p>
</blockquote>
<h1 id="启动">启动</h1>
<p>布置好工作环境，安排好工作内容，让自己发自内心得希望把事情完成。</p>
<ul>
<li><strong>早起，立即开始工作</strong>。早起会立即给自己一个潜意识的信号，让自己在那天努力工作。</li>
<li><strong>制定一个行动计划</strong>。用 10
分钟来筹划接下来的几个小时要做的事情，让事情可以推动自己前进。</li>
<li><strong>提前完成一连串的工作</strong>。清晨就处理完当天最紧要的工作，白天的时间就会显得从容，这也会产生积极的启动，这将持续一整天。</li>
</ul>
<h1 id="无干扰休息">无干扰休息</h1>
<p>休息可以帮助自己以新的方式思考问题，可以清醒头脑，从而重新集中注意力。无干扰的休息意味着休息不会扼杀你的动力，这样你就可以重新振作起来，而不会陷入拖延的弯路。</p>
<ul>
<li><strong>避免参与式的休息</strong>。短视频，游戏，微信等会占据头脑的东西都会打断做事的势头。</li>
<li><strong>专注于放松</strong>。走一小段路、喝一杯水或伸展身体都是不错的选择，可以很容易地从休息中抽身出来回去工作。</li>
</ul>
<p>休息不是为了玩得开心，这才是真正休息的目的。休息是关于战略性地恢复你的能量和注意力，以重新处理手头的工作。把电视、游戏和娱乐活动留给晚上可以无愧疚地放松的时候。</p>
<h1 id="积极工作">积极工作</h1>
<p>被动任务比主动任务更难集中注意力。改变这种状况的关键是，或者。</p>
<ul>
<li><strong>使任务处于活动状态</strong>。将被动学习任务转换为主动学习任务，如写提纲、记录重点。</li>
<li><strong>穿插活动任务</strong>。将被动学习与主动任务穿插在一起，以定期提高注意力，如表达自己见解、用自己的话复述一遍。</li>
</ul>
<blockquote>
<p><strong><a href="https://www.youtube.com/watch?v=FrNqSLPaZLc">Feynman
学习法</a></strong></p>
<p>Step1: choose your concept【写下你要学习的概念】</p>
<p>Step2: Pretend You're Teaching the ldea to a New
Student【假象你在教一位不懂这件事情的人这个概念，尝试将这件事情说明白】</p>
<p>Step3: If You Get Stuck, Go Back to the
Book【如果你在这个过程中遇到了困难，回到课本和视频中进一步学习】</p>
<p>Step4: Simplify and Create
Analogies【尝试精简自己的解释，并将其与其他概念做类比，从而更好地理解概念】</p>
<p>总结一下，当你可以教会某人一个ta完全不懂的概念的时候，说明你真正掌握了这个概念</p>
</blockquote>
<h1 id="固定日程安排">固定日程安排</h1>
<p>努力工作的最好方式就是拥有生活</p>
<ul>
<li><p><strong>保证休息</strong>，应对大量工作任务的办法是保证自己有休息时间。如果你白天不好好工作，却逼迫自己整夜学习的话，你很容易就会筋疲力尽的。无论压力再大任务再多，都要保证休息时间，一颗清醒的大脑决定了工作的质量。</p></li>
<li><p>使用时间分块法或每周/每日目标法，<strong>将工作和生活清晰地分离开</strong>，好好工作好好玩。</p></li>
</ul>
<blockquote>
<p><strong>时间分块法</strong></p>
<p>将一天分成更小的时间分块法。在每一段时间里，专注于一项任务或一组相似的任务。其重点是<strong>规划出需要完成的任务</strong>，然后<strong>划分特定的时间段专注完成这些任务</strong>。</p>
<p>当你把一整天分成时间段后，它会让你专注于任务，并限制其他人占用你的时间。</p>
<p>时间分块法让你每天都有一个要完成的具体任务的时间表，而不是遵循一个不断扩大的待办事项列表，你只需要关注于当下应该做的事情。</p>
</blockquote>
<p><a
href="https://www.scotthyoung.com/blog/2011/11/28/focus-without-caffeine/">Refer</a></p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>保持专注</tag>
      </tags>
  </entry>
</search>
