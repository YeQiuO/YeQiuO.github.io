<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ThreadPoolExecutor 和 CompletableFuture实践</title>
    <url>/JUC-ThreadPool/</url>
    <content><![CDATA[<p>池化思想，维护一个池子，减少创建/销毁的开销，合理分配系统资源，但会增加调度开销。<a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">参考美团技术博客</a>：底层设计思想、业务实现</p>
<h1 id="threadpoolexecutor-线程池实现类"><a class="markdownIt-Anchor" href="#threadpoolexecutor-线程池实现类"></a> ThreadPoolExecutor 线程池实现类</h1>
<h2 id="执行流程图"><a class="markdownIt-Anchor" href="#执行流程图"></a> 执行流程图</h2>
<img data-src="/JUC-ThreadPool/77441586f6b312a54264e3fcf5eebe2663494.png" class="" title="图2 ThreadPoolExecutor运行流程">
<p><strong>线程池生命周期</strong></p>
<img data-src="/JUC-ThreadPool/582d1606d57ff99aa0e5f8fc59c7819329028.png" class="" title="图3 线程池生命周期">
<p><strong>任务调度流程</strong></p>
<p>所有任务的调度都是由execute方法完成的，这部分完成的工作是：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。其执行过程如下：</p>
<ol>
<li>首先检测线程池运行状态，如果不是<code>RUNNING</code>，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。</li>
<li>如果<code>workerCount &lt; corePoolSize</code>，则创建并启动一个线程来执行新提交的任务。</li>
<li>如果<code>workerCount &gt;= corePoolSize，且线程池内的阻塞队列未满</code>，则将任务添加到该阻塞队列中。</li>
<li>如果<code>workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满</code>，则创建并启动一个线程来执行新提交的任务。</li>
<li>如果<code>workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满</code>, 则根据<u>拒绝策略</u>来处理该任务, 默认的处理方式是直接抛异常。</li>
</ol>
<img data-src="/JUC-ThreadPool/31bad766983e212431077ca8da92762050214.png" class="" title="图4 任务调度流程">
<h2 id="底层结构"><a class="markdownIt-Anchor" href="#底层结构"></a> 底层结构</h2>
<p><strong>ThreadPoolExecutor 构造函数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> corePoolSize,  //线程池的核心线程数量</span></span><br><span class="line"><span class="params">    <span class="type">int</span> maximumPoolSize,  //线程池的最大线程数</span></span><br><span class="line"><span class="params">    <span class="type">long</span> keepAliveTime,  //当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span></span><br><span class="line"><span class="params">    TimeUnit unit,  //时间单位</span></span><br><span class="line"><span class="params">    BlockingQueue&lt;Runnable&gt; workQueue,  //任务队列，用来储存等待执行任务的队列</span></span><br><span class="line"><span class="params">    ThreadFactory threadFactory,  //线程工厂，用来创建线程，一般默认即可</span></span><br><span class="line"><span class="params">    RejectedExecutionHandler handler  //拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span></span><br><span class="line"><span class="params">)</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p><strong>阻塞队列 <a href="https://juejin.cn/post/6999798721269465102">BlockingQueue</a></strong></p>
<p>阻塞队列中保存即将运行的任务，BlockingQueue 与 Queue 的主要区别是：</p>
<ul>
<li>通过在入队和出队时进行加锁，保证了队列线程安全</li>
<li>支持阻塞的入队和出队方法：当队列满时，会阻塞入队的线程，直到队列不满；当队列为空时，会阻塞出队的线程，直到队列中有元素。</li>
</ul>
<p>底层实现</p>
<ul>
<li>采用 ReentrantLock 同步队列实现加锁解锁、阻塞释放</li>
<li>队列为空或已满的情况，采用条件队列 Condition</li>
</ul>
<table>
<thead>
<tr>
<th>阻塞队列</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>ArrayBlockingQueue</td>
<td>有界队列</td>
</tr>
<tr>
<td>LinkedBlockingQueue</td>
<td>不设置大小的话，默认无界队列</td>
</tr>
</tbody>
</table>
<p><strong>创建线程工厂类 <u>ThreadFactory</u></strong></p>
<blockquote>
<p>参数可以设定线程名</p>
</blockquote>
<ul>
<li>java rt包：原生 ThreadFactory 类</li>
<li>hutool： ThreadFactoryBuilder</li>
<li>google guava.jar： ThreadFactoryBuilder</li>
</ul>
<p>自定义线程工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">testThreadPoolFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">threadIdx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String threadNamePrefix;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">testThreadPoolFactory</span><span class="params">(String Prefix)</span> &#123;</span><br><span class="line">        threadNamePrefix = Prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">        thread.setName(threadNamePrefix + <span class="string">&quot;-xxljob-&quot;</span> + threadIdx.getAndIncrement());</span><br><span class="line">        <span class="keyword">return</span> thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>任务拒绝策略</strong></p>
<blockquote>
<p>在使用线程池并且使用有界队列的时候，如果队列满了，任务添加到线程池的时候就会拒绝，具体的拒绝策略可以设定</p>
</blockquote>
<table>
<thead>
<tr>
<th>拒绝策略</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>AbortPolicy</td>
<td>线程池队列满了丢掉这个任务并且抛出RejectedExecutionException异常</td>
</tr>
<tr>
<td>DiscardPolicy</td>
<td>如果线程池队列满了，会直接丢掉这个任务并且不会有任何异常</td>
</tr>
<tr>
<td>DiscardOldestPolicy</td>
<td>如果队列满了，会将最早进入队列的任务删掉腾出空间，再尝试加入队列</td>
</tr>
<tr>
<td>CallerRunsPolicy</td>
<td>如果添加到线程池失败，那么主线程会自己去执行该任务</td>
</tr>
</tbody>
</table>
<p>自定义拒绝策略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRejectPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> &#123;</span><br><span class="line">        <span class="comment">//Sender是我的Runnable类，里面有message字段</span></span><br><span class="line">        <span class="keyword">if</span> (r <span class="keyword">instanceof</span> Sender) &#123;</span><br><span class="line">            <span class="type">Sender</span> <span class="variable">sender</span> <span class="operator">=</span> (Sender) r;</span><br><span class="line">            <span class="comment">//直接打印</span></span><br><span class="line">            System.out.println(sender.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程池实现接口"><a class="markdownIt-Anchor" href="#线程池实现接口"></a> 线程池实现接口</h2>
<img data-src="/JUC-ThreadPool/912883e51327e0c7a9d753d11896326511272.png" class="" title="图1 ThreadPoolExecutor UML类图">
<p>ExecutorService接口：（1）扩充执行任务的能力，补充可以为<strong>一个或一批异步任务</strong>生成 Future 的方法；（2）提供了<strong>管控线程池</strong>的方法，比如停止线程池的运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ExecutorService</span> <span class="keyword">extends</span> <span class="title class_">Executor</span> &#123;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//不再接受新任务，待所有任务执行完毕后关闭 ExecutorService  </span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//不再接受新任务，直接关闭 ExecutorService，返回没有执行的任务列表  </span></span><br><span class="line">    List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span>;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//判断ExecutorService是否关闭  </span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isShutdown</span><span class="params">()</span>;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//判断ExecutorService是否终止  </span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isTerminated</span><span class="params">()</span>;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//等待ExecutorService到达终止状态  </span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">awaitTermination</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当task执行成功的时候future.get()返回执行结果</span></span><br><span class="line">    &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//当task执行成功的时候future.get()返回result  </span></span><br><span class="line">    &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span>;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//当task执行成功的时候future.get()返回null  </span></span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//批量提交任务并获得他们的future，Task列表与Future列表一一对应  </span></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> <span class="keyword">throws</span> InterruptedException;  </span><br><span class="line"> </span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//批量提交任务并获得一个已经成功执行的任务的结果  </span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;  </span><br><span class="line">  </span><br><span class="line">    &lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>顶层接口 Executor ：<mark>将任务提交和任务执行进行解耦</mark>。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="comment">// 在未来的某个时间执行 command （方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否）</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="executors-线程池工厂类"><a class="markdownIt-Anchor" href="#executors-线程池工厂类"></a> Executors 线程池工厂类</h1>
<p><strong>FixedThreadPool 固定线程数</strong></p>
<p>运行中的 FixedThreadPool（未执行 shutdown()或 shutdownNow()）不会拒绝任务，在任务比较多的时候会导致 OOM（内存溢出）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img data-src="/JUC-ThreadPool/91ghx5ru0n.jpeg" class="" title="img">
<p><strong>SingleThreadExecutor 只有一个线程的线程池</strong>（FixedThreadPool  的特例）</p>
<p><strong>CachedThreadPool 根据需要创建新线程的线程池</strong></p>
<img data-src="/JUC-ThreadPool/ongsgtlllq.jpeg" class="" title="img">
<h1 id="completablefuture-异步执行结果类"><a class="markdownIt-Anchor" href="#completablefuture-异步执行结果类"></a> CompletableFuture 异步执行结果类</h1>
<blockquote>
<p>RxJava、Reactor 比 CompletableFuture 增加了操作融合、延迟执行、回压等特性</p>
</blockquote>
<p>CompletableFuture实现 Future、CompletionStage 接口。</p>
<p>Future表示异步<strong>计算的结果</strong>，CompletionStage用于表示异步执行过程中的一个<strong>步骤</strong>（Stage），这个步骤可能是由另外一个CompletionStage触发的，随着当前步骤的完成，也可能会触发其他一系列CompletionStage的执行。从而我们可以根据实际业务对这些步骤进行多样化的编排组合，CompletionStage接口正是定义了这样的能力，我们可以通过其提供的thenAppy、thenCompose等函数式编程方法来组合编排这些步骤。</p>
<h2 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h2>
<ul>
<li>Future 需要获取返回值，才能获取异常信息（即线程需要实现 <code>Callable</code> 接口，而 <code>Runnable</code> 接口创建线程不会返回结果或抛出检查异常）</li>
<li>CompletableFuture 的 get() 方法是阻塞等待的</li>
<li>异步调用强制传自定义线程池，做好线程池隔离</li>
<li>自定义线程池时，仔细考虑延迟队列满时，应采取什么拒绝策略</li>
</ul>
<p><strong>Q1</strong>：程序执行在哪个线程上？</p>
<p><strong>A1</strong>：</p>
<p>同步方法（即不带Async后缀的方法）有两种情况。</p>
<ul>
<li>
<p>如果注册时被依赖的操作已经执行完成，则直接由当前线程执行。</p>
</li>
<li>
<p>如果注册时被依赖的操作还未执行完，则由回调线程（按照当前 CF 运行情况区分）执行。</p>
</li>
</ul>
<p>异步方法（即带Async后缀的方法）：可以选择是否传递线程池参数Executor运行在指定线程池中；当不传递Executor时，会使用ForkJoinPool中的共用线程池CommonPool</p>
<p><strong>Q2</strong>：同步回调和异步回调的区别</p>
<p><strong>A2</strong>：</p>
<p>同步回调：把函数 b 传递给函数 a。执行 a 的时候，回调了 b，a 要一直等到 b 执行完才能继续执行；</p>
<p>异步回调：把函数 b 传递给函数 a。执行 a 的时候，回调了 b，然后 a 就继续往后执行，b 独自执行。</p>
<h3 id="线程池循环引用会导致死锁"><a class="markdownIt-Anchor" href="#线程池循环引用会导致死锁"></a> 线程池循环引用会导致死锁</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">doGet</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">ExecutorService</span> <span class="variable">threadPool1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">100</span>));</span><br><span class="line">  <span class="type">CompletableFuture</span> <span class="variable">cf1</span> <span class="operator">=</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">  <span class="comment">//do sth</span></span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;child&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;child&quot;</span>;</span><br><span class="line">      &#125;, threadPool1).join();<span class="comment">//子任务</span></span><br><span class="line">    &#125;, threadPool1);</span><br><span class="line">  <span class="keyword">return</span> cf1.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>threadPool1 大小为 10，当同一时刻有 10 个请求到达，则 threadPool1 被打满，子任务请求线程时进入阻塞队列排队，但是父任务的完成又依赖于子任务，这时由于子任务得不到线程，父任务无法完成。主线程执行 cf1.join() 进入阻塞状态，并且永远无法恢复。</p>
<h3 id="异步rpc调用注意不要阻塞io线程池"><a class="markdownIt-Anchor" href="#异步rpc调用注意不要阻塞io线程池"></a> 异步RPC调用注意不要阻塞IO线程池</h3>
<p>如果是使用基于 NIO（比如Netty）的异步 RPC，则返回结果是由 IO 线程负责设置的，即<mark>回调方法由 IO 线程触发</mark>，CompletableFuture 同步回调（如thenApply、thenAccept等无Async后缀的方法）如果依赖的异步 RPC 调用的返回结果，那么这些<mark>同步回调将运行在IO线程</mark>上，而整个服务只有一个IO线程池，这时需要<mark>保证同步回调中不能有阻塞等耗时过长的逻辑</mark>，否则在这些逻辑执行完成前，IO线程将一直被占用，影响整个服务的响应。</p>
<h2 id="实际使用场景"><a class="markdownIt-Anchor" href="#实际使用场景"></a> 实际使用场景</h2>
<blockquote>
<p><a href="https://tech.meituan.com/2022/05/12/principles-and-practices-of-completablefuture.html">美团技术博客</a></p>
</blockquote>
<p>服务端和客户端信息交换频繁，提升系统吞吐量</p>
<p>I/O密集型任务，对内<strong>调度</strong>各个下游服务获取数据进行<strong>聚合</strong></p>
<p>对业务流程进行编排，降低任务依赖导致的阻塞</p>
<p>避免 guava 的 ListenableFuture 回调所导致的回调地狱</p>
<h3 id="零依赖-构造方法"><a class="markdownIt-Anchor" href="#零依赖-构造方法"></a> 零依赖-构造方法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//1、使用runAsync或supplyAsync发起异步调用</span></span><br><span class="line">CompletableFuture&lt;String&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;result1&quot;</span>;</span><br><span class="line">&#125;, executor);</span><br><span class="line"><span class="comment">//2、CompletableFuture.completedFuture()直接创建一个已完成状态的CompletableFuture</span></span><br><span class="line">CompletableFuture&lt;String&gt; cf2 = CompletableFuture.completedFuture(<span class="string">&quot;result2&quot;</span>);</span><br><span class="line"><span class="comment">//3、先初始化一个未完成的CompletableFuture，然后通过complete()、completeExceptionally()，完成该CompletableFuture</span></span><br><span class="line">CompletableFuture&lt;String&gt; cf = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line">cf.complete(<span class="string">&quot;success&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="一元依赖-异步回调"><a class="markdownIt-Anchor" href="#一元依赖-异步回调"></a> 一元依赖-异步回调</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; cf3 = cf1.thenApply(result1 -&gt; &#123;</span><br><span class="line">  <span class="comment">//result1为CF1的结果</span></span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;result3&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">CompletableFuture&lt;String&gt; cf5 = cf2.thenApply(result2 -&gt; &#123;</span><br><span class="line">  <span class="comment">//result2为CF2的结果</span></span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;result5&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="二元依赖-多任务"><a class="markdownIt-Anchor" href="#二元依赖-多任务"></a> 二元依赖-多任务</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; cf4 = cf1.thenCombine(cf2, (result1, result2) -&gt; &#123;</span><br><span class="line">  <span class="comment">//result1和result2分别为cf1和cf2的结果</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;result4&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="多元依赖"><a class="markdownIt-Anchor" href="#多元依赖"></a> 多元依赖</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; cf6 = CompletableFuture.allOf(cf3, cf4, cf5);</span><br><span class="line">CompletableFuture&lt;String&gt; result = cf6.thenApply(v -&gt; &#123;</span><br><span class="line">  <span class="comment">//这里的join并不会阻塞，因为传给thenApply的函数是在CF3、CF4、CF5全部完成时，才会执行 。</span></span><br><span class="line">  result3 = cf3.join();</span><br><span class="line">  result4 = cf4.join();</span><br><span class="line">  result5 = cf5.join();</span><br><span class="line">  <span class="comment">//根据result3、result4、result5组装最终result;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;result&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="使用方法"><a class="markdownIt-Anchor" href="#使用方法"></a> 使用方法</h2>
<p><a href="https://zhuanlan.zhihu.com/p/647743286">方法汇总</a></p>
<h3 id="构造方法"><a class="markdownIt-Anchor" href="#构造方法"></a> 构造方法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用默认内置线程池ForkJoinPool.commonPool()，根据supplier构建执行任务  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span>  </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 自定义线程池，根据supplier构建执行任务  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span>  </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 使用默认内置线程池ForkJoinPool.commonPool()，根据runnable构建执行任务  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 自定义线程池，根据runnable构建执行任务  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable, Executor executor)</span>  </span><br></pre></td></tr></table></figure>
<h3 id="获取结果方法"><a class="markdownIt-Anchor" href="#获取结果方法"></a> 获取结果方法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span>  </span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span>  </span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">getNow</span><span class="params">(T valueIfAbsent)</span>  </span><br><span class="line"><span class="comment">// 不抛出异常 </span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">join</span><span class="params">()</span>  </span><br></pre></td></tr></table></figure>
<h3 id="异步回调方法"><a class="markdownIt-Anchor" href="#异步回调方法"></a> <strong>异步回调方法</strong></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行第二个任务时，则第二个任务和第一个任务是共用同一个线程池</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenRunAsync</span><span class="params">(Runnable action)</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 执行第二个任务时，使用给定的线程池</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenRunAsync</span><span class="params">(Runnable action, Executor executor)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个回调方法任务，会将该任务的执行结果，作为入参，传递到回调方法中，但是回调方法是没有返回值的</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action, Executor executor)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行第二个回调方法任务，会将第一个任务的执行结果，作为入参，传递到回调方法中，并且回调方法是有返回值的</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApplyAsync</span><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn)</span>;</span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApplyAsync</span><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn, Executor executor)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="异常处理方法"><a class="markdownIt-Anchor" href="#异常处理方法"></a> <strong>异常处理</strong>方法</h3>
<p>由于异步执行的任务在其他线程上执行，而异常信息存储在线程栈中，因此当前线程除非阻塞等待返回结果，否则无法通过try\catch捕获异常。CompletableFuture提供了异常捕获回调exceptionally，相当于同步调用中的try\catch。使用方法如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> WmOrderAdditionInfoThriftService wmOrderAdditionInfoThriftService;<span class="comment">//内部接口</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Integer&gt; <span class="title function_">getCancelTypeAsync</span><span class="params">(<span class="type">long</span> orderId)</span> &#123;</span><br><span class="line">    CompletableFuture&lt;WmOrderOpRemarkResult&gt; remarkResultFuture = wmOrderAdditionInfoThriftService.findOrderCancelledRemarkByOrderIdAsync(orderId);<span class="comment">//业务方法，内部会发起异步rpc调用</span></span><br><span class="line">    <span class="keyword">return</span> remarkResultFuture</span><br><span class="line">          .thenApply(result -&gt; &#123;<span class="comment">//这里增加了一个回调方法thenApply，如果发生异常thenApply内部会通过new CompletionException(throwable) 对异常进行包装</span></span><br><span class="line">      <span class="comment">//这里是一些业务操作</span></span><br><span class="line">        &#125;)</span><br><span class="line">      .exceptionally(err -&gt; &#123;<span class="comment">//通过exceptionally 捕获异常，这里的err已经被thenApply包装过，因此需要通过Throwable.getCause()提取异常</span></span><br><span class="line">         log.error(<span class="string">&quot;WmOrderRemarkService.getCancelTypeAsync Exception orderId=&#123;&#125;&quot;</span>, orderId, ExceptionUtils.extractRealException(err));</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionUtils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Throwable <span class="title function_">extractRealException</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">          <span class="comment">//这里判断异常类型是否为CompletionException、ExecutionException，如果是则进行提取，否则直接返回。</span></span><br><span class="line">        <span class="keyword">if</span> (throwable <span class="keyword">instanceof</span> CompletionException || throwable <span class="keyword">instanceof</span> ExecutionException) &#123;</span><br><span class="line">            <span class="keyword">if</span> (throwable.getCause() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> throwable.getCause();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> throwable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 CompletableFuture 的任务不论是正常完成还是出现异常它都会调用 <code>whenComplete</code> 这回调函数。</p>
<ul>
<li>正常完成：<code>whenComplete</code> 返回结果和上级任务一致，异常为 null；</li>
<li>出现异常：<code>whenComplete</code> 返回结果为 null，异常为上级任务的异常；</li>
</ul>
<h3 id="多任务组合回调方法"><a class="markdownIt-Anchor" href="#多任务组合回调方法"></a> <strong>多任务组合回调方法</strong></h3>
<p>thenCompose 可以用于组合多个CompletableFuture，将前一个任务的返回结果作为下一个任务的参数，它们之间存在着<strong>业务逻辑</strong>上的先后顺序，前后线程执行是同步的，前面阻塞后面不会执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenCompose</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span>;</span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenComposeAsync</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span> ;</span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenComposeAsync</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn, Executor executor)</span> ;</span><br></pre></td></tr></table></figure>
<p>thenCombine 第一个入参 CompletionStage 是异步的，合并结果的BiFunction是同步的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U,V&gt; CompletionStage&lt;V&gt; <span class="title function_">thenCombine</span> <span class="params">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> U,? extends V&gt; fn)</span>;</span><br></pre></td></tr></table></figure>
<p>applyToEither方法返回一个新的CompletionStage，当此阶段或另一个给定阶段正常完成时，将使用相应的结果作为所提供函数的参数来执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletionStage&lt;U&gt; <span class="title function_">applyToEither</span> <span class="params">(CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="built_in">super</span> T, U&gt; fn)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="底层代码"><a class="markdownIt-Anchor" href="#底层代码"></a> 底层代码</h2>
<img data-src="/JUC-ThreadPool/82aa288ea62d74c03afcd2308d302b6910425.png" class="" title="图10 CF基本结构">
<p>result 用于存储当前CF的结果，stack（Completion）表示当前CF完成后需要触发的依赖动作（Dependency Actions），去触发依赖它的CF的计算，依赖动作可以有多个（表示有多个依赖它的CF），以栈（Treiber stack）的形式存储，stack表示栈顶元素。</p>
<p><strong>观察者模式</strong>：依赖动作（Dependency Action）都封装在一个单独Completion子类中。CompletableFuture 中的每个方法都对应了图中的一个 Completion 的子类，Completion本身是<strong>观察者</strong>的基类。</p>
<img data-src="/JUC-ThreadPool/5a889b90d0f2c2a0f6a4f294b9094194112106.png" class="" title="图11 CF类图">
<p>一元依赖中的 thenApply 为例，举例“观察者模式”的设计思想</p>
<img data-src="/JUC-ThreadPool/f45b271b656f3ae243875fcb2af36a1141224.png" class="" title="图12 thenApply简图">
<p><strong>被观察者</strong></p>
<ol>
<li>每个CompletableFuture都可以被看作一个被观察者，其内部有一个Completion类型的链表成员变量stack，用来存储注册到其中的所有观察者。当被观察者执行完成后会弹栈stack属性，依次通知注册到其中的观察者。上面例子中步骤fn2就是作为观察者被封装在UniApply中。</li>
<li>被观察者CF中的result属性，用来存储返回结果数据。这里可能是一次RPC调用的返回值，也可能是任意对象，在上面的例子中对应步骤fn1的执行结果。</li>
</ol>
<p><strong>观察者</strong></p>
<p>CompletableFuture支持很多回调方法，例如thenAccept、thenApply、exceptionally等，这些方法接收一个函数类型的参数 f，生成一个 Completion 类型的对象（即观察者），并将入参函数 f 赋值给 Completion 的成员变量 fn，然后检查当前 CF 是否已处于完成状态（即result != null），如果已完成直接触发 fn，否则将观察者 Completion 加入到 CF 的观察者链 stack 中，再次尝试触发，如果被观察者未执行完则其执行完毕之后通知触发。</p>
<ol>
<li>观察者中的 dep 属性：指向其对应的 CompletableFuture，在上面的例子中 dep 指向 CF2。</li>
<li>观察者中的 src 属性：指向其依赖的 CompletableFuture，在上面的例子中 src 指向 CF1。</li>
<li>观察者 Completion 中的 fn 属性：用来存储具体的等待被回调的函数。这里需要注意的是<u>不同的回调方法</u>（thenAccept、thenApply、exceptionally等）<u>接收的函数类型也不同</u>，即fn的类型有很多种，在上面的例子中fn指向fn2。</li>
</ol>
<p><strong>Q1</strong>：为什么要在入栈前和入栈后都检查<code>result == null</code></p>
<p><strong>A1</strong>：因为查 result 和判断 result==null 是两个操作，CompletableFuture 没有对其加锁，若被观察者在这两个操作数之间完成，会导致观察者得不到通知</p>
<p><strong>Q2</strong>：当依赖多个CF时，观察者会被压入所有依赖的CF的栈中，每个CF完成的时候都会进行，那么会不会导致一个操作被多次执行呢 ？如下图所示，即当CF1、CF2同时完成时，如何避免CF3被多次触发。</p>
<img data-src="/JUC-ThreadPool/316ff338f8dab2826a5d32dfb75ffede4158.png" class="" title="图15 多次触发">
<p><strong>A2</strong>：CompletableFuture的实现是这样解决该问题的：观察者在执行之前会先通过CAS操作设置一个状态位，将status由0改为1。如果观察者已经执行过了，那么CAS操作将会失败，取消执行。</p>
<p>CompletableFuture 处理并行问题的整体流程图：</p>
<img data-src="/JUC-ThreadPool/606323a07fb7e31cb91f46c879d99b8d735272.gif" class="" title="图16 完整流程">
<p><strong>二元依赖</strong></p>
<p>thenCombine 操作表示依赖两个 CompletableFuture。其观察者实现类为 BiApply，如上图所示，BiApply 通过 src 和 snd 两个属性关联被依赖的两个 CF，fn 属性的类型为 BiFunction。与单个依赖不同的是，在依赖的CF未完成的情况下，thenCombine 会尝试将 BiApply 压入这两个被依赖的 CF 的栈中，每个被依赖的 CF 成时都会尝试触发观察者 BiApply，BiApply 会检查两个依赖是否都完成，如果完成则开始执行。这里为了解决重复触发的问题，同样用的是上一章节提到的 CAS 操作，执行时会先通过 CAS 设置状态位，避免重复触发。</p>
<img data-src="/JUC-ThreadPool/b969e49a7eedbd52b014f86e86dcd3fc49634.png" class="" title="图17 二元依赖数据结构">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 状态位 Status 定义于 ForkJoinTask 类中</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Completion</span> <span class="keyword">extends</span> <span class="title class_">ForkJoinTask</span>&lt;Void&gt; <span class="keyword">implements</span> <span class="title class_">Runnable</span>, AsynchronousCompletionTask&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ForkJoinTask</span>&lt;V&gt; <span class="keyword">implements</span> <span class="title class_">Future</span>&lt;V&gt;&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>多元依赖</strong></p>
<p>依赖多个CompletableFuture的回调方法包括<code>allOf</code>、<code>anyOf</code>，区别在于<code>allOf</code>观察者实现类为BiRelay，需要所有被依赖的CF完成后才会执行回调；而<code>anyOf</code>观察者实现类为OrRelay，任意一个被依赖的CF完成后就会触发。二者的实现方式都是将多个被依赖的CF构建成一棵平衡二叉树，执行结果层层通知，直到根节点，触发回调监听。</p>
<img data-src="/JUC-ThreadPool/cef5469b5ec2e67ecca1b99a07260e4e22003.png" class="" title="图18 多元依赖结构树">
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java并发</tag>
        <tag>Java线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发锁</title>
    <url>/JUC-Lock/</url>
    <content><![CDATA[<p>Java.util.concurrent 中有很多 Java 并发相关工具，例如 锁 <code>ReentrantLock</code>、线程 <code>Callable</code> <code>FutureTask</code>、信号量 <code>Semaphore</code>、共享锁 <code>CountDownLatch</code></p>
<p>此外 Java 原生的 <code>volatile</code> 和 <code>synchronized</code> 关键字也是并发编程的关键。</p>
<span id="more"></span>
<h1 id="synchronized-关键字"><a class="markdownIt-Anchor" href="#synchronized-关键字"></a> synchronized 关键字</h1>
<p>每个对象都有一个 monitor 对象于之关联，通过对象监视器 <code>monitor</code> 实现加锁和解锁，被锁住的区域是<code>临界区</code>域（就是被锁保护，线程间只能串行访问的代码）</p>
<p><a href="https://www.cnblogs.com/yescode/p/14474104.html#autoid-0-0-0"><strong>锁升级策略</strong></a>：（图有误，hashcode 占 32 位）</p>
<img data-src="/JUC-Lock/3230688-20231101142351434-473719587.png" class="" title="img">
<p>图中是对象头中的 MarkWord，指向线程栈中锁记录的指针 = 持有锁线程的 lockRecord 的指针，指向重量级锁的指针 = 指向 monitor 的指针（MarkWord 结构之所以搞得这么复杂，是因为需要节省内存，让同一个内存区域在不同阶段有不同的用处）</p>
<ul>
<li>偏向锁：只有一个线程持有锁，无竞争情况时，线程可以直接获得锁，没有额外的开销。CAS 修改 Markword 头信息，该操作一般不会撤销，以避免 CAS 开销。</li>
<li>轻量级锁：多个线程都是在不同的时间段来请求同一把锁时，JVM 会使用轻量级锁：通过 CAS 尝试获取锁，不阻塞线程。如果竞争失败直接会升级成重量级锁，升级过程会自旋尝试获取锁。</li>
<li>重量级锁：加锁的过程中，采用自适应自旋，避免直接阻塞线程。自旋失败才会阻塞线程并入队，阻塞操作<code>LockSupport.park</code>由操作系统来实现，性能消耗高。唤醒线程的策略见下图：（waitset 环形双向链表；cxq 栈；entrylist 双向链表）</li>
</ul>
<img data-src="/JUC-Lock/1240-17140467896205.webp" class="" title="img">
<p><strong>作用域</strong>：</p>
<ul>
<li>修饰实例方法，锁当前对象实例。原理是修饰方法的时候在字节码 flag 上标记 ACC_SYNCHRONIZED，在运行时常量池中通过 ACC_SYNCHRONIZED 标志来区分，这样 JVM 就知道这个方法是被 synchronized 标记的，于是在进入方法的时候就会进行执行争锁的操作，一样只有拿到锁才能继续执行。</li>
<li>修饰静态方法，锁当前类，会作用于所有实例</li>
<li>修饰代码块，程序指定锁什么</li>
</ul>
<p>概念：</p>
<ul>
<li>锁消除：将多次锁请求合并成一个请求，以降低短时间内大量锁请求、同步、释放带来的性能损耗</li>
<li>锁粗化：Java 虚拟机在 JIT 编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过锁消除，可以节省毫无意义的请求锁时间
<ul>
<li>.java -&gt; .class 字节码
<ul>
<li>Javac</li>
</ul>
</li>
<li>字节码 -&gt; 机器码
<ul>
<li>JIT（Just-in-time）动态(即时)编译</li>
<li>AOT（Ahead Of Time）运行前编译</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="reentrantlock-类"><a class="markdownIt-Anchor" href="#reentrantlock-类"></a> ReentrantLock 类</h1>
<p>属性：可重入锁、独占锁、公平锁/非公平锁</p>
<p>特点：可限时等待、可响应中断、可实现选择性通知</p>
<p>使用场景：阻塞队列 <code>ArrayBlockingQueue</code> <code>LinkedBlockingDeque</code></p>
<p>源码结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">    <span class="comment">// 同步控制器（指向公平锁或非公平锁）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;...&#125;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不公平锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 公平锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现 Lock 接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.lock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ReentrantLock</code>独占锁运行过程（可重入锁的 <code>state</code> 表示<mark>重入的次数</mark>，会大于1）</p>
<img data-src="aqs-exclusive-mode-acquire-lock.png" alt="AQS 独占模式获取锁" style="zoom:80%;" />
<p><strong>加锁失败阻塞</strong>的场景：<code>ReentrantLock</code>在CAS加锁失败之后会封装成一个<code>Node</code>类型的对象加入<code>CLH</code>队列中，然后调用<code>LockSupport.park(this)</code>进行阻塞。<code>LockSupport</code>是一个native方法实现的工具类，在hotspot源码中也是通过<code>mutex</code>来实现的。</p>
<p>与<code>synchronized</code>对比：</p>
<table>
<thead>
<tr>
<th>比较</th>
<th style="text-align:left">ReentrantLock</th>
<th>synchronized</th>
</tr>
</thead>
<tbody>
<tr>
<td>如何实现等待-唤醒？</td>
<td style="text-align:left">Condition 类 await/signal</td>
<td>Object 的 wait/notify</td>
</tr>
<tr>
<td>如何释放锁？</td>
<td style="text-align:left">需要手动释放锁</td>
<td>出代码块后自动释放</td>
</tr>
<tr>
<td>底层如何实现？</td>
<td style="text-align:left">API 实现</td>
<td>JVM 内部锁升级策略</td>
</tr>
<tr>
<td>是否可中断？</td>
<td style="text-align:left">可中断锁</td>
<td>不可中断锁</td>
</tr>
<tr>
<td>占用资源大不大？</td>
<td style="text-align:left">通过自旋<code>CAS</code>和<code>Unsafe.park/unpark</code>挂起唤醒线程</td>
<td>锁升级策略：轻量级锁自旋<code>CAS</code>不会阻塞挂起；重量级锁才会和<code>ReentrantLock</code>一样<code>park/unpark</code></td>
</tr>
</tbody>
</table>
<h1 id="abstractqueuedsynchronizer-抽象类"><a class="markdownIt-Anchor" href="#abstractqueuedsynchronizer-抽象类"></a> AbstractQueuedSynchronizer 抽象类</h1>
<p>利用 <mark>FIFO 双端队列</mark>和 <mark>Node 节点</mark>结构来维护等待获取资源的线程队列，确保了线程间的公平性和互斥性。闭锁、读锁、信号量</p>
<p>AQS 底层封装了线程的入队与出队、状态更新以及阻塞与唤醒等底层细节，实现类可以实现具体的资源控制逻辑（<code>tryAcquire(int)</code>、<code>tryRelease(int)</code>等方法）。</p>
<p><code>AbstractQueuedSynchronizer</code>（抽象队列同步器）源码结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span> &#123;</span><br><span class="line">    <span class="comment">// 表示锁的持有数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line">    <span class="comment">// 双向队列（链表实现）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line">    <span class="comment">// 本地方法 eg:unsafe.compareAndSwapInt</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line">    <span class="comment">// 封装线程的节点</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="comment">// 标识当前节点对应的等待状态（不非负数时，仅作为普通标识，下文有详细介绍）</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">        <span class="comment">// 共享锁：Semaphore、CountDownLatch</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        <span class="comment">// 独占锁：ReentrantLock</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 条件队列中，表示下一个节点</span></span><br><span class="line">        <span class="comment">// 同步队列中，表示当前节点想要获取的是排他锁还是共享锁</span></span><br><span class="line">        Node nextWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 条件队列，保存有触发条件的 Node，实现选择性通知</span></span><br><span class="line">    <span class="comment">// 作用类似于 Object 内置的监视器方法：wait notify notifyAll</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionObject</span> <span class="keyword">implements</span> <span class="title class_">Condition</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 超时中断</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">spinForTimeoutThreshold</span> <span class="operator">=</span> <span class="number">1000L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>父类 AbstractOwnableSynchronizer 代码结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractOwnableSynchronizer</span> &#123;</span><br><span class="line">    <span class="comment">// 持有独占锁的线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>等待队列中不直接存储线程对象，而是封装线程为 Node 类的对象，每个 Node 代表一个等待线程</li>
<li>waitStatus 状态枚举值（初始值为 0，表示初始化状态）【使用情况】
<ul>
<li><code>CANCELLED</code> 表示线程已经被<u>取消</u>【响应中断】</li>
<li><code>SIGNAL</code> 表示后继节点的线程需要被唤醒【同步队列】</li>
<li><code>CONDITION</code> 表示线程在条件队列中等待某个<u>条件</u>满足【条件队列】</li>
<li><code>PROPAGATE</code> 表示共享模式下的资源传播【共享锁】</li>
</ul>
</li>
<li>独占 / 共享锁
<ul>
<li>独占锁 tryAcquire-tryRelease</li>
<li>共享锁 tryAcquireShared-tryReleaseShared</li>
</ul>
</li>
</ul>
<p><strong>线程调度逻辑：</strong><br />
当线程尝试获取资源失败时，会创建一个<mark>Node节点</mark>并将当前线程包装进去，然后利用<mark>CAS算法</mark>将其安全地加入到<mark>等待队列的尾部</mark>，并阻塞。<a href="https://www.bilibili.com/video/BV1mP4y1i7Vm/?p=6&amp;spm_id_from=pageDriver">Link</a></p>
<style>.icxmghxpphds{zoom:67%;}</style><img data-src="/JUC-Lock/image-20240415164535374.png" class="icxmghxpphds" alt="image-20240415164535374">
<p>在释放资源时，AQS会根据资源管理策略从队列中选择合适的节点并唤醒对应线程。</p>
<p>采用<strong>模板方法设计模式：</strong></p>
<p>模板方法设计模式：抽象出步骤的执行顺序作为抽象方法，具体的实现方法交给子类实现。</p>
<p>自定义 <code>Synchronizer</code> 时需要重写几个 AQS 提供的钩子方法（通过钩子方法控制 <code>state</code> 为何值时代表加锁成功/失败、解锁成功/失败）：tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared、isHeldExclusively</p>
<h2 id="clh-锁"><a class="markdownIt-Anchor" href="#clh-锁"></a> CLH 锁</h2>
<blockquote>
<p>Craig, Landin, and Hagersten locks 实现线程<u>阻塞等待</u>以及<u>被唤醒时锁分配</u>的机制</p>
</blockquote>
<img data-src="/JUC-Lock/clh-queue-state.png" class="" title="CLH 队列">
<h2 id="locksupport"><a class="markdownIt-Anchor" href="#locksupport"></a> LockSupport</h2>
<p>操作 Node 中的 thread，实现线程的阻塞 <code>park</code> 和解除阻塞 <code>unpark</code> 。<a href="https://juejin.cn/post/7023021536231555086">Link</a></p>
<p>具体来说，操作”许可“（多次 unpark 也只能获取一次许可，不可叠加），底层通过<code>mutex</code>（互斥量）和<code>condition</code>（条件变量）实现。【<code>mutex</code>存在用户态和内核态的切换】</p>
<blockquote>
<table>
<thead>
<tr>
<th>Java 线程中断方法</th>
<th>方法意义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Thread.currentThread().interrupt()</code></td>
<td>将线程的状态置为&quot;中断&quot;</td>
</tr>
<tr>
<td><code>Thread.interrupted()</code></td>
<td>获取当前线程的中断状态，并且会清除线程的状态标记，静态方法</td>
</tr>
<tr>
<td><code>Thread.isInterrupted()</code></td>
<td>获取调用该方法的对象所表示的线程，不会清除线程的状态标记，实例方法阻塞和中断的区别？</td>
</tr>
</tbody>
</table>
<p>阻塞和中断的区别？</p>
</blockquote>
<h2 id="实现方法"><a class="markdownIt-Anchor" href="#实现方法"></a> 实现方法</h2>
<p>Lock 接口（ReentrantLock 通过 Sync 实现接口）</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>lock(): void</td>
<td>加锁（ReentrantLock 默认不可响应中断）</td>
</tr>
<tr>
<td>lockInterruptibly(): void</td>
<td>加锁，阻塞等待锁的过程中，可以相应中断</td>
</tr>
<tr>
<td>tryLock(): boolean</td>
<td>非阻塞获取锁</td>
</tr>
<tr>
<td>tryLock(long, TimeUnit): boolean</td>
<td>时间段内获取锁</td>
</tr>
<tr>
<td>unlock(): void</td>
<td>解锁</td>
</tr>
<tr>
<td>newCondition(): Condition</td>
<td>获取条件等待队列</td>
</tr>
</tbody>
</table>
<h2 id="如何区分公平锁和非公平锁"><a class="markdownIt-Anchor" href="#如何区分公平锁和非公平锁"></a> 如何区分公平锁和非公平锁</h2>
<p><code>AbstractQueuedSynchronizer.hasQueuedPredecessors()</code> 线程在获取锁前，先判断一下自己在不在队列的首位，只有队首线程能被运行</p>
<h1 id="semaphore"><a class="markdownIt-Anchor" href="#semaphore"></a> Semaphore</h1>
<p>信号量，可选择公平 / 非公平锁。</p>
<p>通常用于那些资源有明确访问数量限制的场景，比如限流（仅限于单机模式，实际项目中推荐使用 Redis +Lua 来做限流）</p>
<h1 id="countdownlatch"><a class="markdownIt-Anchor" href="#countdownlatch"></a> CountDownLatch</h1>
<p>倒计时器：<code>await()</code>阻塞当前线程，当 <code>count</code>为零（即 state）时，唤醒所有被阻塞的线程。</p>
<p><code>CountDownLatch</code> 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 <code>CountDownLatch</code> 使用完毕后，它不能再次被使用</p>
<h1 id="cyclicbarrier"><a class="markdownIt-Anchor" href="#cyclicbarrier"></a> CyclicBarrier</h1>
<p>循环栅栏：让<mark>一组线程</mark>到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程都会继续干活。</p>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java并发</tag>
        <tag>Java并发锁</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 虚拟机</title>
    <url>/JVM/</url>
    <content><![CDATA[<blockquote>
<p>《深入理解 <a href="https://link.zhihu.com/?target=http%3A//www.shaoqun.com/s/Java.aspx">Java</a> 虚拟机 - <a href="https://link.zhihu.com/?target=http%3A//www.shaoqun.com/s/JVM.aspx">JVM</a> 高级特性与最佳实践》</p>
</blockquote>
<p>TODO虚拟机器执行子系统、GC、内存区域、调优</p>
<h1 id="内存结构"><a class="markdownIt-Anchor" href="#内存结构"></a> 内存结构</h1>
<p><a href="https://blog.csdn.net/xiaojin21cen/article/details/104267301">方法区、永久代（PermGen space）、元空间（Metaspace）的关系</a></p>
<img data-src="/JVM/image-20240429094145753.png" class="" title="image-20240429094145753">方法区
<ul>
<li>主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出</li>
<li>方法区是 JVM 的规范，元空间是 HotSpot 虚拟机在 Java8 具体实现的方法区（JDK8 之前是永久代）</li>
</ul>
<p>Metaspace（元空间）替换 PermGen（永久代）的原因</p>
<blockquote>
<p>永久代存储在虚拟机堆中，元空间存储在本地内存中</p>
</blockquote>
<ul>
<li>字符串存在永久代中，不方便管理维护，需要单独进行垃圾管理</li>
<li>类及方法的信息等比较难确定其大小，因此难以指定永久代的大小，太小容易出现永久代溢出，太大则容易导致老年代溢出</li>
<li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低</li>
<li>和其他虚拟机架构看齐，方便合并</li>
</ul>
<p>静态变量和基本数据类型包装类的常量池存在哪里？</p>
<ul>
<li>jdk1.6 及之前静态变量和 String Table 在永久代方法区</li>
<li>jdk1.8后 运行时常量池和静态变量在元空间，<strong>字符串常量池在堆空间</strong></li>
</ul>
<p>运行时常量池</p>
<ul>
<li>存储常量、引用、整数和浮点数等内存区域，是类加载后的第一个创建的内存区域，并且在整个 JVM 进程中共享</li>
<li>常量池中的内容是不可变的，可以通过符号引用进行共享，从而避免内存浪费</li>
</ul>
<p>方法区：全局，所有栈都可以访问</p>
<ul>
<li>static、ClassLoader</li>
</ul>
<h2 id="jvm-内存区域"><a class="markdownIt-Anchor" href="#jvm-内存区域"></a> JVM 内存区域</h2>
<p>线程私有的</p>
<ul>
<li>程序计数器（当前线程执行位置；依次读取代码）</li>
<li>本地方法栈（存储栈帧：局部变量表【值、引用指针、句柄】、操作数栈、动态链接【当一个方法要调用其他方法，将常量池中指向方法的符号引用转化为其在内存地址中的直接引用】、方法返回地址）</li>
<li>虚拟机栈</li>
</ul>
<p>线程共享的</p>
<ul>
<li>方法区（元空间、永久代）当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等数据。（运行时常量池：即各种字面量和符号引用【解析阶段：JVM 将符号引用转为直接引用】）</li>
<li>堆（字符串常量池【<a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html">String#intern</a>】、静态变量）</li>
<li>本地内存</li>
</ul>
<h2 id="对象的创建过程"><a class="markdownIt-Anchor" href="#对象的创建过程"></a> 对象的创建过程</h2>
<img data-src="/JVM/1161857-20200427141816383-595743373.png" class="" title="img">
<p><strong>对象的创建过程</strong></p>
<ol>
<li>查找常量池中是否有类的符号引用</li>
<li>分配内存：指针碰撞 OR 空闲列表（保证线程安全：CAS + 失败重试 OR TLAB）</li>
<li>初始化零值</li>
<li>设置对象头：元数据信息、对象的哈希码、对象的 GC 分代年龄、是否启用偏向锁</li>
<li>执行 init 方法</li>
</ol>
<img data-src="/JVM/1161857-20200427171615978-465618542.png" class="" title="img">
<h2 id="对象访问定位"><a class="markdownIt-Anchor" href="#对象访问定位"></a> 对象访问定位</h2>
<p>通过栈上的 引用指针 Reference 来操作堆上的具体对象：句柄、直接指针</p>
<ul>
<li>Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。在对象被移动时（垃圾收集时移动对象是非常普遍的行为）只会改变句柄中的实例数据指针。</li>
</ul>
<style>.zqnrdpvbutiz{zoom:50%;}</style><img data-src="/JVM/image-20240429100643112.png" class="zqnrdpvbutiz" alt="image-20240429100643112">
<ul>
<li>直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销，HotSpot 采用的是直接指针</li>
</ul>
<style>.zdygavkbjfeu{zoom:50%;}</style><img data-src="/JVM/image-20240429100908916.png" class="zdygavkbjfeu" alt="image-20240429100908916">
<h2 id="对象的内存布局"><a class="markdownIt-Anchor" href="#对象的内存布局"></a> 对象的内存布局</h2>
<p>Mark Word 是一个具有动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。</p>
<img data-src="/JVM/1161857-20200427173120968-675206595.png" class="" title="img">
<h1 id="gc-堆"><a class="markdownIt-Anchor" href="#gc-堆"></a> GC 堆</h1>
<p>新生代 Young Generation</p>
<ul>
<li>Eden 区【新建对象分配地址】</li>
<li>两个 Survivor 区 S0 和 S1 【survivor 的阈值年龄取小（占用超过一半 s 区的年龄，MaxTenuringThreshold）】</li>
</ul>
<p>老生代 Old Generation</p>
<p>HotSpot VM 的实现里的 GC 其实准确分类只有两大种：</p>
<p>部分收集 (Partial GC)：</p>
<ul>
<li>
<p>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</p>
</li>
<li>
<p>老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</p>
<ul>
<li>触发条件：老年代空间不足、方法区空间不足</li>
</ul>
</li>
<li>
<p>混合收集（Mixed GC）：</p>
</li>
</ul>
<h1 id="垃圾回收"><a class="markdownIt-Anchor" href="#垃圾回收"></a> 垃圾回收</h1>
<h2 id="gc-root"><a class="markdownIt-Anchor" href="#gc-root"></a> GC Root</h2>
<p>虚拟机栈、本地方法栈、方法区中类静态属性、方法区中常量、JNI 引用的对象</p>
<p>被同步锁持有的对象</p>
<p><strong>记忆集与卡表</strong>：</p>
<p>记忆集是一种用于记录从<strong>非收集区域指向收集区域的指针集合</strong>的抽象数据结构。在垃圾收集的场景中，收集器只需要通过记忆集判断出<strong>某一块非收集区域是否存在有指向了收集区域的指针</strong>，并不需要了解这些跨代指针的全部细节。老年代划分为若干个小块，标识出老年代哪一块内存会存在跨代引用。当发生 Minor GC 时，只有包含了跨代引用的小块内存中的老年代对象才会加入到 GC Roots 扫描中，避免整个老年代加入到 GC Roots 中</p>
<h2 id="垃圾收集算法"><a class="markdownIt-Anchor" href="#垃圾收集算法"></a> 垃圾收集算法</h2>
<table>
<thead>
<tr>
<th>垃圾收集算法</th>
<th>优点</th>
<th>缺点</th>
<th>适用范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>标记清除法</td>
<td>不需要移动对象，简单高效</td>
<td>标记效率低（访问全部内存）内存碎片</td>
<td>老年代</td>
</tr>
<tr>
<td>标记复制算法</td>
<td>无内存碎片</td>
<td>频繁复制；内存使用率低</td>
<td>新生代</td>
</tr>
<tr>
<td>标记整理法</td>
<td>结合了上面两个优点</td>
<td>移动局部对象</td>
<td>老年代</td>
</tr>
<tr>
<td>分代收集算法</td>
<td>根据对象存活概率，选择垃圾收集算法</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="垃圾回收器"><a class="markdownIt-Anchor" href="#垃圾回收器"></a> 垃圾回收器</h2>
<p>GCRoot：栈帧中引用的对象、静态变量、常量、本地方法栈中对象<br />
STW：Stop the World</p>
<table>
<thead>
<tr>
<th>Young GC</th>
<th>Old GC</th>
</tr>
</thead>
<tbody>
<tr>
<td>Serial 串行、标记-复制</td>
<td>Serial Old 标记-整理（STW）</td>
</tr>
<tr>
<td>PawNew 并行、标记-复制</td>
<td>CMS 降低单次垃圾收集时间</td>
</tr>
<tr>
<td>Parallel Scavenge 吞吐率</td>
<td>Parallel Old</td>
</tr>
</tbody>
</table>
<img data-src="/JVM/1712545820562-e5255e3e-762c-44b8-a179-1cca4068b847.png" class="" title="image.png">
<h3 id="cms"><a class="markdownIt-Anchor" href="#cms"></a> CMS</h3>
<blockquote>
<p>以获得最短回收停顿时间为目标的收集器</p>
</blockquote>
<p>流程</p>
<ul>
<li>初次标记 STW：标记直接与 root 相连的对象</li>
<li>并发标记：标记可达对象，跟踪更新记录</li>
<li>重新标记 STW：修正并发标记的变动</li>
<li>并发清理：标记-清理（不用 STW，但清理会产生内存碎片，复制不会）</li>
</ul>
<p>优点</p>
<ul>
<li>并发收集、低停顿</li>
</ul>
<p>缺点</p>
<ul>
<li>对 CPU 资源敏感；</li>
<li>无法处理浮动垃圾；</li>
<li>它使用的回收算法“标记-清除”算法会导致收集结束时会有大量空间碎片产生，过量碎片会导致 Full GC；</li>
<li>并发失败：并发清理的时候用户线程没有足够的 JVM 内存，会导致 STW 并产生内存碎片</li>
</ul>
<h3 id="g1"><a class="markdownIt-Anchor" href="#g1"></a> <a href="https://github.com/sunwu51/notebook/blob/master/19.09/java_jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.md">G1</a></h3>
<blockquote>
<p>G1 跟踪每个区域的垃圾大小，在后台维护一个优先级列表，每次根据允许的收集时间，优先回收价值最大的区域，已达到在有限时间内获取尽可能高的回收效率</p>
</blockquote>
<img data-src="/JVM/image-20240429095131808.png" class="" title="image-20240429095131808">
<p>内存结构</p>
<ul>
<li>Region 大小 1M~32M、个数大概 2000</li>
<li>&gt;=0.5 Region &lt;1Region：H 区（超大对象存储区）</li>
<li>&gt;1Region：多个连续存储区</li>
</ul>
<p>概念</p>
<ul>
<li>RememberSets，又叫 Rsets 是每个 region 中都有的一份存储空间，用于存储本 region 的对象被其他 region 对象的引用记录</li>
<li>CollectionSets，又叫 Csets 是一次 GC 中需要被清理的 regions 集合，注意G1每次 GC 不是全部 region 都参与的，可能只清理少数几个，这几个就被叫做 Csets</li>
</ul>
<p><a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html">Young GC</a> 复制清理的过程</p>
<img data-src="/JVM/image-20240429095142614.png" class="" title="image-20240429095142614">
<p>MixGC（没有 Old GC 的概念，新老代一起 GC)类似于 CMS</p>
<ul>
<li>初次标记 STW：标记直接与 GCRoot 相连的对象，和该对象所处的 Region(RootRegion)</li>
<li>扫描 RootRrgion：遍历 old Region，如果 rset 中存在 RootRegion，则标记（即为可达的 Region）</li>
<li>并发标记：同 CMS，但仅遍历标记的 Region</li>
<li>重新标记 STW：SATB 算法</li>
<li>筛选回收 STW：局部的标记整理垃圾收集</li>
</ul>
<img data-src="/JVM/image-20240429095150787.png" class="" title="image-20240429095150787">
<p>对比CMS，有哪些不同？</p>
<ul>
<li>region化的内存结构，采用复制清理的方式，避免了内存碎片。但是这种清理也造成了STW</li>
<li>SATB速度更快</li>
<li>初始标记，并发标记，重新标记，清理垃圾四个阶段很像，但是G1中有很多标记region的操作，并借助Rset进行了范围的缩小，提高了并发标记的速度。小结下就是初始标记和YGC的STW一起了，提高了效率；并发标记因为rset的设计，扫描范围缩小了，提高了效率；重新标记因为使用了SATB提高了效率；清理虽然造成了STW，但是复制使内存紧凑，避免了内存碎片。同时只清理垃圾较多的region，最大限度的降低了STW时间</li>
</ul>
<img data-src="/JVM/image-20240429095159588.png" class="" title="image-20240429095159588">
<p>GC 回收，针对堆内存<br />
GC 回收问题：<a href="https://heapdump.cn/article/1661497">YGC</a>、<a href="https://heapdump.cn/article/1870333">FGC</a></p>
<h1 id="类加载过程"><a class="markdownIt-Anchor" href="#类加载过程"></a> 类加载过程</h1>
<p><strong>类的生命周期</strong>：加载、连接、初始化、使用、卸载</p>
<style>.ngoxkqtorxcl{zoom:67%;}</style><img data-src="/JVM/image-20240429095206248.png" class="ngoxkqtorxcl" alt="image-20240429095206248">
<ul>
<li>加载：通过全类名获取定义此类的二进制字节流；将字节流所代表的静态存储结构转换为方法区的运行时数据结构；在内存中生成一个代表该类的 <code>Class</code> 对象，作为方法区这些数据的访问入口；【通过类加载器实现加载，通过双亲委派模型决定采用哪个类加载器】</li>
<li>验证：确保 Class 文件的字节流中包含的信息无误</li>
<li>准备：分配内存并设置类变量初始值</li>
<li>解析：将常量池内的<strong>符号引用替换为直接引用</strong>，也就是得到类或者字段、方法在内存中的指针或者偏移量；</li>
<li>初始化：执行字节码中的构造器来初始化类</li>
</ul>
<h1 id="类加载器"><a class="markdownIt-Anchor" href="#类加载器"></a> 类加载器</h1>
<blockquote>
<p>负责加载类的对象，主要作用就是加载 Java 类的字节码（ .class 文件）到 JVM 中（在内存中生成一个代表该类的 Class 对象）；</p>
</blockquote>
<p>将“通过类的全限定名获取描述类的二进制字节流”这件事放在虚拟机外部，由应用程序自己决定如何实现；</p>
 <img data-src="/JVM/image-20240429095212841.png" class="" title="image-20240429095212841">（启动类加载器：虚拟机的一部分)
<h2 id="双亲委派模型"><a class="markdownIt-Anchor" href="#双亲委派模型"></a> 双亲委派模型</h2>
<blockquote>
<p>决定类由哪个类加载器加载<br />
编程思想：在面向对象编程中，有一条非常经典的设计原则：组合优于继承，多用组合少用继承（即双亲委派的实现方法）</p>
</blockquote>
<ul>
<li>ClassLoader 类使用委托模型来搜索类和资源。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。
<ul>
<li>获取该类的类加载器getClassLoader()方法；获取父类的类加载器getParent()</li>
</ul>
</li>
<li>ClassLoader 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。</li>
</ul>
<p><strong>为什么用双亲委派？</strong></p>
<ul>
<li>相同二进制名称的类只会被加载一次，已经加载的类会被放在 ClassLoader 中，防止重复加载；</li>
<li>保证了 Java 的核心 API 不被篡改；</li>
</ul>
<p><strong>为什么打破双亲委派？</strong></p>
<ul>
<li>Tomcat 下 Web 应用之间的类需要实现隔离，打破双亲委派可以更好地管理多个Web应用程序的类加载，并避免类加载冲突。</li>
<li>SPI 的接口是由 Java 核心库提供的（BootstrapClassLoader），SPI 的实现是由第三方供应商提供的（AppClassLoader），实现类无法通过接口的加载器加载</li>
</ul>
<p>ClassLoader 抽象类：</p>
<ul>
<li>loadClass(String name, boolean resolve) ：父类的加载器不为空，则通过父类的loadClass来加载该类。如果要打破双亲委派机制，就重写这个方法；</li>
<li>findClass(String name)：当父类加载器无法加载时，根据类的二进制名称来加载该类；</li>
</ul>
<p><a href="https://javaguide.cn/java/jvm/classloader.html#%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E6%96%B9%E6%B3%95">线程上下文类加载器</a></p>
<ul>
<li>类加载器保存在线程私有数据里，跟线程绑定。解决了，默认情况下一个类及其依赖类由同一个类加载器加载，而接口的类加载器和子类或实现类的加载器不是同一个加载器。</li>
</ul>
<h1 id="jvm-调优"><a class="markdownIt-Anchor" href="#jvm-调优"></a> JVM 调优</h1>
<p>配置Java堆和元空间大小</p>
<p>选择垃圾回收器：CMS 升级到 G1，甚至 ZGC。</p>
<p>JVM性能监控和调试，分析堆内存状态，合理优化代码</p>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 算法汇总</title>
    <url>/Java-Algorithm/</url>
    <content><![CDATA[<h1 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法</h1>
<h2 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h2>
<blockquote>
<p>思路</p>
<ul>
<li>确定dp数组（dp table）以及下标的含义</li>
<li>确定递推公式</li>
<li>dp数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ul>
</blockquote>
<h3 id="0-1背包"><a class="markdownIt-Anchor" href="#0-1背包"></a> 0-1背包</h3>
<blockquote>
<p>每个物品只能用一次</p>
</blockquote>
<p>下标含义：dp[物品 i ][容量 j ] 。如果 物品价值==物品种类，dp数组可以直接用 boolean[][]，不相等用 int[][]</p>
<p>状态转移方程：<code>dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]]</code></p>
<p>初始化：物品 0 和容量 0 的情况</p>
<p>遍历顺序：二维数组先遍历物品和容量都可以，一维数组只能先遍历容量</p>
<h3 id="树形-dp"><a class="markdownIt-Anchor" href="#树形-dp"></a> 树形 dp</h3>
<p>题型：<strong>树的直径</strong></p>
<p>思路：可以看作是再求树的深度，在求深度的同时“更新树的最长直径”。</p>
<p>代码模板</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LongestPath</span> &#123;</span><br><span class="line">    List&lt;Integer&gt;[] g;</span><br><span class="line">    <span class="type">int</span> <span class="variable">longestPath</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 两种思路：1.记录最大和次大长的路径；2.记录最大长 max，max+当前结果 和 result 比大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> child:g[x]) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> dfs(child) + <span class="number">1</span>;</span><br><span class="line">            longestPath = Math.max(longestPath, max + cur);</span><br><span class="line">            max = Math.max(max, cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] relate = &#123;-<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;  <span class="comment">// 边的关系(题目给出)</span></span><br><span class="line">        <span class="comment">// 构建关系，List 存儿子节点，可以拓展到一般树的情况</span></span><br><span class="line">        g = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[relate.length];</span><br><span class="line">        Arrays.setAll(g, e -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;relate.length; i++) &#123;</span><br><span class="line">            g[relate[i]].add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        System.out.println(longestPath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拓展：</p>
<ul>
<li>【124】求二叉树中最大的路径和。改左右子树的深度为节点值的和，若和为负数则返回 0</li>
<li>【2245】一般树的最长路径。遍历所有邻居（过滤掉父节点），取最长、次长两条路径相加，结果为最长路径。此外，根据题意还要去除父子结点相同的情况。</li>
</ul>
<p>题型：<strong>树上最大独立集</strong>（从图中选择尽量多的点，使得这些点互不相邻）</p>
<p>题型：<strong>树上最小支配集</strong>（从图中选择尽量少的点，使得这些点和其父子结点包括了整棵树）</p>
<h3 id="二维-dp"><a class="markdownIt-Anchor" href="#二维-dp"></a> 二维 dp</h3>
<p>题型：最长公共子序列</p>
<p>思路：定义 <code>dp[i][j]</code> 表示 <code>text1[0:i-1]</code> 和 <code>text2[0:j-1]</code> 的最长公共子序列</p>
<h2 id="前缀和"><a class="markdownIt-Anchor" href="#前缀和"></a> 前缀和</h2>
<blockquote>
<p>应用题型：连续子数组</p>
</blockquote>
<h2 id="并查集"><a class="markdownIt-Anchor" href="#并查集"></a> 并查集</h2>
<blockquote>
<p>应用题型：检查树是否连通；构造最小生成树</p>
<p>扩展：带权并查集</p>
</blockquote>
<p>数据结构模板</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] tab;</span><br><span class="line">    Node (<span class="type">int</span> size) &#123;</span><br><span class="line">        <span class="built_in">this</span>.tab = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i==tab[i] ? i : (tab[i] = find(tab[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        tab[find(x)] = find(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="java-技巧"><a class="markdownIt-Anchor" href="#java-技巧"></a> Java 技巧</h1>
<p>强制类型转换</p>
<ul>
<li>向零截断，直接保留整数位 <code>1/2 == -1/2 == 0</code></li>
</ul>
<p>基本数据类型的默认值</p>
<ul>
<li>int \ double：0</li>
<li>boolean：false</li>
</ul>
<p>常量池</p>
<ul>
<li>包装类型常量池：Byte, Short, Integer [-128,127], Long, Character, Boolean</li>
<li>字符串常量池</li>
</ul>
<p>初始化</p>
<ul>
<li>成员变量（定义在类里方法外的变量）一定要进行初始化的，如果不显式的进行初始化，那么虚拟机会进行默认的初始化
<ul>
<li>基本数据类型一般是给予默认值</li>
<li>引用类型初始值为 null</li>
</ul>
</li>
<li>局部变量不会自动初始化，所以在声明局部变量时要注意，可以不在声明时初始化，但在使用之前一定要进行初始化，否则会报编译错误</li>
</ul>
<h2 id="数组-列表快速初始化"><a class="markdownIt-Anchor" href="#数组-列表快速初始化"></a> 数组、列表快速初始化</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>[][] array = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);  <span class="comment">// 返回的是Arrays的内部类无法增删</span></span><br><span class="line">List&lt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()&#123;&#123;</span><br><span class="line">    add(<span class="number">1</span>);</span><br><span class="line">    add(<span class="number">2</span>);</span><br><span class="line">    add(<span class="number">3</span>);</span><br><span class="line">&#125;&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="初始化小根堆"><a class="markdownIt-Anchor" href="#初始化小根堆"></a> 初始化小根堆</h2>
<p>使用优先级队列 <code>PriorityQueue</code> 实现小根堆</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((pair1,pair2) -&gt; pair1[<span class="number">1</span>]-pair2[<span class="number">1</span>]);  <span class="comment">// 数组</span></span><br><span class="line">PriorityQueue&lt;ListNode&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; o1.val-o2.val);  <span class="comment">// 节点</span></span><br><span class="line"></span><br><span class="line">queue.offer(data)  <span class="comment">// 节点入堆</span></span><br><span class="line">data = queue.poll()  <span class="comment">// 头节点出堆</span></span><br></pre></td></tr></table></figure>
<h2 id="list-转数组"><a class="markdownIt-Anchor" href="#list-转数组"></a> List 转数组</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本数据类型需要手动拆箱</span></span><br><span class="line"><span class="type">int</span>[] array = list.stream().mapToInt(Integer::valueOf).toArray();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 流式</span></span><br><span class="line">String[] array = list.stream().toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line"><span class="comment">// 串行</span></span><br><span class="line">String[] array = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[list.size()]); <span class="comment">// 规定好数组大小，速度更快</span></span><br><span class="line">String[] array = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<h2 id="数组转-list"><a class="markdownIt-Anchor" href="#数组转-list"></a> 数组转 List</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本数据类型需要手动装箱</span></span><br><span class="line"><span class="type">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">List&lt;Integer&gt; list = Arrays.stream(arr).boxed().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] integers = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">3</span>,<span class="number">8</span>,<span class="number">20</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">25</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(integers); </span><br><span class="line"><span class="comment">// ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">// Collections.addAll(list, a);</span></span><br></pre></td></tr></table></figure>
<h2 id="原地交换"><a class="markdownIt-Anchor" href="#原地交换"></a> 原地交换</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ch[a] ^= ch[b];</span><br><span class="line">ch[b] ^= ch[a];</span><br><span class="line">ch[a] ^= ch[b];</span><br></pre></td></tr></table></figure>
<h2 id="泛型占位符"><a class="markdownIt-Anchor" href="#泛型占位符"></a> 泛型&amp;占位符</h2>
<p>泛型：T E K V</p>
<blockquote>
<p>泛型的初衷就是为了能在编译器检查出类型安全问题，并通过编译错误提示程序员</p>
</blockquote>
<ul>
<li>泛型必须是引用类型，不能是基本类型</li>
<li>泛型通过类型擦除实现</li>
</ul>
<p>占位符：?</p>
<p>TODO lambda stream 流式计算 详解</p>
<h2 id="判断奇偶"><a class="markdownIt-Anchor" href="#判断奇偶"></a> 判断奇偶</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">num &amp; <span class="number">1</span> == <span class="number">0</span> 则为奇数</span><br></pre></td></tr></table></figure>
<h2 id="十进制数转-char"><a class="markdownIt-Anchor" href="#十进制数转-char"></a> 十进制数转 char</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">t</span> <span class="operator">=</span> Character.forDigit(i, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h2 id="collection-转-list的方法"><a class="markdownIt-Anchor" href="#collection-转-list的方法"></a> Collection 转 List的方法</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;T&gt; collection = map.values();</span><br><span class="line">List&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;T&gt;(collection);</span><br></pre></td></tr></table></figure>
<h2 id="map-遍历方法"><a class="markdownIt-Anchor" href="#map-遍历方法"></a> Map 遍历方法</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Key.class, Value.class&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;key= &quot;</span> + entry.getKey() + <span class="string">&quot; and value= &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="条件语句中赋值"><a class="markdownIt-Anchor" href="#条件语句中赋值"></a> 条件语句中赋值</h2>
<p>不能直接在 <code>if</code> 语句的条件部分进行声明和赋值，需要在 <code>if</code> 语句之前声明变量，并在条件语句中只进行赋值或比较操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> dis;  </span><br><span class="line"><span class="keyword">if</span> ((dis = i - dp[i - <span class="number">1</span>]) &gt; <span class="number">1</span> &amp;&amp; s.charAt(dis - <span class="number">2</span>) == <span class="string">&#x27;(&#x27;</span>) &#123;  </span><br><span class="line">    <span class="comment">// ... 使用 dis 进行操作 ...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[5,4,8,11,null,13,4,7,2,null,null,5,1]</span><br><span class="line">22</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java 算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java常用数据结构的底层实现</title>
    <url>/Java-DataStructure/</url>
    <content><![CDATA[<h1 id="arraylist"><a class="markdownIt-Anchor" href="#arraylist"></a> ArrayList</h1>
<p><code>ArrayList</code> 的底层是数组队列，相当于动态数组。</p>
<ul>
<li>与数组相比，它的容量能动态增长。</li>
<li>与 Vector 相比，它的底层使用 Object[] 存储，适用于频繁的查找工作，线程不安全</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, E)</span>;</span><br><span class="line">    E <span class="title function_">set</span><span class="params">(<span class="type">int</span>, E)</span>;</span><br><span class="line">    E <span class="title function_">get</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">    E <span class="title function_">remove</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>List</code> : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。</li>
<li><code>RandomAccess</code> ：这是一个标志接口，表明实现这个接口的 <code>List</code> 集合是支持 <strong>快速随机访问</strong> ,可以通过元素的序号快速获取元素对象<code>list.get(i)</code>。</li>
<li><code>Cloneable</code> ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。</li>
<li><code>Serializable</code> : 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便。</li>
</ul>
<h2 id="扩容机制"><a class="markdownIt-Anchor" href="#扩容机制"></a> 扩容机制</h2>
<p>初始化时默认空数组 <code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>。</p>
<p>添加元素时，先判断需要扩容的最小扩容量大小（DEFAULT_CAPACITY 默认是 10）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要扩容，就会进入扩容方法 grow()，扩容效果是小于等于 1.5 倍的（因为 int 取整）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果扩容长度超过定义的数组的最大长度 <code>MAX_ARRAY_SIZE = Integer.MAX_VALUE-8</code>，就会触发最大值限制，防止 size 溢出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将旧数组移动到新数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] copyOf(<span class="type">int</span>[] original, <span class="type">int</span> newLength) &#123;</span><br><span class="line">    <span class="type">int</span>[] copy = <span class="keyword">new</span> <span class="title class_">int</span>[newLength];</span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>, Math.min(original.length, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>手动扩容</strong>，可以在需要插入大量数据前手动扩容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minExpand</span> <span class="operator">=</span> (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) ? <span class="number">0</span> : DEFAULT_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="与-linkedlist-的异同"><a class="markdownIt-Anchor" href="#与-linkedlist-的异同"></a> 与 LinkedList 的异同</h2>
<ul>
<li>
<p>都不保证线程安全；</p>
</li>
<li>
<p><code>ArrayList</code> 底层使用的是 <code>Object[]</code> <strong>数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>Node+双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环）</p>
</li>
<li>
<p><strong>插入和删除是否受元素位置的影响：</strong></p>
</li>
<li>
<ul>
<li><code>ArrayList</code> 将指定的元素<strong>追加到此列表的末尾</strong>，时间复杂度 <strong>O(1)</strong>。但是如果要在<strong>指定位置 i 插入和删除元素</strong>的话（<code>add(int index, E element)</code>），时间复杂度 <strong>O(n)</strong>。</li>
<li><code>LinkedList</code> <strong>头尾插入或者删除</strong>元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code>、 <code>removeLast()</code>），时间复杂度 <strong>O(1)</strong>；<strong>指定位置 <code>i</code> 插入和删除元素</strong>的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>,<code>remove(int index)</code>）， 时间复杂度为 <strong>O(n)</strong> 。</li>
</ul>
</li>
<li>
<p><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code>（实现了 <code>RandomAccess</code> 接口） 支持。</p>
</li>
<li>
<p><strong>内存空间占用：</strong> <code>ArrayList</code> 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素 Node 都需要消耗比 ArrayList 更多的空间</p>
</li>
</ul>
<h1 id="linkedlist"><a class="markdownIt-Anchor" href="#linkedlist"></a> LinkedList</h1>
<blockquote>
<p>需要用到 <code>LinkedList</code> 的场景几乎都可以使用 <code>ArrayList</code> 来代替，而且性能会更好。头尾插入或者删除元素的时候时间复杂度近似 O(1)，其他情况增删元素的平均时间复杂度都是 O(n) 。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt; </span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.item = element;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">            <span class="built_in">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>List</code> : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。</li>
<li><code>Deque</code> ：继承自 <code>Queue</code> 接口，具有双端队列的特性，支持从两端插入和删除元素，方便实现栈和队列等数据结构。</li>
</ul>
<h1 id="hashmap"><a class="markdownIt-Anchor" href="#hashmap"></a> HashMap</h1>
<blockquote>
<p>JDK1.8 之前 HashMap 采用“拉链法”处理冲突，由 数组+链表 组成； JDK1.8 以后，若Table长度大于 64，会将链表转化为红黑树。</p>
</blockquote>
<style>.gzpwqqycurtb{zoom:50%;}</style><img data-src="/Java-DataStructure/image-20240425212527868.png" class="gzpwqqycurtb" alt="image-20240425212527868">
<ul>
<li>key 和 value 可以为 null，但 null 作为 key 只能有一个，而 null 作为 value 可以有多个</li>
<li>非线程安全的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">    <span class="comment">// 默认的初始容量是16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 默认的负载因子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">// 当桶上的结点数大于等于这个值时会转成红黑树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 当桶上的结点数小于等于这个值时树转链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 桶中结构转化为红黑树对应的 table 的最小容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 存储桶（bin）的数组，永远是 2 的幂次倍</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;k,v&gt;[] table;</span><br><span class="line">    <span class="comment">// 一个包含了映射中所有键值对的集合视图</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;</span><br><span class="line">    <span class="comment">// 存放元素的个数，注意这个不等于数组的长度</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// 阈值=容量*负载因子，当实际大小超过阈值时，会进行扩容</span></span><br><span class="line">    <span class="type">int</span> threshold;</span><br><span class="line">    <span class="comment">// 负载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt;&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        <span class="comment">// 连接下一个 Node，用于遍历 Map</span></span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt;&#123;</span><br><span class="line">        Entry&lt;K,V&gt; before, after;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// 红黑树链</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// 需要在下次删除时解除链接</span></span><br><span class="line">        <span class="type">boolean</span> red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>entrySet</code> 通过<code>Node的next属性</code>遍历元素，<code>keySet()</code>、<code>values()</code>基于<code>entrySet</code>实现，用于遍历访问所有 Node 元素，还支持元素的删除操作【不确定，entrySet不存储数据，只是数据对外的操作接口】。</li>
<li><code>TreeNode</code> 继承了 <code>LinkedHashMap.Entry</code> ，有指向前后节点的指针</li>
</ul>
<p>jdk 1.8 <strong>Key 计算 hash 值的方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩容机制-2"><a class="markdownIt-Anchor" href="#扩容机制-2"></a> 扩容机制</h2>
<p><strong>何时触发 <code>resize()</code> 扩容</strong></p>
<ul>
<li>要插入数据前，发现<code>table</code> 中的 <code>bin</code> 为空</li>
<li>要插入数据后，发现<code>HashMap</code>的 <code>size</code> 超过 <code>threshold</code></li>
<li><code>table</code> 长度小于 <code>MIN_TREEIFY_CAPACITY</code>时，某 <code>Node</code> 上的链长度超过 <code>TREEIFY_THRESHOLD</code></li>
</ul>
<p><code>resize()</code> 扩容，会将 table 中的节点数量 &lt;&lt; 1，并重新 hash 映射所有节点（因为 table 变大了，每个节点对应的 bin 下标发生了变化 <code>newTab[e.hash &amp; (newCap - 1)] = e</code>，<code>newCap</code>为 table 的新大小）</p>
<p>链表何时变成红黑树？</p>
<ul>
<li>该 <code>bin</code> 上的链长度<code>binCount</code>大于等于 <code>TREEIFY_THRESHOLD</code>  且 <code>table</code> 中 <code>bin</code> 数量大于等于 <code>MIN_TREEIFY_CAPACITY</code></li>
</ul>
<p>如果链表转红黑树的时候，又有数据要插入，会发生什么？</p>
<ul>
<li>线程不安全。在树结构替换链表最终阶段会校验树结构，在此过程中的插入会使该树结构不满足红黑树和双链表的特性，导致报异常 <code>assert checkInvariants(root);</code></li>
</ul>
<h1 id="concurrenthashmap"><a class="markdownIt-Anchor" href="#concurrenthashmap"></a> ConcurrentHashMap</h1>
<blockquote>
<p>Java7 中 ConcurrentHashMap 使用的是分段锁，每一个 Segment 上同时只有一个线程可以操作，结构上时 <code>Segment</code> <strong>数组 +</strong> <code>HashEntry</code> <strong>数组 + 链表</strong>。<code>Segment</code> 的个数一旦<strong>初始化就不能改变</strong>，默认 <code>Segment</code> 的个数是 16 个，<code>Segment</code>继承<code>ReentrantLock</code>实现分段锁。</p>
<p>Java8 中的 ConcurrentHashMap 通过 <strong>Synchronized 锁加 CAS</strong> 保证多线程安全，结构上是 <code>Node</code> <strong>数组</strong> + <strong>链表 / 红黑树</strong>。</p>
</blockquote>
<p>如果链表转红黑树，又有数据要插入，会发生什么。</p>
<ul>
<li><code>treeifyBin</code> 通过 <code>synchronized</code> 把 <code>bin</code> 加锁，后续数据插入会因为无法竞争到资源而阻塞</li>
<li>链表开始转红黑树前，会将 Node 头节点置为 <code>ForwardingNode</code>，<code>ForwardingNode</code> 的 hash 是 <code>Moved</code> 表示正在转换为红黑树，此时会自旋等待转换完成后插入（大概是这样的）</li>
</ul>
<p>如果数组扩容，又有数据要插入，会发生什么。</p>
<ul>
<li>扩容前，会将 Node 头节点置为 <code>ForwardingNode</code>，<code>ForwardingNode</code> 的 hash 是 <code>Moved</code> 表示正在扩容。</li>
<li>扩容时，插入数据的线程若发现 hash 值为负，会去协助扩容，扩容完成后再插入数据。</li>
</ul>
<p><a href="https://blog.csdn.net/ZOKEKAI/article/details/90051567"><strong>什么时候触发扩容？</strong></a></p>
<ul>
<li>在调用 addCount 方法增加集合元素计数后发现当前集合元素个数到达扩容阈值时就会触发扩容</li>
<li>扩容状态下其他线程对集合进行插入、修改、删除、合并、compute 等操作时遇到 <code>ForwardingNode</code> 节点会触发扩容（帮助扩容）</li>
<li>putAll 批量插入或者插入节点后发现存在链表长度达到 8 个或以上，但数组长度为 64 以下时会触发扩容  。</li>
</ul>
<p>同 HashMap：桶上链表长度达到 8 个或者以上，并且数组长度为 64 以下时只会触发扩容而不会将链表转为红黑树</p>
<h1 id="linkedhashmap"><a class="markdownIt-Anchor" href="#linkedhashmap"></a> LinkedHashMap</h1>
<p>对于每次put进来Entry，除了将其保存到哈希表中对应的位置上之外，还会将其插入到双向链表的尾部。</p>
<h1 id="copyonwritelist"><a class="markdownIt-Anchor" href="#copyonwritelist"></a> CopyOnWriteList</h1>
<p>写时复制</p>
<p><strong>如果写多读少应该用什么数据结构实现同步数组？</strong></p>
<p>分段读写锁 ReadWriteLock（由于 List.copy() 是操作系统实现，数据量少的话依然可用写时复制）</p>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/Network/</url>
    <content><![CDATA[<blockquote>
<p>先草率的记一下，反正记下来也背不下来，我恨八股呜呜呜</p>
</blockquote>
<h1 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h1>
<p>OSI  七层模型：应用层、表示层、会话层、传输层、网罗层、数据链路层、物理层</p>
<p>TCP/IP 四层模型：应用层、传输层、网络层、网络接口层</p>
<ul>
<li>HTTP、FTP、Telnet、DNS、SMTP、DHCP</li>
<li>TCP、UDP</li>
<li>IP、ARP、ICMP</li>
</ul>
<p>数据传输结构</p>
<ul>
<li>TCP 分段（MSS）传输应用层数据</li>
<li>传输层通过端口区分应用</li>
<li>IP 分片（MTU）传输 TCP 报文</li>
</ul>
<style>.badroesqyolu{zoom: 60%;}</style><img data-src="/Network/12.jpg" class="badroesqyolu" alt="img">
<style>.mnwbsthvsume{zoom:50%;}</style><img data-src="/Network/image-20240508140301819.png" class="mnwbsthvsume" alt="image-20240508140301819">
<h1 id="应用层-http"><a class="markdownIt-Anchor" href="#应用层-http"></a> 应用层 HTTP</h1>
<blockquote>
<p>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」</p>
</blockquote>
<p>常用字段</p>
<p><strong>Content-Length</strong>：HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题。</p>
<p>HTTP/1.1 优化</p>
<ul>
<li>长连接，复用 TCP 连接</li>
<li>缓存：强制缓存和协商缓存</li>
<li>压缩</li>
<li>管道传输</li>
<li>灵活、易于扩展</li>
</ul>
<p>HTTP/2 优化</p>
<ul>
<li>头部压缩</li>
<li>并发传输</li>
<li>服务端主动推送</li>
<li>二进制帧格式传输</li>
</ul>
<p>HTTP/3 优化</p>
<ul>
<li>提出了 QUIC 传输层协议代替 tcp。quic是基于udp实现的，在无连接的基础上实现了可靠和安全
<ul>
<li>更快的请求多路复用</li>
<li>避免队头阻塞</li>
<li>更快的建立连接</li>
</ul>
</li>
</ul>
<p>HTTPS</p>
<ul>
<li>加密传输：在应用层和传输层之间加了 SSL/TLS 安全协议；建立连接时需要 SSL/TLS 的握手过程；使用时需要向 CA 申请数字证书</li>
<li>摘要算法 + 数字签名
<ul>
<li>混合加密：建立连接用非对称加密：公钥和私钥；传输数据用对称加密：一个密钥</li>
<li>摘要算法：用摘要算法（哈希函数）来计算出内容的哈希值，哈希值是唯一的，且无法通过哈希值推导出内容</li>
<li>数字签名：通过「私钥加密，公钥解密」的方式，来确认消息的身份</li>
<li>数字证书：通过第三方 CA 保证服务器的公钥私钥没有被别人替换过</li>
</ul>
</li>
<li>建立连接：RSA算法
<ul>
<li>ClientHello：客户端生产随机数 Client Random</li>
<li>SeverHello：服务端生产随机数 Server Random、数字证书</li>
<li>客户端回应：获取证书中的服务器公钥、加密通信算法改变通知、公钥加密随机数 pre-master key</li>
<li>三个随机数算出<strong>会话密钥</strong>，双方都通知对方后续请求都使用会话密钥加密通信</li>
</ul>
</li>
</ul>
<h1 id="传输层-tcp"><a class="markdownIt-Anchor" href="#传输层-tcp"></a> 传输层 TCP</h1>
<blockquote>
<p>负责为应用层提供网络支持，实现应用到应用的数据传输</p>
</blockquote>
<p>TCP ：面向连接的、可靠的、基于字节流的</p>
<p>三次握手</p>
<style>.ninroljrbcpj{zoom:50%;}</style><img data-src="/Network/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png" class="ninroljrbcpj" alt="TCP 三次握手">
<p>四次挥手</p>
<style>.fuarveqgylns{zoom: 67%;}</style><img data-src="/Network/format,png-20230309230614791.png" class="fuarveqgylns" alt="客户端主动关闭连接 —— TCP 四次挥手">
<ul>
<li>首先确认客户端不会再发送请求给服务端</li>
<li>然后服务端在发送完数据后，再向客户端发送断开连接</li>
</ul>
<p>为什么这么设计？因为TCP是双向通信的可靠的协议，需要确保客户端和服务端都有收发数据包的能力；为后续传输做准备：序列号</p>
<p>流量控制、超时重传、拥塞控制</p>
<h1 id="网络层-ip"><a class="markdownIt-Anchor" href="#网络层-ip"></a> 网络层 IP</h1>
<blockquote>
<p>负责路径传输过程中路径和节点的选择，实现设备到设备的数据传输</p>
</blockquote>
<p>寻址能力：网络号+主机号（子网掩码）</p>
<p>路由：数据包每到达一个节点，通过路由算法决定下一步走哪条路径</p>
<p>分片重组：以太网的 MTU（最大传输单元）是 1500 字节。在分片传输中，一旦某个分片丢失，则会造成<strong>整个 IP 数据报作废</strong>，所以 TCP 引入了 MSS 也就是在 TCP 层进行分片不由 IP 层分片，那么对于 UDP 我们尽量不要发送一个大于 MTU 的数据报文</p>
<p>ICMP：诊断和通知出错</p>
<p>NAT：网络地址转换</p>
<p>DHCP：动态获取 IP 地址</p>
<p>ARP：下一跳的 MAC 地址</p>
<p>DNS：域名解析</p>
<p>IGMP：组播</p>
]]></content>
      <categories>
        <category>八股</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基础</title>
    <url>/MySQL/</url>
    <content><![CDATA[<h1 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h1>
<h2 id="sql-查询语句执行过程"><a class="markdownIt-Anchor" href="#sql-查询语句执行过程"></a> SQL 查询语句执行过程</h2>
<ul>
<li>连接器：客户端与 Server 层建立连接，管理连接、校验用户身份；</li>
<li>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行（MySQL 8.0 已删除该模块）</li>
<li>解析 SQL：通过解析器对 SQL 查询语句进行<strong>词法分析</strong>、<strong>语法分析</strong>，然后<strong>构建语法树</strong>，方便后续模块读取表名、字段、语句类型；</li>
<li>执行 SQL：
<ul>
<li>预处理阶段：检查表或字段是否存在；将 select * 中的 * 符号扩展为表上的所有列；</li>
<li>优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；查询优化器</li>
<li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li>
</ul>
</li>
</ul>
<h2 id="mysql-数据文件"><a class="markdownIt-Anchor" href="#mysql-数据文件"></a> MySQL 数据文件</h2>
<ul>
<li>db.opt，用来存储当前数据库的默认字符集和字符校验规则。</li>
<li>table.frm ，存放<strong>表结构</strong>，在 MySQL 中建立一张表都会生成一个.frm 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。</li>
<li>table.ibd，存放<strong>表数据</strong>，<s>表数据既可以存在共享表空间文件（文件名：ibdata1）里</s>，也可以存放在独占表空间文件（文件名：表名字.ibd）。这个行为是由参数 innodb_file_per_table 控制的，若设置了参数 innodb_file_per_table 为 1，则会将存储的<strong>数据、索引等信息单独存储在一个独占表空间</strong>，从 MySQL 5.6.6 版本开始，它的默认值就是 1 了，因此从这个版本之后， MySQL 中每一张表的数据都存放在一个独立的 .ibd 文件。</li>
</ul>
<p><strong>表空间文件的结构</strong></p>
<style>.jvnmohvxhoxo{zoom:67%;}</style><img data-src="/MySQL/%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84.drawio.png" class="jvnmohvxhoxo" alt="img">
<h2 id="innodb-行格式"><a class="markdownIt-Anchor" href="#innodb-行格式"></a> InnoDB 行格式</h2>
<p>共有 Redundant、Compact、Dynamic、Compressed 四种，下图时 Compact 行格式的结构</p>
<img data-src="/MySQL/COMPACT.drawio.png" class="" title="img">
<h2 id="innodb-页格式"><a class="markdownIt-Anchor" href="#innodb-页格式"></a> InnoDB 页格式</h2>
<p>InnoDB 的数据是按「数据页」为单位来读写的，数据页的默认大小是 16KB</p>
<style>.mxxfxghbxfig{zoom:50%;}</style><img data-src="/MySQL/243b1466779a9e107ae3ef0155604a17-17146246150216.webp" class="mxxfxghbxfig" alt="243b1466779a9e107ae3ef0155604a17">
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>文件头</td>
<td>页的信息；两个指针指向<u>上一个/下一个数据页</u></td>
</tr>
<tr>
<td>页头</td>
<td>页的状态信息</td>
</tr>
<tr>
<td>最小和最大记录</td>
<td>两个虚拟伪记录，分别表示页中的最小记录和最大记录</td>
</tr>
<tr>
<td><u>用户记录</u></td>
<td>储存所有的行记录</td>
</tr>
<tr>
<td>空闲空间</td>
<td>还没被用到的空间</td>
</tr>
<tr>
<td><u>页目录</u></td>
<td>用户记录相对位置，页中所有记录的索引</td>
</tr>
<tr>
<td>文件尾</td>
<td>校验页是否完整</td>
</tr>
</tbody>
</table>
<p>数据页中的 页目录存储各个槽，用户记录按照「主键」顺序组成单向链表，可以通过二分查找法的方式进行检索。</p>
<h1 id="索引"><a class="markdownIt-Anchor" href="#索引"></a> 索引</h1>
<p>索引字段特性分类</p>
<ul>
<li>主键索引</li>
<li>唯一索引</li>
<li>前缀索引</li>
<li>普通索引</li>
</ul>
<p>索引个数分类</p>
<ul>
<li>单例索引</li>
<li>联合索引：最左匹配原则（MySQL 有查询优化器，所以字段在 where 子句的顺序并不重要）</li>
</ul>
<blockquote>
<p>最左匹配原则：按照最左优先的方式进行索引的匹配，范围查询的字段可以用到联合索引，在遇到范围查询（如 &gt;、&lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 &gt;=、&lt;=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配。</p>
</blockquote>
<h2 id="innodb-采用-btree-作为索引的优势"><a class="markdownIt-Anchor" href="#innodb-采用-btree-作为索引的优势"></a> Innodb 采用 B+Tree 作为索引的优势</h2>
<blockquote>
<p>MySQL 底层实现的 B+ 树在原有的 B+ 树的基础上做了改动</p>
<ul>
<li>叶子节点采用双向链表连接</li>
<li>所有节点都是 16KB 数据页</li>
<li>非叶子节点中有多少个子节点，就有多少个索引</li>
</ul>
<p>nosql 的 MongoDB 采用 B 树实现，适用于大量的单个索引查询的场景；</p>
</blockquote>
<ul>
<li><strong>查询底层节点的磁盘 I/O次数少</strong>。非叶子节点只存放索引，相比 B 树，每个非叶子节点能存储更多的索引，树形结构更加矮胖；</li>
<li><strong>插入和删除效率高</strong>。非叶子节点中的都是冗余索引，所有索引都在叶子节点中又存储了一次；</li>
<li><strong>树层低，磁盘 I/O 次数少</strong>。若每行数据 1KB，三层最多可存放千万级数据量；</li>
<li><strong>范围查询，磁盘 I/O 次数少</strong>。叶子节点采用双向有序链表连接；其他树结构需要中序遍历，磁盘 I/O 次数多；</li>
</ul>
<p>B+Tree 索引结构</p>
<ul>
<li>主键索引/聚簇索引：叶子节点存放实际数据、事务 id、用于事务和 MVCC 的回滚指针；</li>
<li>二级索引：叶子节点存放主键值；</li>
</ul>
<h2 id="explain-执行计划"><a class="markdownIt-Anchor" href="#explain-执行计划"></a> Explain 执行计划</h2>
<p>数据扫描类型 type</p>
<ul>
<li>All：全表扫描；</li>
<li>index：全索引扫描；</li>
<li>index merge：索引合并。先将使用到的索引先进行求 交集、并集之后在进行回表；</li>
<li>range：索引范围扫描。使用 &lt; 、&gt;、in、between 等关键词，只检索给定范围的行；</li>
<li>ref：非唯一索引等值匹配；</li>
<li>eq_ref：唯一索引 多表联查 等值匹配；</li>
<li>const：主键或唯一索引 常量 等值匹配；</li>
</ul>
<p>额外信息 extra</p>
<ul>
<li>Using filesort ：当查询语句中包含 group by 操作，而且无法利用索引完成排序操作的时候， 这时不得不选择相应的排序算法进行；</li>
<li>Using temporary：使了用临时表保存中间结果，如排序 order by 和分组查询 group by；</li>
<li>Using where：存储引擎层返回行以后在 MySQL 服务层应用 where 过滤条件；</li>
<li>Using index：所需数据可以直接在二级索引值和主键值中得到，采用覆盖索引，不回表；</li>
<li>Using index condition 索引下推 ：可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数；</li>
</ul>
<h2 id="是否需要索引"><a class="markdownIt-Anchor" href="#是否需要索引"></a> 是否需要索引</h2>
<p>需要索引的情况</p>
<ul>
<li>唯一性字段</li>
<li>范围查询 <code>WHERE</code></li>
<li>排序查询 <code>GROUP BY</code> 、 <code>ORDER BY</code></li>
<li>覆盖索引，全索引扫描优于全表扫描</li>
</ul>
<p>不需要索引的情况</p>
<ul>
<li>不需要范围查询、排序查询</li>
<li>大量重复数据</li>
<li>频繁修改</li>
<li>数据量少</li>
</ul>
<h2 id="索引优化"><a class="markdownIt-Anchor" href="#索引优化"></a> 索引优化</h2>
<p><strong>前缀索引</strong>：减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。</p>
<p><strong>覆盖索引</strong>：联合索引和主键值中包括了查询数据，避免回表</p>
<p><strong>主键索引自增</strong>：追加记录时不需要移动数据；避免页分裂造成内存碎片；</p>
<p><strong>主键字段长度尽可能短</strong>：聚簇索引非叶子节点可以装下更多的索引；二级索引叶子节点可以装下更多的主键值，占用空间更小</p>
<p><strong>索引 NOT NULL</strong>：简化索引统计、值比较过程；减少 1 字节的行格式长度；</p>
<p><strong>联合索引 区分度大的在前</strong>：建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到。</p>
<blockquote>
<p>如果索引的区分度很小，假设字段的值分布均匀，那么无论搜索哪个值都可能得到一半的数据（惯用的百分比界线是&quot;30%&quot;）MySQL 查询优化器，会忽略索引，进行全表扫描</p>
</blockquote>
<h2 id="索引失效"><a class="markdownIt-Anchor" href="#索引失效"></a> 索引失效</h2>
<ul>
<li>
<p>左或者左右模糊匹配</p>
</li>
<li>
<p>查询条件中对索引列做了</p>
<ul>
<li>计算</li>
<li>函数</li>
<li>类型转换操作</li>
</ul>
</li>
<li>
<p>联合索引未遵循最左匹配原则</p>
</li>
<li>
<p>条件语句中 OR 前后子句一个有索引一个没索引</p>
</li>
</ul>
<p><strong>Count 计算</strong></p>
<p>遍历索引，优先遍历 key_len 最小的二级索引，只有当没有二级索引的时候，才会采用主键索引来进行统计。</p>
<h1 id="事务"><a class="markdownIt-Anchor" href="#事务"></a> 事务</h1>
<p>事务是由存储引擎实现的，InnoDB 支持事务</p>
<h2 id="特性"><a class="markdownIt-Anchor" href="#特性"></a> 特性</h2>
<ul>
<li>持久性是通过 redo log （重做日志）保证的；</li>
<li>原子性是通过 undo log（回滚日志） 保证的；</li>
<li>隔离性是通过 MVCC（多版本并发控制） 或锁机制保证的；</li>
<li>一致性则是通过持久性+原子性+隔离性保证的；</li>
</ul>
<p><strong>并行事务会引发的问题</strong></p>
<ul>
<li>脏读：一个事务读到了另一个<u>未提交事务修改过的数据</u></li>
<li>不可重复读：一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样</li>
<li>幻读：一个事务内多次查询某个查询条件的记录数量不同</li>
</ul>
<h2 id="隔离级别"><a class="markdownIt-Anchor" href="#隔离级别"></a> 隔离级别</h2>
<table>
<thead>
<tr>
<th>隔离级别（是否会出现xx问题）</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>READ-UNCOMMITTED 读未提交</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>READ-COMMITTED 读已提交</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE-READ 可重复读</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>SERIALIZABLE 可串行化</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody>
</table>
<ul>
<li>读未提交：允许读取尚未提交的数据变更。直接读取最新的数据</li>
<li>读已提交：允许读取并发事务已经提交的数据。<strong>「每个 SQL 语句执行前」都会重新生成一个 Read View</strong></li>
<li>可重复读：对同一字段的多次读取结果都是一致的。<strong>「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View</strong></li>
<li>可串行化：所有的事务依次逐个执行，完全服从 ACID 的隔离级别。采用加读写锁的方式来避免并行访问</li>
</ul>
<p>虽然 InnoDB 默认采用可重复读隔离级别，但基本不会出现幻读，因为其采用 next-key lock（记录锁+间隙锁）和 MVCC 来避免幻读的发生</p>
<ul>
<li>
<p><strong>快照读</strong>（select）：采用 MVCC 方式解决了幻读。事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，保证事务隔离性；</p>
<ul>
<li>在执行第一个查询语句后，会创建一个 Read View，后续的查询语句利用这个 Read View，通过这个 Read View 就可以在 undo log 版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的</li>
</ul>
</li>
<li>
<p><strong>当前读/共享锁</strong>（select for update）：通过 next-key lock（记录锁+间隙锁）方式解决了幻读，读到的记录是最新的。如果有其他事务在 Next-Key Lock 范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入；</p>
<ul>
<li>update、insert、delete 都是当前读，这些语句执行前都会<strong>查询最新版本的数据</strong>，然后再做进一步的操作；</li>
<li>如果 update 是已经被锁住的记录，就生成插入意向锁并进入阻塞状态；</li>
<li>当前读给某记录加锁了，那么对该记录已修改但未提交的事物就无法提交这个修改了，直到锁被释放；</li>
<li>Next-Key Lock 对索引记录加上行锁（Record Lock），对索引记录两边的间隙加上<strong>间隙锁（Gap Lock）</strong>，是针对事务隔离级别为可重复读或以上级别而设计的；</li>
</ul>
</li>
</ul>
<h2 id="mvcc-多版本并发控制"><a class="markdownIt-Anchor" href="#mvcc-多版本并发控制"></a> MVCC 多版本并发控制</h2>
<p>InnoDB 事务是通过 <strong>Read View 和 聚簇索引中的两个隐藏列</strong> 实现 MVCC 的</p>
<p><strong>Read View 字段</strong></p>
<img data-src="/MySQL/readview%E7%BB%93%E6%9E%84.drawio.png" class="" title="img">
<p><strong>聚簇索引中的两个隐藏列</strong></p>
<ul>
<li>trx_id，当一个事务对某条聚簇索引记录进行改动时，就会<strong>把该事务的事务 id 记录在 trx_id 隐藏列里</strong>；</li>
<li>roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后<strong>这个隐藏列是个指针，指向每一个旧版本记录</strong>，于是就可以通过它找到修改前的记录。</li>
</ul>
<p><strong>MVCC 如何实现可重复读？</strong></p>
<p>事务 A 读某字段时，会先读取该字段的 trx_id，如果 Read View 中记录的该 trx_id 是<strong>活跃事务</strong>，则沿着 roll_pointer（即 <strong>undo log 版本链</strong>）寻找旧版本字段；如果 Read View 中记录的该 trx_id 是<strong>当前事务</strong> 或 <strong>已提交事务</strong>，则返回该记录。【注意，Read View 字段不随活跃事务的提交而改变，它是该事务开启时的数据库事务状态快照】</p>
<h2 id="可重复读下发生幻读"><a class="markdownIt-Anchor" href="#可重复读下发生幻读"></a> 可重复读下发生幻读</h2>
<ol>
<li>事务 A 先对某块记录执行快照读</li>
<li>事务 B 插入数据到该块记录中，并提交事务 B</li>
<li>事务 A 再对该块记录执行当前读或更新记录</li>
<li>会读取到事务 B 插入的数据，因为当前读会读取最新的记录</li>
</ol>
<p><strong>如何避免？</strong></p>
<p>若事务中会对数据采取 当前读，则在事务刚开始时就执行，通过 next-key lock 避免其他事物再插入数据。</p>
<h1 id="锁"><a class="markdownIt-Anchor" href="#锁"></a> 锁</h1>
<blockquote>
<p>MySQL 加锁时，先 生成锁结构，然后 设置锁的状态，即初始化锁再竞争锁；如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁；</p>
</blockquote>
<p><strong>锁的种类</strong></p>
<ul>
<li>全局锁</li>
<li>表级锁
<ul>
<li>表锁</li>
<li>意向表：用于<strong>快速判断表里是否有记录被加锁</strong>。意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（lock tables … read）和独占表锁（lock tables … write）发生冲突</li>
<li>元数据表 MDL 锁：更表结构时需要申请 MDL 写锁</li>
<li>AUTO-INC 锁：配置文件 <code>innodb_autoinc_lock_mode = 2, binlog_format = row</code>，既能提升并发性，又不会出现数据一致性问题</li>
</ul>
</li>
<li>行级锁
<ul>
<li>Record Lock 记录锁，区分读锁和写锁，锁定存在的记录；</li>
<li>Gap Lock 间隙锁，不区分读锁和写锁；间隙锁用来锁一个范围，间隙锁之间是兼容的；</li>
<li>Next-Key Lock 临键锁，区分读锁和写锁；</li>
<li>插入意向锁，特殊的间隙锁，<strong>用于不同事务的并发控制和冲突检测</strong>；插入意向锁和不同事物的间隙锁之间是冲突的，当某个事务的插入语句遇到间隙锁时，会产生插入意向锁；</li>
</ul>
</li>
<li>隐式锁
<ul>
<li>延迟加锁机制，特点是只有在可能发生冲突时才加锁</li>
<li>使用场景：事务 B 插入记录的索引 == 事务 A 已插入且未提交的索引，事务 A 插入的记录上的「隐式锁」会变「显示锁」且锁类型为 X 型的记录锁，所以事务 B 想获取 <s>S 型</s>next-key 锁时会遇到锁冲突，事务 B 进入阻塞状态。</li>
</ul>
</li>
</ul>
<h2 id="行级锁实现"><a class="markdownIt-Anchor" href="#行级锁实现"></a> 行级锁实现</h2>
<blockquote>
<p>行级锁时 Innodb 实现高效事务的关键</p>
</blockquote>
<p>加锁是加在索引上的【加行级锁时还要加表锁：X 类型的意向锁】</p>
<ul>
<li>全表当前读，<strong>遍历</strong>聚簇索引加临键锁（update 未走索引的情况）</li>
<li>全索引当前读，<strong>遍历</strong>当前索引加临键锁</li>
</ul>
<p><strong>二级索引加锁后，还要在查询到的记录的主键索引项加记录锁</strong></p>
<p><strong>Insert 语句，加行级锁</strong></p>
<ul>
<li>记录被间隙锁，阻塞
<ul>
<li>插入意向锁</li>
</ul>
</li>
<li>唯一键冲突，执行失败
<ul>
<li>如果主键索引重复，插入新记录的事务会给已存在的主键值重复的聚簇索引记录<strong>添加 S 型记录锁</strong>。</li>
<li>如果唯一二级索引重复，插入新记录的事务都会给已存在的二级索引列值重复的二级索引记录<strong>添加 S 型 next-key 锁</strong>。</li>
</ul>
</li>
</ul>
<h3 id="临键锁退化成记录锁或间隙锁的情况"><a class="markdownIt-Anchor" href="#临键锁退化成记录锁或间隙锁的情况"></a> 临键锁退化成记录锁或间隙锁的情况</h3>
<p>唯一索引查询</p>
<ul>
<li>等值查询
<ul>
<li>（条件值）存在，<strong>该索引加记录锁</strong></li>
<li>（条件值）不存在，<strong>后一索引加间隙锁</strong></li>
</ul>
</li>
<li>范围查询
<ul>
<li>条件值在表中，非等值查询
<ul>
<li>小于，<strong>该索引加间隙锁</strong></li>
<li>大于，<strong>后一索引加临键锁</strong></li>
</ul>
</li>
<li>条件值在表中且条件是等值查询
<ul>
<li>小于等于，<strong>该索引加临键锁</strong></li>
<li>大于等于，<strong>该索引加记录锁</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>非唯一索引查询</p>
<ul>
<li>等值查询
<ul>
<li>存在，扫描到的索引记录加的是 next-key 锁，而对于第一个不符合条件的索引记录，该索引的 next-key 锁会退化成间隙锁；</li>
<li>不存在，扫描到第一条不符合条件的索引记录，该索引的 next-key 锁会退化成间隙锁；</li>
</ul>
</li>
<li>范围查询
<ul>
<li>为确保条件值前后都锁住，加锁时不存在临建锁退化为间隙锁和记录锁的情况</li>
</ul>
</li>
</ul>
<h2 id="死锁"><a class="markdownIt-Anchor" href="#死锁"></a> 死锁</h2>
<ul>
<li>两个事务分别加了间隙锁（前提）</li>
<li>两个事务分别向对方的间隙锁插入数据，于是都产生插入意向锁</li>
<li>由于插入意向锁和间隙锁冲突，双方都为了获取插入意向锁，会等待对方事务的间隙锁释放，陷入循环等待，造成死锁</li>
</ul>
<p>插入意向锁是对不同事务才产生作用的，对于本身事务的间隙锁是兼容的。</p>
<p>解决方法</p>
<ul>
<li>设置事务等待锁的超时时间 <code>innodb_lock_wait_timeout</code></li>
<li>开启主动死锁检测 <code>innodb_deadlock_detect</code></li>
</ul>
<h1 id="日志"><a class="markdownIt-Anchor" href="#日志"></a> 日志</h1>
<ul>
<li>undo log（回滚日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的原子性，主要用于<strong>事务回滚和 MVCC</strong>；</li>
<li>redo log（重做日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的持久性，主要用于<strong>掉电等故障恢复</strong>；</li>
<li>bin log （归档日志）：是 Server 层生成的日志，主要用于<strong>数据备份和主从复制</strong>；</li>
</ul>
<p>回滚日志与重做日志的区别</p>
<ul>
<li>redo log 记录了此次事务「完成后」的数据状态，记录的是更新之后的值；防止已提交事务的修改丢失；</li>
<li>undo log 记录了此次事务「开始前」的数据状态，记录的是更新之前的值；防止未提交事务的修改无法回滚；</li>
</ul>
<p>重做日志和归档日志的区别</p>
<ul>
<li>bin log 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。</li>
<li>redo log 是循环写，日志空间大小是固定，全部写满就从头开始，保存未被刷入磁盘的脏页日志。</li>
</ul>
<h2 id="回滚日志-undo-log"><a class="markdownIt-Anchor" href="#回滚日志-undo-log"></a> 回滚日志 Undo log</h2>
<ul>
<li><strong>实现事务回滚，保障事务的原子性</strong>。事务处理过程中，如果出现了错误 或者 用户执行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。</li>
<li>实现 MVCC（多版本并发控制）关键因素之一。MVCC 是通过 Read View + undo log 实现的。<strong>undo log 为每条记录保存多份历史数据</strong>，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。</li>
</ul>
<p>持久化方法：开启事务后，InnoDB 层更新记录前，首先要记录相应的 undo log，如果是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，对 undo 页的修改也都会记录到 redo log。redo log 会每秒刷盘，提交事务时也会刷盘，数据页和 undo 页都是靠这个机制保证持久化的。</p>
<h2 id="重做日志-redo-log"><a class="markdownIt-Anchor" href="#重做日志-redo-log"></a> 重做日志 Redo log</h2>
<blockquote>
<p>防止 Buffer Pool 中的脏页丢失</p>
</blockquote>
<ul>
<li>实现<strong>事务的持久性</strong>，让 MySQL 有 <strong>crash-safe</strong> 的能力，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；</li>
<li>将<strong>脏页的写操作</strong>从「随机写」变成了「顺序写」，提升 MySQL 写入磁盘的性能；</li>
</ul>
<p>WAL（Write-Ahead Logging）：MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo log 日志，然后在合适的时间再将脏页写到磁盘上。</p>
<p>redo log 是<strong>物理日志</strong>，记录了某个数据页做了什么修改，即所有未还没持久化的脏页修改。在事务提交时，只要<strong>先将 redo log 持久化到磁盘即可</strong>，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。当系统崩溃时，虽然脏页数据没有持久化，但是 redo log 已经持久化，接着 MySQL 重启后，可以根据 redo log 的内容，将所有数据恢复到最新的状态。</p>
<p><strong>redo log 持久化操作</strong>：每当产生一条 redo log 时，会先写入到 redo log buffer，为了在 MySQL 处理大事务时尽可能少写入磁盘，进而提升写 IO 性能。<strong>redo log buffer 写入磁盘的时机</strong>：</p>
<ul>
<li>MySQL 正常关闭时；</li>
<li>当 redo log buffer 中记录的写入量大于 redo log buffer <strong>内存空间</strong>的一半时；</li>
<li>InnoDB 的<strong>后台线程</strong>每隔 1 秒，将 redo log buffer 持久化到磁盘。</li>
<li>每次<strong>事务提交</strong>时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘；
<ul>
<li>参数为 0 时，事务提交不会主动触发写入磁盘的操作；<strong>MySQL 进程崩溃</strong>会导致上一秒钟所有事务数据的丢失；</li>
<li>参数为 1 时，每次事务提交都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘；</li>
<li>参数为 2 时，每次事务提交都只是缓存在 redo log buffer 里的 redo log 写到 redo log 文件（写入到 redo log 文件并不意味着写入到了磁盘，而是存在操作系统里的文件系统中的 Page Cache）；<strong>操作系统崩溃或者系统断电</strong>会导致上一秒钟所有事务数据的丢失；</li>
</ul>
</li>
</ul>
<h3 id="重做日志文件组"><a class="markdownIt-Anchor" href="#重做日志文件组"></a> 重做日志文件组</h3>
<p>redo log 是为了防止 Buffer Pool 中的脏页丢失而设计的，<strong>只记录未被刷入磁盘的数据的物理日志</strong>。随着系统运行，Buffer Pool 的脏页刷新到了磁盘中，redo log 对应的记录也就没用了，这时候我们需要擦除这些旧记录，以腾出空间记录新的更新操作。重做日志文件组由有 2 个 redo log 文件组成，以循环写的方式工作，从头开始写，写到末尾就又回到开头，相当于一个环形。</p>
<style>.dgmxjhltyqyz{zoom: 50%;}</style><img data-src="/MySQL/checkpoint.png" class="dgmxjhltyqyz" alt="img">
<ul>
<li>write pos ～ checkpoint 之间的部分（图中红色部分）：记录新的更新操作；</li>
<li>check point ～ write pos 之间的部分（图中蓝色部分）：待落盘的脏数据页记录；</li>
</ul>
<p>将 Buffer Pool 中的脏页刷新到磁盘中，然后标记 redo log 哪些记录可以被擦除，接着对旧的 redo log 记录进行擦除，等擦除完旧记录腾出了空间，checkpoint 就会往后移动（图中顺时针）。一次 checkpoint 的过程就是脏页刷新到磁盘中变成干净页，然后标记 redo log 哪些记录可以被覆盖的过程。</p>
<h2 id="归档日志-bin-log"><a class="markdownIt-Anchor" href="#归档日志-bin-log"></a> 归档日志 Bin log</h2>
<p>记录 MySQL 上的所有变化并以二进制形式保存在磁盘上。MySQL 在完成<strong>数据库表结构变更或表数据修改</strong>（增删改）时，Server 层会生成一条 binlog，等之后事务提交的时候，会将该事物执行过程中产生的所有 binlog 统一写入 binlog 文件。</p>
<ul>
<li>binlog 日志只能用于数据备份和主从复制，没有 crash-safe 的能力；</li>
<li>binlog 是全量日志，保存了所有数据变更的情况，可以恢复整个数据库所有数据；</li>
</ul>
<h3 id="主从复制"><a class="markdownIt-Anchor" href="#主从复制"></a> 主从复制</h3>
<style>.repbwhutbjdh{zoom:67%;}</style><img data-src="/MySQL/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B.drawio.png" class="repbwhutbjdh" alt="MySQL 主从复制过程">
<ul>
<li>写入 Binlog：数据修改 -&gt; 主库写 binlog 日志 -&gt; commit 事务 -&gt; 持久化本地数据 -&gt; 提交事务成功；</li>
<li>同步 Binlog：从库会创建一个专门的 I/O 线程，连接主库的 log dump 线程，来接收主库的 binlog 日志，再把 binlog 信息写入 relay log 的中继日志里，再返回给主库“复制成功”的响应。</li>
<li>回放 Binlog：读 relay log 中继日志，回放 binlog，并更新从库中的数据。</li>
</ul>
<p>主从复制模型</p>
<ul>
<li>同步复制：MySQL 主库提交事务的线程要等待所有从库的复制成功响应，才返回客户端结果；</li>
<li>异步复制（默认模型）：MySQL 主库提交事务的线程并不会等待 binlog 同步到各从库，就返回客户端结果；</li>
<li>半同步复制：只要数据成功复制到任意一个从库上，主库的事务线程就可以返回给客户端；</li>
</ul>
<h3 id="binlog-刷盘"><a class="markdownIt-Anchor" href="#binlog-刷盘"></a> binlog 刷盘</h3>
<style>.ciutuyrqsmur{zoom: 67%;}</style><img data-src="/MySQL/binlogcache.drawio.png" class="ciutuyrqsmur" alt="binlog cach">
<ul>
<li>图中的 write，把<strong>日志写入到 binlog 文件（文件系统的 page cache 里）</strong>，但是并没有把数据持久化到磁盘；</li>
<li>图中的 fsync，把数据持久化到磁盘的操作，这里就会涉及磁盘 I/O，所以频繁的 fsync 会导致磁盘的 I/O 升高；</li>
</ul>
<p>MySQL 提供一个 sync_binlog 参数来控制数据库的 binlog 刷到磁盘上的频率：</p>
<ul>
<li>sync_binlog = 0 的时候，表示每次提交事务都只 write，不 fsync，后续交由操作系统决定何时将数据持久化到磁盘；</li>
<li>sync_binlog = 1 的时候，表示每次提交事务都会 write，然后马上执行 fsync；</li>
<li>sync_binlog =N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。</li>
</ul>
<h2 id="两阶段提交"><a class="markdownIt-Anchor" href="#两阶段提交"></a> 两阶段提交</h2>
<p>binlog 主从复制和 redo log 崩溃恢复需要保持一致，不然会出现<strong>主从数据不一致、备份数据与真实数据不一致</strong>等问题。MySQL 采用两阶段提交来避免两份日志之间的逻辑不一致，两阶段提交是一种<strong>分布式事务一致性协议</strong>。</p>
<p>两阶段提交：把单个事务的提交拆分成了 2 个阶段，分别是准备阶段和提交阶段（不是 commit 语句），每个阶段都由协调者和参与者共同完成。</p>
<h3 id="内部-xa-事务"><a class="markdownIt-Anchor" href="#内部-xa-事务"></a> 内部 XA 事务</h3>
<style>.ojuhofppsjky{zoom:50%;}</style><img data-src="/MySQL/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.drawio.png" class="ojuhofppsjky" alt="两阶段提交">
<p>为了保证这两个日志的一致性，MySQL 使用了内部 XA 事务。内部 XA 事务由 binlog 作为协调者，存储引擎是参与者，可以实现跨数据库事务。将 redo log 的写入拆成了<strong>两个状态：prepare 和 commit</strong>，中间再穿插写入binlog。</p>
<ul>
<li>如果 binlog 中没有当前内部 XA 事务的 XID，说明 redolog 完成刷盘，但是 binlog 还没有刷盘，则<strong>回滚事务</strong>。对应时刻 <strong>A 崩溃恢复</strong>的情况；</li>
<li>如果 binlog 中有当前内部 XA 事务的 XID，说明 redolog 和 binlog 都已经完成了刷盘，则<strong>提交事务</strong>。对应时刻 <strong>B 崩溃恢复</strong>的情况；</li>
</ul>
<p>对于处于 prepare 阶段的 redo log，即可以提交事务，也可以回滚事务，这取决于是否能在 binlog 中查找到与 redo log 相同的 XID，以 binlog 写成功为事务提交成功的标识。</p>
<h2 id="组提交"><a class="markdownIt-Anchor" href="#组提交"></a> 组提交</h2>
<p>采用<strong>组提交</strong>策略，减少 redolog 和 binlog 两次刷盘导致的 <strong>I/O 次数高</strong>和<strong>锁竞争激烈</strong>的问题。</p>
<blockquote>
<p>多事务场景下，两阶段提交会导致锁竞争激烈，因为为保证两个日志保存的数据库状态一致，需要加锁操作保证两阶段提交的原子性。</p>
</blockquote>
<p><strong>binlog 组提交机制</strong>：当有多个事务提交的时候，会将多个 binlog 刷盘操作合并成一个，从而减少磁盘 I/O 的次数。prepare 阶段不变，只针对 commit 阶段，将 commit 阶段拆分为三个阶段：</p>
<ul>
<li><strong>flush 阶段</strong>：多个事务按进入的顺序将 binlog 从 cache 写入文件（不刷盘）；5.7 之后在该阶段增加了 redo log 的组提交，即多个事务 redo log 统一刷盘；
<ul>
<li>类似于 XA 事务的 Prepare 阶段，如果在这一步完成后数据库崩溃，由于 binlog 中没有该组事务的记录，所以 MySQL 会在重启后回滚该组事务；</li>
</ul>
</li>
<li><strong>sync 阶段</strong>：对 binlog 文件做 fsync 操作（多个事务的 binlog 合并一次刷盘）；
<ul>
<li>类似于 XA 事务的 Commit 阶段，如果在这一步完成后数据库崩溃，由于 binlog 中已经有了事务记录，MySQL会在重启后通过 redo log 刷盘的数据继续进行事务的提交。</li>
</ul>
</li>
<li><strong>commit 阶段</strong>：各个事务按顺序做 InnoDB commit 操作；</li>
</ul>
<p>每个阶段都有一个队列，锁就只针对每个队列进行保护，不再锁住提交事务的整个过程。减小了锁粒度，这样就使得多个阶段可以并发执行，从而提升效率。</p>
<h2 id="总结模拟一次更新流程"><a class="markdownIt-Anchor" href="#总结模拟一次更新流程"></a> 总结模拟一次更新流程</h2>
<ul>
<li>MySQL 执行器检查记录是否在 buffer pool 中
<ul>
<li>若不在，将数据页从磁盘读入到 buffer pool；</li>
<li>若更新前与更新后数据不同，调用 存储引擎 执行更新操作；</li>
</ul>
</li>
<li>开启事务，记录 undo log，同时将 Undo 页的修改记录存在 redo log 中；</li>
<li>存储引擎更新数据，并标记数据页为脏页，同时将数据页的修改记录存在 redo log 中；
<ul>
<li>为了减少磁盘I/O，脏页选择合适时间持久化到硬盘，持久化后删除对应的 redo log；</li>
</ul>
</li>
<li>记录更新完毕，记录 binlog 至 binlog cache；</li>
<li>事务提交，将 redolog binlog 持久化到硬盘（两阶段提交；组提交）
<ul>
<li>prepare 阶段</li>
<li>commit 阶段</li>
</ul>
</li>
</ul>
<p>脏页刷盘的时机</p>
<ul>
<li>Redo log 满了；</li>
<li>BufferPool满了；</li>
<li>MySQL空闲；</li>
<li>后台线程定时 checkpoint；</li>
<li>事务提交时（一般不选）；</li>
</ul>
<h1 id="内存"><a class="markdownIt-Anchor" href="#内存"></a> 内存</h1>
<p><strong>Buffer Pool 缓存</strong>的内容包括：索引页、数据页、Undo 页、插入缓存页、自适应哈希索引、锁信息等。<code>innodb_buffer_pool_size</code>  默认 128MB。</p>
<p>为了管理这些在 Buffer Pool 中的缓存页，InnoDB 为每一个缓存页都创建了一个<strong>控制块</strong>，控制块信息包括：缓存页的表空间、页号、缓存页地址、链表节点等等。用三种链表管理不同状态的缓存块：</p>
<ul>
<li>Free List （空闲页链表），管理空闲页；</li>
<li>Flush List （脏页链表），管理脏页；</li>
<li>LRU List，管理脏页+干净页，将经常查询或可能将要查询的数据缓存在其中，而不常查询的数据就淘汰出去；</li>
</ul>
<p><strong>Free 链表</strong>：使用链表结构，快速找到空闲的缓存页；</p>
<p>每当需要从磁盘中加载一个页到 Buffer Pool 中时，就从 Free链表中取一个空闲的缓存页，并且把该缓存页对应的控制块的信息填上，然后把该缓存页对应的控制块从 Free 链表中移除</p>
<style>.ugcoyccojdtp{zoom: 67%;}</style><img data-src="/MySQL/freelist.drawio.png" class="ugcoyccojdtp" alt="img">
<p><strong>Flush 链表</strong>：使用链表结构，快速找到脏页；（结构类似于 Free 链表）</p>
<p>脏页落盘时，后台线程遍历 Flush 链表</p>
<h2 id="提高缓存命中率"><a class="markdownIt-Anchor" href="#提高缓存命中率"></a> 提高缓存命中率</h2>
<p>Buffer Pool 有三种页和链表用来管理数据</p>
<style>.tjzfrmwakozs{zoom:67%;}</style><img data-src="/MySQL/bufferpoll_page.png" class="tjzfrmwakozs" alt="img">
<ul>
<li>Free Page（空闲页），表示此页未被使用，位于 Free 链表；</li>
<li>Clean Page（干净页），表示此页已被使用，但是页面未发生修改，位于LRU 链表。</li>
<li>Dirty Page（脏页），表示此页「已被使用」且「已经被修改」，其数据和磁盘上的数据已经不一致。当脏页上的数据写入磁盘后，内存数据和磁盘数据一致，那么该页就变成了干净页。脏页同时存在于 LRU 链表和 Flush 链表。</li>
</ul>
<p>普通的LRU 算法会出现以下<strong>两个问题</strong></p>
<ul>
<li>预读失效：加载访问数据页时，提前加载进来的<strong>相邻数据</strong>页，即预读页，但后续并没有访问预读页；</li>
<li>Buffer Pool 污染：某一个 SQL 语句扫描了大量的数据时，将 Buffer Pool 里的所有页都替换出去，导致<strong>大量热数据被淘汰</strong>了，后续热数据被访问时会产生大量磁盘 I/O；
<ul>
<li>索引失效批量扫描的时候会出现污染</li>
</ul>
</li>
</ul>
<p><strong>解决办法</strong></p>
<ul>
<li>将 LRU 划分了 2 个区域：old 区域 和 young 区域。划分这两个区域后，预读的页就只需要加入到 old 区域的头部，当页被真正访问的时候，才将页插入 young 区域的头部。</li>
<li>只有同时满足<strong>被访问</strong>与在 <strong>old 区域停留时间超过 <code>innodb_old_blocks_time</code> 秒</strong>两个条件，才会被插入到 young 区域头部</li>
<li>young 区域优化：为了防止 young 区域节点频繁移动到头部。young 区域前面 1/4 被访问不会移动到链表头部，只有后面的 3/4被访问了才会</li>
</ul>
<h1 id="优化"><a class="markdownIt-Anchor" href="#优化"></a> 优化</h1>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/Redis/</url>
    <content><![CDATA[<p><s>先速通一遍，底层实现后续慢慢看书学</s></p>
<p>Redis 的特性：单线程、原子性、内存、数据结构、I/O 多路复用的非关系型数据库；总体设计思路遵循高性能、可扩展性、简单性和安全性</p>
<p>6.0 版本前网络 I/O 和命令处理都是单线程，6.0 版本后网络 I/O 采用多个线程处理</p>
<ul>
<li>大部分操作都在内存中完成。CPU 并不是制约 Redis 性能表现的瓶颈所在，而是机器的内存或者网络带宽</li>
<li>避免了多线程之间的竞争</li>
<li>I/O 多路复用机制</li>
</ul>
<h1 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h1>
<p>String 字符串</p>
<p>List 列表</p>
<p>Set 集合</p>
<p>Zset 有序集合</p>
<p>Hash 哈希</p>
<h1 id="持久化"><a class="markdownIt-Anchor" href="#持久化"></a> 持久化</h1>
<p>保证即使在服务器重启的情况下也不会丢失数据（或少量损失）</p>
<h2 id="aof-日志"><a class="markdownIt-Anchor" href="#aof-日志"></a> AOF 日志</h2>
<p>每执行一条写操作命令就追加到日志文件中</p>
<p>重写机制：后台子进程共享父进程内存，AOF 重写缓冲区</p>
<h2 id="rdb-快照"><a class="markdownIt-Anchor" href="#rdb-快照"></a> RDB 快照</h2>
<p>某一时刻的内存数据快照</p>
<h2 id="混合持久化"><a class="markdownIt-Anchor" href="#混合持久化"></a> 混合持久化</h2>
<p>前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据（重写缓冲区数据）。</p>
<h1 id="策略"><a class="markdownIt-Anchor" href="#策略"></a> 策略</h1>
<h2 id="过期删除策略"><a class="markdownIt-Anchor" href="#过期删除策略"></a> 过期删除策略</h2>
<p>惰性删除+定期删除</p>
<h2 id="内存淘汰策略"><a class="markdownIt-Anchor" href="#内存淘汰策略"></a> 内存淘汰策略</h2>
<p>仅淘汰过期数据：random、ttl、lru、lfu</p>
<p>淘汰所有数据：lru、lfu</p>
<h1 id="高可用"><a class="markdownIt-Anchor" href="#高可用"></a> 高可用</h1>
<h2 id="主从复制"><a class="markdownIt-Anchor" href="#主从复制"></a> 主从复制</h2>
<p>全量复制</p>
<img data-src="/Redis/ea4f7e86baf2435af3999e5cd38b6a26.png" class="" title="图片">
<ul>
<li>bgsave 命令是产生了一个子进程来做生成 RDB 文件的工作，是异步工作的</li>
</ul>
<p>基于长连接的命令传播</p>
<p>连接恢复时可以采用<strong>增量复制</strong>：repl_backlog_buffer 环形缓冲区保存了最近传播的写命令，若其中存着从服务器请求的 offset，就采用增量复制，否则采用全量复制</p>
<p><strong>如何应对异步复制导致的主从数据不一致？</strong></p>
<p>外部程序来监控主从节点间的复制进度</p>
<p><strong>主从切换如何减少数据丢失？</strong></p>
<ul>
<li>设置复制延迟限制 <code>min-slaves-max-lag</code></li>
<li>客户端降级措施，当 master 不可写，就把数据存到本地或 kafka 中等待主节点正常后再消费</li>
</ul>
<p><strong>集群脑裂导致数据丢失</strong></p>
<p>主节点必须要有至少 <code>min-slaves-to-write</code> 个从节点连接，主从数据复制和同步的延迟不能超过 <code>min-slaves-max-lag</code> 秒。否则原主节点就会被限制接收客户端写请求，客户端也就不能在原主节点中写入新数据，等到新的主节点上线一切恢复正常。</p>
<h2 id="哨兵机制"><a class="markdownIt-Anchor" href="#哨兵机制"></a> 哨兵机制</h2>
<blockquote>
<p>自动完成故障发现和故障转移，并通知给应用方，从而实现高可用性</p>
</blockquote>
<p>哨兵之间建立连接</p>
<style>.qridoevjkqqr{zoom:50%;}</style><img data-src="/Redis/a6286053c6884cf58bf397d01674fe80.png" class="qridoevjkqqr" alt="img">
<p>哨兵与从节点建立连接</p>
<style>.hfacrnfdgmnp{zoom:50%;}</style><img data-src="/Redis/fdd5f695bb3643258662886f9fba0aab.png" class="hfacrnfdgmnp" alt="img">
<h3 id="第一轮投票判断主节点下线"><a class="markdownIt-Anchor" href="#第一轮投票判断主节点下线"></a> 第一轮投票：判断主节点下线</h3>
<p>主观下线：主节点或者从节点没有在规定的时间内响应哨兵的 PING 命令</p>
<p>客观下线：一个哨兵判断主节点为「主观下线」后，就会向其他哨兵发起命令，通过多个哨兵节点一起判断主节点是否下线。哨兵的赞同票数达到哨兵配置文件中的 quorum 配置项设定的值则判断主节点客观下线</p>
<h3 id="第二轮投票选出哨兵-leader"><a class="markdownIt-Anchor" href="#第二轮投票选出哨兵-leader"></a> 第二轮投票：选出哨兵 leader</h3>
<ul>
<li>哪个哨兵节点判断主节点为「客观下线」，这个哨兵节点就是候选者，所谓的候选者就是想当 Leader 的哨兵。</li>
<li>候选者会向其他哨兵发送命令，表明希望成为 Leader 来执行主从切换，并让所有其他哨兵对它进行投票。选择哨兵 Leader：
<ul>
<li>第一，拿到半数以上的赞成票；</li>
<li>第二，拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值。</li>
</ul>
</li>
</ul>
<h3 id="由哨兵-leader-进行主从故障转移"><a class="markdownIt-Anchor" href="#由哨兵-leader-进行主从故障转移"></a> 由哨兵 leader 进行主从故障转移</h3>
<ul>
<li>第一步：在已下线主节点（旧主节点）属下的所有「从节点」里面，挑选出一个从节点，并将其转换为主节点，选择的规则：
<ul>
<li>过滤掉已经离线的从节点；</li>
<li>过滤掉历史网络连接状态不好的从节点；</li>
<li>将剩下的从节点，进行三轮考察：优先级、复制进度、ID 号。在每一轮考察过程中，如果找到了一个胜出的从节点，就将其作为新主节点。</li>
</ul>
</li>
<li>第二步：让已下线主节点属下的所有「从节点」修改复制目标，修改为复制「新主节点」；</li>
<li>第三步：将新主节点的 IP 地址和信息，通过「发布者/订阅者机制」通知给客户端；</li>
<li>第四步：继续监视旧主节点，当这个旧主节点重新上线时，将它设置为新主节点的从节点；</li>
</ul>
<h2 id="集群"><a class="markdownIt-Anchor" href="#集群"></a> 集群</h2>
<p>CRC16 算法 + 16384 取模，每个模数代表一个相应编号的哈希槽</p>
<p>切片 slot 槽，将数据分布在多个Redis节点上，每个节点负责一部分 slot 槽</p>
<h1 id="缓存"><a class="markdownIt-Anchor" href="#缓存"></a> 缓存</h1>
<h2 id="缓存雪崩-击穿-穿透"><a class="markdownIt-Anchor" href="#缓存雪崩-击穿-穿透"></a> 缓存雪崩、击穿、穿透</h2>
<h2 id="如何保证数据库和缓存一致性"><a class="markdownIt-Anchor" href="#如何保证数据库和缓存一致性"></a> 如何保证数据库和缓存一致性</h2>
<blockquote>
<p>采用 Cache Aside 旁路缓存策略：以数据库中的数据为准，缓存中的数据是按需加载的</p>
<ul>
<li>缺点：数据写入频繁时，缓存中的数据会被频繁的清理，降低缓存命中率</li>
</ul>
</blockquote>
<p>更新数据库+删除缓存：延迟双删</p>
<p>更新数据库+更新缓存：分布式锁</p>
<p>更新数据库+不更新缓存：较短的缓存有效期</p>
<p>删除缓存的时候失败了怎么办？采用异步删除的方式：</p>
<ul>
<li>消息队列确保缓存删除成功</li>
<li>订阅 MySQL 的 binlog，数据修改时删除缓存</li>
</ul>
<h1 id="实战"><a class="markdownIt-Anchor" href="#实战"></a> 实战</h1>
<h2 id="分布式锁"><a class="markdownIt-Anchor" href="#分布式锁"></a> 分布式锁</h2>
<blockquote>
<p>Redis + Lua 脚本，可以以原子性的方式执行一组命令，可用于保证锁释放操作的原子性（Lua 脚本执行期间 Redis 不会执行其他命令），但无法用于事务执行失败的回滚</p>
</blockquote>
<p>SET 命令的 NX 参数可以实现：key不存在才插入，可以用于实现分布式锁</p>
<p>优点：性能高效、实现方便、分布式高可用</p>
<p>缺点：不好设置超时时间（守护线程定期续约）、主从异步复制可能导致不可靠性</p>
<p>提高可靠性：客户端和多个独立的 Redis 节点依次请求申请加锁，如果客户端能够和半数以上的节点成功地完成加锁操作，那么就认为，客户端成功地获得分布式锁，否则加锁失败</p>
<h2 id="延迟队列"><a class="markdownIt-Anchor" href="#延迟队列"></a> 延迟队列</h2>
<p>有序集合 Zset，score 存储延迟执行的时间</p>
<h2 id="大-key-问题"><a class="markdownIt-Anchor" href="#大-key-问题"></a> 大 Key 问题</h2>
<p>会导致的问题</p>
<ul>
<li>由于 Redis 单线程处理，大 Key 的增删改查都很耗时，会导致工作线程阻塞、客户响应超时</li>
<li>内存分布不均匀，集群场景下 slot 槽数据量不均</li>
<li>阻塞网络传输</li>
</ul>
<p>解决办法</p>
<ul>
<li>拆分大 key</li>
<li>及时清理大 key，异步删除 unlink</li>
</ul>
<h2 id="发布者订阅者"><a class="markdownIt-Anchor" href="#发布者订阅者"></a> 发布者/订阅者</h2>
<blockquote>
<p>订阅命令：subscribe channel  [channel … ]</p>
</blockquote>
<style>.rhwioracfsft{zoom:40%;}</style><img data-src="/Redis/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAwrfmooXoirHljYHkuIk=,size_20,color_FFFFFF,t_70,g_se,x_16.png" class="rhwioracfsft" alt="img">
<p><a href="https://blog.csdn.net/w15558056319/article/details/121490953">Link</a></p>
<h2 id="事务回滚"><a class="markdownIt-Anchor" href="#事务回滚"></a> 事务回滚</h2>
<p>Redis 不支持回滚，事务没有原子性（要么全部成功要么全部失败）</p>
<h2 id="管道"><a class="markdownIt-Anchor" href="#管道"></a> 管道</h2>
<p>批处理技术，可以一次处理多个 Redis 命令，减少多个命令执行时的网络等待</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Rpc 框架</title>
    <url>/Rpc/</url>
    <content><![CDATA[<img data-src="/Rpc/A5B6F28E3286E3F920698A1D904CE4B0.png" class="" title="图片说明">
<p>分布式系统的 CAP 理论</p>
<ul>
<li>一致性（Consistency）：所有节点访问同一份最新的数据副本</li>
<li>可用性（Availability）：非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）</li>
<li>分区容错性（Partition Tolerance）：分布式系统出现网络分区的时候，仍然能够对外提供服务。</li>
</ul>
<p>Nacos 配置中心 注册中心</p>
<h1 id="rpc-框架"><a class="markdownIt-Anchor" href="#rpc-框架"></a> RPC 框架</h1>
<blockquote>
<p>泛指调用远程的函数的方法，对编解码和网络层有特殊的优化，从而有更高的效率。</p>
</blockquote>
<p>RPC 框架主要由 Server、Client、Server Stub、Client Stub 组件组成</p>
<ul>
<li>Client Stub 主要是将客户端的请求参数、请求服务地址、请求服务名称做一个封装，并发送给 Server Stub</li>
<li>Server Stub 主要用于接收 Client Stub 发送的数据并解析，去调用 Server 端的本地方法</li>
</ul>
<p>层次结构：代理曾、注册中心层（服务发现、注册、管理）、</p>
<p>RPC 协议定制化程度高，可以采用体积更小的 Protobuf 或其他序列化协议去保存结构体数据，同时也不需要像 HTTP 那样考虑各种浏览器行为，如 302 重定向跳转。因此性能也会更好一些。其底层不仅可以通过 tcp udp 实现，也可以通过 http 实现。</p>
<p>RPC 协议会建个连接池，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，用完放回去，下次再复用，可以说非常环保。</p>
<p>目前，对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。</p>
<h1 id="dubbo-上线问题"><a class="markdownIt-Anchor" href="#dubbo-上线问题"></a> Dubbo 上线问题</h1>
<p>记录、学习、汇总实习和技术博客中看到的 Dubbo 实战遇到的问题</p>
<h2 id="服务端接口不指定通讯协议导致-oom"><a class="markdownIt-Anchor" href="#服务端接口不指定通讯协议导致-oom"></a> 服务端接口不指定通讯协议导致 OOM</h2>
<p>问题背景：</p>
<p>问题描述：</p>
<ul>
<li>
<p>开发人员使用方没有配置接口的 protocol 字段，而是写在接口实现类上</p>
</li>
<li>
<p><code>dubbo-3.0.4</code> 框架：</p>
<ul>
<li>若没有指定 protocol 字段，会创建服务端提供的所有协议的 invoker</li>
<li>EasyREST 包<code>createClientInvoker</code>创建 REST 协议的 invoker 时需要 HttpMethod 参数</li>
<li>由于注解写在实现类而不是接口上面，导致消费端无法共享相应的 REST 配置信息，即 HttpMethod 为 null，因此 RESTClient 创建失败</li>
<li>在服务更新过程中，客户端每次都是全量更新注册中心的服务端信息，这个过程中如果 invoker 一直注册失败，会不断将失败的<code>Client</code>存到<code>List&lt;ResteasyClient&gt;</code>中，如果有 n 台机器需要依次更新，这时客户端的数组中会存 n*n 个失败的连接实例，从而导致 OOM</li>
</ul>
</li>
</ul>
<p>解决方法（针对框架，开发人员需要牢记 Dubbo 配置必须在接口上）：</p>
<ul>
<li>ResteasyClient 对象由 RestProtocol 协议对象持有，针对没有创建成功 invoker 的场景应把其对应的 ResteasyClient <u>销毁</u>掉</li>
</ul>
<p>销毁方法</p>
<ul>
<li>用<code>Map&lt;String, ResteasyClient&gt;</code>代替 <code>List&lt;ResteasyClient&gt;</code>，同一个服务端只存一次</li>
<li>用<code>WeakHashMap&lt;String, ResteasyClient&gt;</code>自动回收不用的 ResteasyClient（参考<a href="https://github.com/apache/dubbo/pull/4629">pr</a>）</li>
</ul>
<p><a href="https://tech.youzan.com/ji-ci-dubbofu-wu-fa-xian-dao-zhi-de-oom/">参考</a></p>
<h2 id="父子线程并发-rpc-调用死锁"><a class="markdownIt-Anchor" href="#父子线程并发-rpc-调用死锁"></a> 父子线程并发 RPC 调用死锁</h2>
<p>问题描述：</p>
<ul>
<li>直接通过 <code>Executors</code> 构造 固定数量+无限长等待队列 线程池，该线程池在共享的无界队列上操作的固定数量的线程。在任何时候，最多nThreads线程将处于活动处理任务状态。如果在所有线程都处于活动状态时提交额外的任务，它们将在队列中等待，直到有线程可用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>并发调用 Rpc 接口获取返回值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Future&lt;String&gt; future = executor.submit(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> 数据查询任务;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>数据查询任务中存在父子调用关系，数据查询任务同步调用 Redis 查询缓存和 Rpc 调用微服务获得数据。如果本地 Redis 缓存中能获得数据，就直接返回缓存值并取消 Rpc 调用 <code>future.cancel(true)</code>。</li>
</ul>
<p>解决办法</p>
<ul>
<li>父子任务分开并发执行，耗时的异步线程应做好线程池隔离</li>
<li><code>CompletableFuture.anyOf(task1,tsak2)</code> 优先取先完成的那个任务的返回值</li>
</ul>
<p><a href="https://heapdump.cn/article/646639">参考</a></p>
<h1 id="尝试开发基础版-rpc-中间件"><a class="markdownIt-Anchor" href="#尝试开发基础版-rpc-中间件"></a> 尝试开发基础版 Rpc 中间件</h1>
<p><strong>服务发现流程</strong>：使用远程服务的时候首先需要配置一个 dubbo.xml 文件或者在使用的类加上<code>@Reference</code>，二者都是用来对dubbo消费者引用服务进行一些配置，然后应用在启动的时候会将配置信息转化为一个<code>ReferenceBean</code>对象，并调用<code>createProxy</code>方法创建一个远程服务接口的代理对象。</p>
<p>代理对象的 <strong>invoke 创建</strong>：启动时主动订阅注册中心，会显示地调用一次<code>notify</code>接口，这个接口会尝试将远程服务注册的<code>url</code>转换成一个本地的<code>invoker</code>。</p>
<ul>
<li>转换过程中会根据具体的 <code>protocol</code> 创建对应的 <code>invoker</code>，如 Rest 和 Dubbo 需要解析不同的参数。</li>
</ul>
<p>服务注册地址发生改变时：会通知给消费者，dubbo 协议里面明确讲到服务发生改变会全量更新所有客户端的缓存</p>
<h2 id="netty-数据传输"><a class="markdownIt-Anchor" href="#netty-数据传输"></a> Netty 数据传输</h2>
<blockquote>
<p>在网络通信中，序列化和编码通常是结合使用的。<strong>序列化将对象转换为字节流，编码将字节流转换为网络传输所需的格式</strong>（如按照协议规定的格式进行编码）。在接收端，<strong>解码将网络传输的数据解析为原始的格式（如解码成对象）</strong>，以便进行进一步的处理和使用。</p>
</blockquote>
<p>Netty 是一个高性能<strong>事件驱动型非阻塞 IO 框架</strong>：</p>
<ul>
<li>提供了 ByteBuf 容器，更方便地处理数据。<code>ByteBuf</code> 在重写编解码器的 encoder/decoder 方法中作为参数传入。</li>
<li>channel</li>
</ul>
<p>编码：先序列化，再压缩，最后写进 ByteBuf 对象中</p>
<p>解码：从 ByteBuf 对象中读，然后转成我们需要的对象</p>
<h2 id="代理模式"><a class="markdownIt-Anchor" href="#代理模式"></a> 代理模式</h2>
<p><strong>静态代理</strong></p>
<blockquote>
<p>静态代理中，我们对目标对象的每个方法的增强都是手动完成的（后面会具体演示代码），非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改）且麻烦(需要对每个目标类都单独写一个代理类)。 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。</p>
</blockquote>
<p>从 JVM 层面来说， 静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</p>
<p>静态代理的步骤</p>
<ul>
<li>定义一个接口及其实现类；</li>
<li>创建一个代理类同样实现这个接口</li>
<li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</li>
</ul>
<h2 id="jdk-动态代理"><a class="markdownIt-Anchor" href="#jdk-动态代理"></a> JDK 动态代理</h2>
<ul>
<li>定义一个接口及其实现类；</li>
<li>自定义 InvocationHandler 并重写 invoke 方法，在 invoke 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li>
<li>通过 <code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code> 方法创建代理对象；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcClientProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 在代理类内，根据传入的类 clazz，获得代理对象</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getProxy</span><span class="params">(Class&lt;T&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(clazz.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;clazz&#125;, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当通过代理类调用的所有方法，实际上调用的是这个invoke（传入的只是服务接口，具体的实现在服务端实现类中）</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么是如何调用服务端实现类的代码的呢？<strong>注入</strong></p>
<ol>
<li>在实例化 bean 之后，postProcessAfterInitialization 方法被调用。</li>
<li>对于每个 bean 类的字段，检查是否标记了 @RpcReference 注解。</li>
<li>如果发现标记了 @RpcReference 注解的字段，根据注解中的信息创建相应的 RpcServiceConfig 对象。</li>
<li>通过 RpcClientProxy 创建了一个代理对象 clientProxy，这个代理对象实现了 declaredField.getType() 所表示的接口，这个接口可能就是 HelloService 接口或其它接口，取决于 helloService 字段的类型。</li>
<li>这个代理对象 clientProxy 会在方法调用时委托给 RpcClientProxy 的 invoke 方法，该方法负责处理远程调用的逻辑。</li>
<li>通过反射设置 clientProxy 到 HelloController 类的 helloService 字段上，替换了原来的字段值。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">clientProxy</span> <span class="operator">=</span> rpcClientProxy.getProxy(declaredField.getType());</span><br><span class="line">declaredField.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    declaredField.set(bean, clientProxy);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="传输协议"><a class="markdownIt-Anchor" href="#传输协议"></a> 传输协议</h2>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">*   0     1     2     3     4        5     6     7     8         9        10     11     12   13   14 15 16</span><br><span class="line">*   +-----+-----+-----+-----+--------+----+----+----+------+-----------+-------+-------+-----+---+-----+----+</span><br><span class="line">*   |   magic   code        |version | full length         | messageType| codec|compress|    RequestId       |</span><br><span class="line">*   +-----------------------+--------+---------------------+-----------+-----------+-----------+------------+</span><br><span class="line">*   |                                         body                                                            |</span><br><span class="line">*   +-------------------------------------------------------------------------------------------------------+</span><br><span class="line">* 4B  magic code（魔法数）   1B version（版本）   4B full length（消息长度）    1B messageType（消息类型）</span><br><span class="line">* 1B compress（压缩类型） 1B codec（序列化类型）    4B  requestId（请求的Id）</span><br></pre></td></tr></table></figure>
<h2 id="注册中心"><a class="markdownIt-Anchor" href="#注册中心"></a> 注册中心</h2>
<p>服务注册：在 zk 里面创建一个对应的持久节点</p>
<p>当我们的服务被<strong>注册进 zookeeper</strong> 的时候，我们将完整的服务名称 rpcServiceName （class name+group+version）作为根节点 ，子节点是对应的服务地址（ip+端口号）。相关代码在 <code>ZkServiceProviderImpl.publishService()</code> 中。</p>
<p>如果我们要<strong>获得某个服务对应的地址</strong>的话，就直接根据完整的服务名称来获取到其下的所有子节点，然后通过具体的负载均衡策略取出一个就可以了。相关代码在 <code>ZkServiceDiscoveryImpl.lookupService()</code> 中。</p>
<h3 id="zookeeper-客户端"><a class="markdownIt-Anchor" href="#zookeeper-客户端"></a> Zookeeper 客户端</h3>
<blockquote>
<p>Curator 是 Netflix 公司开源的一套zookeeper客户端框架，解决了很多Zookeeper客户端非常底层的细节开发工作，包括连接重连、反复注册Watcher和NodeExistsException异常等等。项目内采用 CuratorUtils 类调用 Curator。</p>
</blockquote>
<p>重试策略：ExponentialBackoffRetry是指数退避重试策略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// zk的对外接口，后面我们要干什么只需要通过单例模式获得这个类，然后用这个类的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ServiceProvider</span> &#123;</span><br><span class="line">    <span class="comment">// 添加到本地 serviceMap 中（远程Rpc调用，获取本地的调用类）</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addService</span><span class="params">(RpcServiceConfig rpcServiceConfig)</span>;</span><br><span class="line">    Object <span class="title function_">getService</span><span class="params">(String rpcServiceName)</span>;</span><br><span class="line">    <span class="comment">// 注册服务到 zookeeper 中（服务发现与注册）</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">publishService</span><span class="params">(RpcServiceConfig rpcServiceConfig)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="负载均衡"><a class="markdownIt-Anchor" href="#负载均衡"></a> 负载均衡</h2>
<p>随机选取策略<br />
轮询策略<br />
加权轮询策略<br />
最少活跃连接策略<br />
一致性 Hash 策略</p>
<h2 id="序列化"><a class="markdownIt-Anchor" href="#序列化"></a> 序列化</h2>
<ul>
<li>序列化：将数据结构或对象转化为二进制字节流</li>
<li>反序列化：将在序列化过程中生成的二进制字节流转化为数据结构或对象</li>
</ul>
<p><strong>数据传输过程中，可能会出现粘包和半包问题，你是如何解决的？</strong></p>
<p>自定义消息结构（其他的还有固定长度传输、特殊字符分割）：MagicNumber 魔数、ContentLength 请求长度</p>
]]></content>
      <categories>
        <category>Java开发</category>
      </categories>
      <tags>
        <tag>分布式通讯框架</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/SpringMVC/</url>
    <content><![CDATA[<h1 id="tomcat"><a class="markdownIt-Anchor" href="#tomcat"></a> Tomcat</h1>
<p>Tomcat 是基于 HTTP 协议的 Web 服务器，工作流程图 <a href="https://blog.csdn.net/qq_19782019/article/details/80292110">Link</a></p>
<img data-src="/SpringMVC/2018120522281643.gif" class="" title="img">
<h2 id="servlet"><a class="markdownIt-Anchor" href="#servlet"></a> Servlet</h2>
<p>Servlet 接口定义了 Servlet 与 servlet容器 之间的契约。这个契约是：Servlet容器将Servlet类载入内存，并产生 Servlet 实例和调用它具体的方法。但是要注意的是，<strong>在一个应用程序中，每种 Servlet 类型只能有一个实例</strong>。类比 SpringMVC 中每一个 Mapping 对应一个控制层方法【不确定】</p>
<p>对于每一个应用程序，Servlet容器还会创建一个ServletContext对象。这个对象中封装了上下文（应用程序）的环境详情。每个应用程序只有一个ServletContext。每个Servlet对象也都有一个封装Servlet配置的ServletConfig对象。</p>
<h1 id="springmvc"><a class="markdownIt-Anchor" href="#springmvc"></a> SpringMVC</h1>
<p>流程图</p>
<img data-src="/SpringMVC/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5q2i5q2l5YmN6KGM,size_20,color_FFFFFF,t_70,g_se,x_16.png" class="" title="SpringMVC流程图">
<ul>
<li>由<code>DispatcherServlet</code> 从<code>HandlerMappings</code>中匹配对应的<code>Handler</code>。此时只是获取到了对应的<code>Handler</code>，然后拿着这个<code>Handler</code>去寻找对应的适配器，即：<code>HandlerAdapter</code>：让固定参数的 Servlet 处理方法调用灵活的 Handler 来处理；</li>
<li>执行 <code>Controller</code> 处理业务逻辑， 执行完成之后返回一个 <code>ModeAndView</code> 或 Json 格式数据；</li>
</ul>
<p>HandlerMapping/HandlerAdapter 的<strong>适配器模式</strong>：</p>
<p>SpringMVC 的 Handler 有多种实现方式（如继承 Controller 接口、继承 HttpRequestHandler 接口、基于注解 @Controller 的控制器）。由于实现方式不一样，调用方式就不确定，就需要适配器模式将所有实现方式都统一成同一个接口。把任何一个 Handler 都适配成一个HandlerAdapter，从而可以做统一的流程处理，不用耦合具体的处理器，模糊掉具体的实现。</p>
<p>Spring MVC会为每一个标记了 @Controller 的类创建一个控制器实例（bean），并且根据这些类中的 @RequestMapping 注解来配置 URL 到方法的映射。这些映射信息通常会被存储在一个叫做 <code>HandlerMapping</code> 的组件中</p>
]]></content>
      <categories>
        <category>Java开发</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>实习笔试题汇总</title>
    <url>/%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="2024427-美团笔试"><a class="markdownIt-Anchor" href="#2024427-美团笔试"></a> 2024.4.27 美团笔试</h1>
<p>和携程差不多，签到题速通，后续疯狂折磨人，过不了一点。感觉题目难度差的好大，要么我秒杀它，要么它秒杀我</p>
<p><strong>第三题</strong></p>
<blockquote>
<p>回溯写了半天，结果只能过20%。看别人是用前缀和+dp，那就是和腾讯第四题类似了，当时学会了现在又忘了，真难崩。</p>
</blockquote>
<p>小美拿到了一个数组，她每次操作可以将两个相邻元素合并为一个元素，合并后的元素为原来两个元素之和。小美希望最终数组的最小值不小于 k。她想知道有多少种不同的合并结果?</p>
<p>输入描述：第一行输入两个正整数n,k，代表数组大小和数组的最大值。第二行输入几个正整数q:，代表小美拿到的数组。1 ≤ n,k,ai &lt; 200</p>
<p>输出描述：输出一个整数，代表小美可以得到多少种不同的结果。由于结果可能很大，输出对10^9+7取模的结果。</p>
<p>eg：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">4 4</span><br><span class="line">2 3 4 5</span><br></pre></td></tr></table></figure>
<p>输出 4</p>
<p><strong>回溯</strong>解法，只过20%（加了dp保存过程值也没用）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution_3</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp;</span><br><span class="line">    <span class="type">int</span>[] a;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dp = <span class="keyword">new</span> <span class="title class_">int</span>[a.length];</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        Arrays.fill(dp, -<span class="number">1</span>);</span><br><span class="line">        System.out.println(backtrack(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> sum, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index==a.length) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (sum==<span class="number">0</span> &amp;&amp; dp[index]!=-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> dp[index];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isBegin</span> <span class="operator">=</span> sum==<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=index; i&lt;a.length; i++) &#123;</span><br><span class="line">            sum += a[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sum&gt;=k) &#123;</span><br><span class="line">                cnt += backtrack(<span class="number">0</span>, i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isBegin) dp[index] = cnt;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt(), k = in.nextInt();</span><br><span class="line">        <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            a[i] = in.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Solution_3</span>().solve(a, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自己试试写<strong>前缀和+dp</strong>（思路重要真的很重要，二十分钟就写出来了）</p>
<blockquote>
<p>dp[i] 表示<s>数字 0-i 的方案数</s>[0, i) 的字串可以拆分的种类，状态转移方程为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mo>∑</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i] = \sum dp[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>（j-i 大于等于 k 的数量总和，用前缀和求出）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt(), k = in.nextInt();</span><br><span class="line">        <span class="type">int</span>[] sum = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        sum[<span class="number">1</span>] = in.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            sum[i] += sum[i-<span class="number">1</span>] + in.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sum[i] - sum[j] &gt;= k) &#123;</span><br><span class="line">                    dp[i] += dp[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Q1</strong>：前缀和算法初始化时为什么都要设置 <code>[0, 0] = 1</code> 呢？ 如: <code>dp[0] = 1</code> or <code>map.put(0,1)</code></p>
<p><strong>A1</strong>：想不明白呢，需要对状态转移数组 dp[] 的理解非常正确才行</p>
<p><strong>第四题</strong></p>
<p>小美拿到了一棵树，其中有一些节点被染成红色。</p>
<blockquote>
<p>大佬的思路：预打表小质数，然后dfs遍历连通块，统计块内每个红点的质因子，得到结点编号的乘积的质因子分解形式，根据质因子数量计算因子个数。对于我来说，需要背一下并查集的模板。</p>
</blockquote>
<p>小美定义一个红色连通块的权值为:所有节点编号乘积的因子数量。小美想知道，所有红色连通块的权值之和是多少?由于答案过大，请对10^9+ 7取模。</p>
<p><strong>输入描述</strong>：</p>
<p>第一行输入一个正整数n，代表节点数量。<br />
第二行输入一个长度为几的、仅由’R&quot;和&quot;W组成的字符串，第i个字符为’R’代表;号节点被染成红色，&quot;W代表未被染色。保证至少有一个节点被染成红色。</p>
<p>接下来的n - 1行，每行输入2个正整数4,U，代表u号节点和u号节点有一条边连接。1 ≤n ≤ 10^5, 1 ≤u,v≤n</p>
<p><strong>输出描述</strong>：</p>
<p>一个整数，代表所有红色连通块的权值之和。</p>
<h1 id="2024425-华为测评"><a class="markdownIt-Anchor" href="#2024425-华为测评"></a> 2024.4.25 华为测评</h1>
<p>华子免笔试，只有测评了。看网上好多人测评挂了我都惊呆了，还好没和其他的厂一样直接做测评而是上我搜了下，其他的厂可以不去但华子我必然拿下（小心谨慎哈哈哈）</p>
<p>华子要什么样性格的人？（前后回答要一致）</p>
<ul>
<li>不需要凸显自己的能力、表达自己的个性，更多的是团队合作</li>
<li>遇到挫折要坚持，遇到问题会咨询</li>
<li>热爱工作，吃苦耐劳，积极向上</li>
</ul>
<p>（准备了又好像没准备，就这样吧，希望能过！阿弥陀佛财神爷保佑！）</p>
<p><strong>复盘</strong>：有些过于没有压力了，前面每一题都认真思考结果 40min 过完才做了一半，人家都是 40min 就做完了，实在是有些拖拉（但这个要认真选真的很难啊，得回忆自己平常的所思所想所做才然后选个答案，后续时间紧张直接主观臆断速度还是很快的）。<strong>只要时间不紧张就慢慢做，一旦时间紧张了才开始全神贯注做，这可真的是一个坏毛病，得改。</strong></p>
<p>后续学习工作中都应该有这个意识，主动养成专注的习惯，要做就认真仔细专注的做事情！</p>
<h1 id="2024416-携程笔试"><a class="markdownIt-Anchor" href="#2024416-携程笔试"></a> 2024.4.16 携程笔试</h1>
<p>前两道签到题，后面一个半小时纯折磨</p>
<p>第三题</p>
<p>游游拿到了一个数组，她每次操作可以将相邻的两个素数元素进山314行合并，合并后的新数为原来的两个数之和，并删除原来两个数。游游希望最终数组的元素数量尽可能少，你能帮帮她吗?</p>
<blockquote>
<p>第一行输入一个正整数n，代表数组的大小。<br />
第二行输入几个正整数a_i，代表数组的元素<br />
1 ≤ n &lt; 10^5<br />
1 ≤ a_i &lt; 10^6</p>
</blockquote>
<p>返回合并结束后的元素的数量</p>
<p><strong>题目分析</strong>：素数是只能被1和自身整除的数。针对这道题可以用到，它的一大特性：除了 2 之外两个素数之和一定是偶数（即，一定不是素数）</p>
<p>因此只要先把所有 2 和素数合并，后续只需要判断还有多少相邻的素数即可。</p>
<p>做题的时候没有考虑到 <code>7 2 2 3</code> 这种情况，即素数和 2 合并完的结果如果是素数，还需要和判断他的左边还有没有 2，有的话还要合并，即代码中的 <code>i--</code> 部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrimeMerge</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        List&lt;Integer&gt; numbers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取数组元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            numbers.add(scanner.nextInt());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并素数，优先处理2</span></span><br><span class="line">        mergePrimesWithPriorityToTwo(numbers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出最终数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : numbers) &#123;</span><br><span class="line">            System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查一个数是否是素数的辅助函数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i * i &lt;= num; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergePrimesWithPriorityToTwo</span><span class="params">(List&lt;Integer&gt; numbers)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并2与其相邻的素数，得到一个新的素数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numbers.size(); ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers.get(i) == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// 检查左边是否有素数可以合并</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; isPrime(numbers.get(i - <span class="number">1</span>)) &amp;&amp; isPrime(numbers.get(i - <span class="number">1</span>) + <span class="number">2</span>)) &#123;</span><br><span class="line">                    numbers.set(i - <span class="number">1</span>, numbers.get(i - <span class="number">1</span>) + <span class="number">2</span>);</span><br><span class="line">                    numbers.remove(i);</span><br><span class="line">                    i--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; numbers.size() - <span class="number">1</span> &amp;&amp; isPrime(numbers.get(i + <span class="number">1</span>)) &amp;&amp; isPrime(numbers.get(i + <span class="number">1</span>) + <span class="number">2</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 检查右边是否有素数可以合并</span></span><br><span class="line">                    numbers.set(i, numbers.get(i) + numbers.get(i + <span class="number">1</span>));</span><br><span class="line">                    numbers.remove(i + <span class="number">1</span>);</span><br><span class="line">                    i--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 没有可以合并的素数，继续下一个数</span></span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并剩余的素数对</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numbers.size() - <span class="number">1</span>; ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime(numbers.get(i)) &amp;&amp; isPrime(numbers.get(i + <span class="number">1</span>))) &#123;</span><br><span class="line">                numbers.set(i, numbers.get(i) + numbers.get(i + <span class="number">1</span>));</span><br><span class="line">                numbers.remove(i + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第四题</p>
<p>定义一棵树的直径为：任意两个节点的距离的最大值。现在定义f(i)：对i号节点上再连接一个新的子叶节点后，树的直径长度。现在要求f(1)到f(n)的值。</p>
<p>输入描述：第一行输入一个正整数n，代表树的节点数量。</p>
<p>接下来的n-1行，每行输入两个正整数u和v，代表u号节点和v号节点之间有一条长度为1的边连接。</p>
<p>变量的范围：1≤n≤10的五次方，1≤u，v≤n。</p>
<p><strong>题目分析：</strong> 树的直径引出树形 dp 算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    List&lt;TreeNode&gt; children;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        children = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeDiameter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] f; <span class="comment">// 存储每个节点的最大直径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt(); <span class="comment">// 树的节点数量</span></span><br><span class="line"></span><br><span class="line">        f = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        TreeNode[] nodes = <span class="keyword">new</span> <span class="title class_">TreeNode</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            nodes[i] = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接节点之间的关系</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            nodes[u].children.add(nodes[v]);</span><br><span class="line">            nodes[v].children.add(nodes[u]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每个节点，添加一个新的子叶节点，计算f(i)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 添加新的子叶节点</span></span><br><span class="line">            nodes[i].children.add(<span class="keyword">new</span> <span class="title class_">TreeNode</span>(-<span class="number">1</span>));</span><br><span class="line">            <span class="comment">// 计算当前最大直径</span></span><br><span class="line">            dfs(nodes[i], <span class="literal">null</span>, i);</span><br><span class="line">            <span class="comment">// 删除添加的子叶节点</span></span><br><span class="line">            nodes[i].children.remove(nodes[i].children.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            System.out.print(f[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归计算以当前节点为根的子树的直径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode node, TreeNode parent, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxDepth1</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 最大深度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxDepth2</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 次大深度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历当前节点的子节点</span></span><br><span class="line">        <span class="keyword">for</span> (TreeNode child : node.children) &#123;</span><br><span class="line">            <span class="keyword">if</span> (child == parent) <span class="keyword">continue</span>; <span class="comment">// 不访问父节点，防止死循环</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">childDepth</span> <span class="operator">=</span> dfs(child, node, i) + <span class="number">1</span>; <span class="comment">// 递归计算子节点的深度</span></span><br><span class="line">            <span class="keyword">if</span> (childDepth &gt; maxDepth1) &#123;</span><br><span class="line">                maxDepth2 = maxDepth1;</span><br><span class="line">                maxDepth1 = childDepth;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDepth &gt; maxDepth2) &#123;</span><br><span class="line">                maxDepth2 = childDepth;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新当前状态的最大直径</span></span><br><span class="line">        f[i] = Math.max(f[i], maxDepth1 + maxDepth2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxDepth1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="202449-恒生笔试"><a class="markdownIt-Anchor" href="#202449-恒生笔试"></a> 2024.4.9 恒生笔试</h1>
<ol>
<li>下列代码的返回值</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>/<span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*<span class="number">3</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.20.2">根据Java语言规范文档规定</a>。在 try-catch-finally 语句块中，finally 语句块中的 return/抛出异常（立即结束语句）的优先级最高，程序会优先返回 finally 语句块中的立即结束语句的结果，此时 try-catch 语句块中的 return/抛出异常（立即结束语句）的结果就会被丢弃掉。</p>
<ol start="2">
<li>SQL 语句</li>
</ol>
<p>联结语法、INNER JOIN 语法</p>
<ol start="3">
<li>初始资金 M，N 天价格信息，K 次交易后，能赚多少钱？（动态规划）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 根据输入计算最大收益</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> M double浮点型 初始资金</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> N int整型 历史价格天数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> historyPrices double浮点型一维数组 N天历史价格</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> K int整型 最大允许交易次数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> double浮点型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">get_max_profit</span> <span class="params">(<span class="type">double</span> M, <span class="type">int</span> N, <span class="type">double</span>[] historyPrices, <span class="type">int</span> K)</span> &#123;</span><br><span class="line">    <span class="type">double</span>[][] dp = <span class="keyword">new</span> <span class="title class_">double</span>[K+<span class="number">1</span>][N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;N; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;=K; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=K; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;N; j++) &#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">max</span> <span class="operator">=</span> dp[i][j-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> t=<span class="number">0</span>; t&lt;j; t++) &#123;</span><br><span class="line">                <span class="type">double</span> <span class="variable">rest</span> <span class="operator">=</span> dp[i-<span class="number">1</span>][t]%historyPrices[t], buy = (dp[i-<span class="number">1</span>][t]-rest)/historyPrices[t];</span><br><span class="line">                max = Math.max(max, buy*historyPrices[j]+rest);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][j] = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[K][N-<span class="number">1</span>]-dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2024331-腾讯笔试"><a class="markdownIt-Anchor" href="#2024331-腾讯笔试"></a> 2024.3.31 腾讯笔试</h1>
<p>没做好记录，只记了没做出来的第四题，其他四道题 AC 了三道，还有一道通过 97% 我怀疑是样例有问题[手动狗头]</p>
<ol start="4">
<li>给你 n 个数，这 n 个数要被拆成 k 份，对每份中的数字求异或，求各份异或总和的最大值（和恒生第二题的思路基本一样）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">    <span class="type">long</span>[][] dp = <span class="keyword">new</span> <span class="title class_">long</span>[k + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[<span class="number">1</span>][i + <span class="number">1</span>] = in.nextInt() ^ dp[<span class="number">1</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span>[] prefix = dp[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 拆分为 i 份</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="comment">// 从头到尾遍历：将第 1~j 个元素拆成 i 份</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 将第 [1,s] 个元素拆成 i-1 份，(s,j] 是最后一份</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> j - <span class="number">1</span>; s &gt;= i - <span class="number">1</span>; s--) &#123;</span><br><span class="line">                <span class="comment">// 异或的优先级小于加减法</span></span><br><span class="line">                max = Math.max(max, dp[i - <span class="number">1</span>][s] + (prefix[j] ^ prefix[s]));</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][j] = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(dp[k][n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>找工作</category>
      </categories>
      <tags>
        <tag>笔试记录</tag>
      </tags>
  </entry>
  <entry>
    <title>实习面试题汇总</title>
    <url>/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="2024510-华为一面"><a class="markdownIt-Anchor" href="#2024510-华为一面"></a> 2024.5.10 华为一面</h1>
<ul>
<li>让我调了下摄像头，好展示我的颜，然后自我介绍</li>
<li>手撕算法（由于太紧张写代码一直在絮絮叨叨）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">业务发送数据到对端，由于网络原因会出现概率丢包；现发送1W条数据到对端，指定输入N为丢包数量，随后列出丢包数据的具体位置；你有机会进行补包，M为可补包的数量，请返回补包后最大可连续发送数据的数量</span><br><span class="line"></span><br><span class="line">无需实现交互式输入，只需实现如下函数</span><br><span class="line"><span class="type">int</span> <span class="title function_">maxContinuousPackages</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] lostPackages, <span class="type">int</span> m)</span></span><br></pre></td></tr></table></figure>
<p>测试样例</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">示例1：</span><br><span class="line">3</span><br><span class="line">1 5 10</span><br><span class="line">1</span><br><span class="line">-----</span><br><span class="line">9995</span><br><span class="line">本示例中，丢包数量N为3，丢包位置分布为第1、5、10三个位置，补包数量M为1；在第10个位置补包后可连续发包数量最大，为10000 - 5 = 9995</span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line">4</span><br><span class="line">4 6 20 9990</span><br><span class="line">2</span><br><span class="line">-----</span><br><span class="line">9994</span><br><span class="line"></span><br><span class="line">示例3：</span><br><span class="line">4</span><br><span class="line">1500 4100 5000 8000</span><br><span class="line">2</span><br><span class="line">---</span><br><span class="line">6499</span><br><span class="line"></span><br><span class="line">示例4：</span><br><span class="line">4</span><br><span class="line">4 699 700 9990</span><br><span class="line">2</span><br><span class="line">---</span><br><span class="line">9985</span><br><span class="line"></span><br><span class="line">示例5：</span><br><span class="line">6</span><br><span class="line">100 2700 5100 7498 7499 7500</span><br><span class="line">2</span><br><span class="line">---</span><br><span class="line">7397</span><br></pre></td></tr></table></figure>
<p>AC 代码，中途写错了还考虑了动态规划，导致三十分钟用满了，说是最多 30 min 再满一点我就 GG 了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxContinuousPackages</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] lostPackages, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> lostPackages.length, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] data = <span class="keyword">new</span> <span class="title class_">int</span>[len+<span class="number">1</span>];</span><br><span class="line">    data[<span class="number">0</span>] = lostPackages[<span class="number">0</span>]-<span class="number">1</span>;</span><br><span class="line">    data[data.length-<span class="number">1</span>] = <span class="number">10000</span> - lostPackages[len-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;data.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        data[i] = lostPackages[i] - lostPackages[i-<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m++;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">        sum += data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ans = sum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=m; i&lt;data.length; i++) &#123;</span><br><span class="line">        sum -= data[i-m];</span><br><span class="line">        sum += data[i];</span><br><span class="line">        ans = Math.max(ans, sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans+m-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>算法思路讲一遍，中间做错了删掉的代码也要讲为什么做错了，然后把代码截了个图</li>
<li>说一下自己的技术栈</li>
</ul>
<p>Java基础、JUC、JVM、SpringBoot、MySQL</p>
<ul>
<li>挑一个自己熟悉的讲一讲，选了 MySQL 索引</li>
</ul>
<p>B+ 树结构，聚簇索引、二级索引、和 B 树的对比</p>
<ul>
<li>如果让你建一张表，你会如何设计索引</li>
</ul>
<p>联合索引、覆盖索引、前缀索引</p>
<ul>
<li>IOC 容器的理解</li>
</ul>
<p>代理所有单例的创建，防止频 GC</p>
<ul>
<li>那为什么不直接用单例模式而用 IOC 容器的 Bean</li>
</ul>
<p>还能实现 Bean 的生命周期管理，可以实现 AOP</p>
<ul>
<li>用 Python 能否实现 AOP</li>
</ul>
<p>我说不能，AOP 实现需要操作字节码，他说行，我道歉</p>
<ul>
<li>设计模式讲一下</li>
</ul>
<p>讲了 SpringMVC 中 HanderAdapter 用到的适配器模式</p>
<ul>
<li>Rest 和 Rpc 有什么区别</li>
</ul>
<p>首先说了实习的时候 Rpc 底层有用到 Rest 传输数据包，而这没有本质区别</p>
<p>http 头部冗余，效率低；但 http3 效率挺好但没普及</p>
<p>Rpc 更适合后台内部调用，效率高；Rest 适合所有场景，适配做的好</p>
<ul>
<li>OS 为什么需要虚拟地址</li>
</ul>
<p>没复习到的八股，说了下虚拟地址映射到物理地址，页的映射，道歉</p>
<ul>
<li>会什么语言</li>
</ul>
<p>还会点 Python，不懂 C</p>
<ul>
<li>反问，进去需要什么技术栈</li>
</ul>
<p>Java 微服务开发等</p>
<h1 id="2024430-小红书一面"><a class="markdownIt-Anchor" href="#2024430-小红书一面"></a> 2024.4.30 小红书一面</h1>
<blockquote>
<p>以后有机会的话可以问问 HR 这个部门是干什么的，再做相应的准备，不然临时抱佛脚可能抱错佛了。</p>
</blockquote>
<p>他温我哭，面试官又帅又贴心，看到我紧张也不催我。但是他一直在叹气，搞得我压力好大。面试总共30min，后续手撕了一道算法题20min，<mark>已经好几次算法题读题不准确了，连续字串和子序列最容易理解错</mark></p>
<ol>
<li>
<p>自我介绍</p>
</li>
<li>
<p>深入讲一下实习经历（完全没想到会问这个）</p>
</li>
</ol>
<p>数据中台项目</p>
<ul>
<li>了解项目架构，微服务和多模块开发，数据流过程</li>
<li>尝试开发字典结构</li>
<li>AOP 日志：运行时间、调用接口、速度、ip</li>
<li>调用微服务获取运维大屏数据，并展示：线程池、CompletableFuture 线程先后调用关系</li>
</ul>
<ol start="3">
<li>日志 AOP，能不能查找、过滤逻辑，为什么不用 ELK。如果有监控平台的话，为什么不存到监控平台里（看得出来面试官很奇怪怎么只有 AOP 记录日志，没有其他的相关功能）</li>
</ol>
<p>Leader 安排的，直接存到 MySQL 中即可（搪塞一下）</p>
<ol start="4">
<li>AOP 底层原理</li>
</ol>
<p>CGLib、Java 原生，SpringBoot 中只使用 CGLib 代理（一定要说 Spring 是可以配置的）</p>
<ol start="5">
<li>行，继续说（我超，怎么说啊说啥啊）</li>
</ol>
<p>扯到 Rpc 服务端接口代理；底层原理，编译成字节码，读入 JVM 前做一层代理</p>
<ol start="6">
<li>有 A 类中的 BC 方法。B 方法使用注解代理，再用 C 方法通过 this.B() 调用，会出现什么逻辑</li>
</ol>
<p>会直接调用 B 方法</p>
<ol start="7">
<li><strong>那如何让 this.B() 的代理生效呢</strong></li>
</ol>
<p>获取到被代理的 Bean，再调用 B 方法【如何获取被 AOP 代理的 Bean？】</p>
<ol start="8">
<li>修改一个数据，存储层、缓存层一起用的话怎么办</li>
</ol>
<p>双删一致性</p>
<ol start="9">
<li>单例模式实际应用场景，Spring 底层的设计有哪些用到了单例模式</li>
</ol>
<p>Spring 单例模式的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> sychronize Singleton <span class="title function_">getInstace</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">            <span class="keyword">if</span>(instance==<span class="literal">null</span>) instance=<span class="keyword">new</span> <span class="title class_">Singleton</span>(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><mark>底层针对单例模式的使用：IOC 容器、BeanFactory</mark>、工具类、线程池、ApplicationContext自身、</p>
<ol start="10">
<li>底层创建 Bean 是线程安全的吗？一定会用到 <code>synchronized</code> 吗？</li>
<li>启动时直接把所有 Bean 都创建好，可不可以保证线程安全？</li>
</ol>
<p>Bean 生命周期中，初始化和依赖注入是两个阶段，不会相互影响，因此是安全的</p>
<ol start="10">
<li>MySQL 的索引机制</li>
</ol>
<p>聚簇索引；相比于跳表，B+ 树可以有效降低树的高度；【InnoDB 的 B+ 树到达四层的情况下能装下多少数据？】</p>
<ol start="10">
<li>B+ 和 B 树的区别</li>
</ol>
<p>顺序访问叶子节点；中间节点不会存到下层节点</p>
<ol start="11">
<li>MySQL 乐观锁和悲观锁</li>
</ol>
<p><s>MVCC</s> 时间戳或版本号字段；间隙锁行锁表锁【悲观锁底层如何实现的？】</p>
<ol start="12">
<li><strong>update 用的是行锁还是表锁</strong></li>
</ol>
<p>在 update 语句的 where 条件没有使用索引，就会全表扫描，于是就会对所有记录加上 next-key 锁（记录锁 + 间隙锁），相当于把整个表锁住了</p>
<ol start="13">
<li>二级索引、联合索引、最左前缀匹配原则</li>
<li>Redis 怎么实现过期删除策略（不是内存淘汰策略）</li>
<li>缓存穿透</li>
</ol>
<p>太紧张了，回答成缓存雪崩了</p>
<ol start="13">
<li><strong>Redis 大 Key 问题的定义，解决方法</strong></li>
<li><strong>线程池的核心线程池的个数是如何设置的？</strong></li>
</ol>
<p>线程等待时间所占比例越高，需要越多线程；线程计算时间所占比例越高，需要越少线程；</p>
<ul>
<li>CPU密集型任务：N+1</li>
<li>IO密集型任务：2N</li>
</ul>
<p>手撕算法：【300. 最长递增子序列】一开始贪心没写出来，后面用 dp 写出来的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line"><span class="type">int</span>[] data = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">    data[i] = in.nextInt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">    dp[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data[j]&lt;data[i]) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i], dp[j]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = Math.max(ans, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(ans);</span><br></pre></td></tr></table></figure>
<p><strong>总结QA</strong></p>
<p><strong>Q</strong>：JDK 动态代理和 cglib 的底层实现的区别？</p>
<p><strong>A</strong>：JDK：目标类加载后，使用 Native 方法在<strong>运行时动态生成代理类</strong>，将切面织入到代理类中；CGLib：目标类加载后，字节码构建框架 <strong>ASM 构建字节码</strong>文件，并生成目标类的子类，将切面逻辑加入到子类中；AspectJ：<strong>编译期间</strong>，将切面织入代理类中，得到代理后的字节码；</p>
<p><strong>Q</strong>：类上有 AOP 注解，如何分别获取被代理前和代理后的这个类呢？</p>
<p><strong>A</strong>：代理前：直接 new 一个对象；代理后：通过 <code>ApplicationContext</code> 或 <code>@Autowired</code> 注解来获取代理 Bean 对象，即<strong>容器中只会存放被代理过的类</strong>；</p>
<p><strong>Q</strong>：单例模式 Bean 是线程安全的吗？</p>
<p><strong>A</strong>：主要取决于 Bean 是否是无状态的，即 Bean 中是否包含可变的状态信息；</p>
<p><strong>Q</strong>：MySQL 如何实现乐观锁和悲观锁？</p>
<p><strong>A</strong>：乐观锁：版本号或时间戳字段；悲观锁：InnoDB 所有的行锁算法都是基于索引实现的，锁定的都是索引或索引区间；</p>
<p><strong>Q</strong>：update 用的是行锁还是表锁【TODO】</p>
<p><strong>A</strong>：Where 条件判断有索引就走索引，走索引就锁索引，索引锁了就是行锁，不然就是表锁</p>
<p><strong>Q</strong>：Redis 怎么实现过期删除策略</p>
<p><strong>A</strong>：惰性删除+定期删除（不采用定时删除）<img data-src="/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5.jpg" class="" title="img"></p>
<p><strong>Q</strong>：Redis 大 Key 问题的定义，解决方法</p>
<p><strong>A</strong>：从应用服务、持久化角度分别作答</p>
<p><strong>定义</strong>：某个 key 所对应的 value 过大。具体来说，对于 String 类型的数据，如果其大小超过 10KB，一般被认为是大 key；而对于 set、zset、hash 等集合类型的数据，如果其包含的元素数量超过 5000 条，也通常被视为大 key。</p>
<p><strong>解决办法</strong>：</p>
<ul>
<li>把大 key 拆分成一个一个小 key；</li>
<li>将大 Key 拆分成多个小 Key 并用 Hash 结构存储；</li>
<li>定时检查 Redis 是否存在大 key ，如果该大 key 是可以删除的，不要使用 DEL 命令删除，因为该命令删除过程会阻塞主线程，而是用 unlink 命令（Redis 4.0+）删除大 key，因为该命令的删除过程是异步的，不会阻塞主线程；</li>
</ul>
<p>造成的不良影响：</p>
<ul>
<li>应用服务：Redis 是单线程的，大 Key 写入和删除会阻塞其他命令；内存分布不均，失去内存时空局部性特性；网络阻塞，IO 压力大；</li>
<li>持久化：Always 参数下数据同步到硬盘时会阻塞主线程；经常性触发AOF 重写机制；AOF 重写机制和 RDB 快照（bgsave 命令）的过程，都会分别通过 fork() 函数创建一个子进程来处理任务，会导致阻塞父进程（主线程）；集群模式下内存分布不均</li>
</ul>
<h1 id="2024410-恒生一面"><a class="markdownIt-Anchor" href="#2024410-恒生一面"></a> 2024.4.10 恒生一面</h1>
<p>虽然面试只有 17min，但感觉再长一点我真的要蚌埠住了，哭（在杭电十二教线下面的）</p>
<p>反思：自我介绍准备不足，都要开始面试了还在考虑怎么改（其实也怪他们面试通知太晚了，不怪我嘻嘻）平时学的不扎实，说不出 AQS 的底层实现原理我可以接受，但连 AQS 都没提到实在是太蠢了，果然还是准备的不够充分。谢谢恒生一巴掌拍醒了我，认清了自己还是个小菜鸡。摆正心态，继续努力！！！</p>
<ol>
<li>自我介绍</li>
</ol>
<p>面试官看了简历，说“不愧是软件工程内容比别人多多了”，面试官真的是很认真的把简历从头看到尾（泪目）</p>
<ol start="2">
<li>Rpc 项目具体是什么</li>
</ol>
<p>因为自我介绍里说了为什么要做 RPC 项目，面试官顺势问了。</p>
<p>简单说了上段实习中用到了自定义 Cluster 集群策略，因为 Dubbo 自带的 ClusterRules（广播、失败立刻返回）没有涉及到轮询检查离线任务是否完成的功能，所以 Leader 让我利用 Dubbo 的 SPI 机制做了一个查询微服务的计算过程是否完成的方法，然后挂载在 META-INF/dubbo 下就 Dubbo 框架就可以直接调用该集群执行方式（当时说的并没有这么清晰，还是太菜了呜呜）</p>
<ol start="3">
<li>如何分析 dump 文件</li>
</ol>
<p>感觉简历里唯一吸引面试官的就是如何处理 OOM Crash 了。</p>
<p>测试报服务异常，线程池等待队列过长；Leader 带我用 jstack 获得线程的状态；发现该线程池中的所有线程都处在阻塞状态，并且都阻塞在父线程；查看父子线程调用关系和 Executors.<em>newFixedThreadPool</em>(25) 底层原理，发现 FixedThreadPool 使用了无限长的阻塞队列，父线程未执行完成，且子线程只能在队列中等待，造成死锁所以队列一直在变长</p>
<ol start="4">
<li>synchronized Reentrantlock 的具体使用场景有什么不同</li>
</ol>
<p>只知道底层实现原理不同且都是可重入锁，并不知道具体使用场景的区别（哪来的这么真实业务多场景啊喂）</p>
<ol start="5">
<li>MySQL 调优</li>
</ol>
<p>愚蠢的我只知道构建索引、优化表结构和增大 BufferPool，好在后续上网也没找到什么很好的方法。或许<mark>预编译 SQL 语句</mark>是个不错的想法，根据 MySQL 运行过程推出的优化方法。</p>
<h1 id="项目困难解决方法"><a class="markdownIt-Anchor" href="#项目困难解决方法"></a> 项目困难/解决方法</h1>
<p>实习</p>
<ul>
<li>分布式微服务架构</li>
<li>多线程并发，编排任务执行流程</li>
<li>沟通协作，和同事交流，理解别人的想法的同时清楚地表达自己的想法；让领导清楚自己在做什么，工作量和重难点在哪；</li>
</ul>
<p>LLM 应用开发</p>
<ul>
<li>LLM 部署，技术选型 FastChat、FastApi、VLLM 加速</li>
<li>Python 开发生态差，要造轮子，MySQL 连接池、事务、并发线程池等</li>
<li>Prompt 构建，数据切分、数据集构建：分词、分段、Embedding 计算</li>
</ul>
<p>RPC 中间件</p>
<ul>
<li>Bean 生命周期</li>
<li>Netty 数据传输</li>
<li>分布式注册中心：zk（CP、zab算法）</li>
</ul>
<p>三友</p>
<ul>
<li>数据库缓存一致性设计</li>
<li>新需求的开发</li>
</ul>
<h1 id="面试"><a class="markdownIt-Anchor" href="#面试"></a> 面试</h1>
<blockquote>
<p>由于错误使用 Dubbo 注解导致的 JVM 异常问题；Rpc 中间件采用 Netty 传输数据、Zookeeper 注册服务;调度各微服务，聚合并缓存数据；我还和同事一起分析解决了线上告警事故；</p>
</blockquote>
<p><strong>自我介绍</strong>：</p>
<p>面试官您好，很荣幸能来参加华为的面试，我叫王哲文，目前在杭州电子科技大学读研，本科就读于浙大城市学院。</p>
<p>本科期间我加入了黑胡桃实验室，参与了智慧实验室和时间序列预测等项目，还在实验室举办的 2020 年谷歌开发者大会上分享了自己的项目经验。我在浙江华坤道威数据科技有限公司实习期间，主要负责日志切面和运维大屏的开发，在这期间我积累了企业级分布式微服务项目的开发经验。</p>
<p>在读研期间，我加入了大数据与城市计算实验室，主要负责三友阴极板项目的后端开发和某涉密项目的大语言模型应用开发。在项目开发过程中，我不仅更加深入掌握了 SpringBoot、MySQL、Redis 等主流技术，还了解了 Langchain、PyTorch、Milvus 等前沿技术。在工作之余，我还学习了 Rpc 中间件的架构和设计思想，并开发了一个简易的轻量级 Rpc 中间件。此外，我还搭建了个人博客网站，定期发布学习笔记和技术总结，不断沉淀自己的开发经验。</p>
<p>最后，我非常希望能有机会加入华为，将所学知识应用到实际工作中，并与优秀的团队一起共同成长。谢谢！</p>
<p><a href="https://www.bilibili.com/read/cv13183086/#:~:text=%EF%BC%88%E7%AE%80%E5%8C%96%E7%89%88%EF%BC%89,%E5%8D%8E%E4%B8%BA%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BB%B7%E5%80%BC%E8%A7%82%E6%9C%89%E5%9B%9B%E4%B8%AA%E6%96%B9%E9%9D%A2%EF%BC%9A1%E3%80%81%E4%BB%A5%E5%AE%A2%E6%88%B7%E4%B8%BA%E4%B8%AD%E5%BF%83%EF%BC%8C%E5%AE%83%E5%8F%AF%E4%BB%A5%E7%A1%AE%E5%AE%9A%E5%A5%8B%E6%96%97%E7%9A%84%E6%96%B9%E5%90%91%3B2%E3%80%81%E4%BB%A5%E5%A5%8B%E6%96%97%E8%80%85%E4%B8%BA%E6%9C%AC%EF%BC%8C%E5%AE%83%E5%8F%AF%E4%BB%A5%E6%8F%90%E4%BE%9B%E6%B4%BB%E5%8A%9B%E7%9A%84%E6%BA%90%E6%B3%89%3B3%E3%80%81%E9%95%BF%E6%9C%9F%E8%89%B0%E8%8B%A6%E5%A5%8B%E6%96%97%EF%BC%8C%E8%BF%99%E6%98%AF%E5%AF%B9%E4%BA%BA%E4%BF%AE%E8%BA%AB%E7%9A%84%E4%B8%80%E4%B8%AA%E8%BF%87%E7%A8%8B%3B4%E3%80%81%E5%9D%9A%E6%8C%81%E8%87%AA%E6%88%91%E6%89%B9%E5%88%A4%EF%BC%8C%E5%9C%A8%E6%89%B9%E5%88%A4%E4%B8%AD%E8%83%BD%E5%A4%9F%E5%BE%97%E5%88%B0%E4%BF%AE%E5%BF%83%E3%80%82">华为核心价值观</a>：以客户为中心，以奋斗者为本，长期艰苦奋斗，坚持自我批判</p>
<p>科研&amp;项目：</p>
<ul>
<li>
<p>担任角色；项目背景；前期调研；创新点</p>
</li>
<li>
<p>项目有哪些难点</p>
</li>
<li>
<p>开发过程中遇到问题如何解决</p>
</li>
</ul>
<p>未来职业规划</p>
<ul>
<li>为了达成这些规划具体会做些行动</li>
</ul>
<p>绩点排名</p>
<p>如何看待华为公司？为什么想来华为公司进行实习？</p>
<p>能够实习多长时间？半年，立刻到岗</p>
<p>面试技巧</p>
<ul>
<li>
<p>回答问题的时候不能想到什么说什么，思维要有逻辑性，直击重点，有逻辑性的表达</p>
</li>
<li>
<p>展开问题，进一步作答，不要等着面试官提问题</p>
</li>
</ul>
<p>开闭原则：新增代替修改</p>
]]></content>
      <categories>
        <category>找工作</category>
      </categories>
      <tags>
        <tag>面试记录</tag>
      </tags>
  </entry>
  <entry>
    <title>AugESC</title>
    <url>/2023/AugESC_%20Large-scale%20Data%20Augmentation%20for%20Emotional%20Support%20Conversation%20with%20Pre-trained%20Language%20Models/</url>
    <content><![CDATA[<p><strong>Title:</strong> Large-scale Data Augmentation for Emotional Support Conversation with Pre-trained Language Models</p>
<blockquote>
<p>开放式对话数据增强的研究</p>
</blockquote>
<span id="more"></span>
<h1 id="论文速览"><a class="markdownIt-Anchor" href="#论文速览"></a> 论文速览</h1>
<h2 id="abstract"><a class="markdownIt-Anchor" href="#abstract"></a> Abstract</h2>
<ul>
<li>利用LLM进行数据增强，使用公开的对话帖子触发各种主题的对话</li>
</ul>
<h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2>
<ul>
<li>目前工作的缺陷
<ul>
<li>成本高、耗时长</li>
<li>预算限制，所收集的对话规模小，主题少</li>
</ul>
</li>
<li>本文主要贡献
<ul>
<li>关键发现</li>
<li>使用 GPT-J 和公开对话帖子触发各种主题的对话</li>
<li>构建机器增强数据集AUGES，具有更广泛和多样化的主题覆盖范围，可以提供更有效的情感支持</li>
</ul>
</li>
</ul>
<h2 id="related-work"><a class="markdownIt-Anchor" href="#related-work"></a> Related Work</h2>
<ul>
<li>预训练模型</li>
<li>预训练模型的数据增强</li>
</ul>
<h2 id="key-findings"><a class="markdownIt-Anchor" href="#key-findings"></a> Key Findings</h2>
<ul>
<li>语言模型优于对话模型
<ul>
<li>语言模型存储了从大规模训练语料库中学习到的更丰富的知识，有助于更好地泛化到各种对话主题</li>
<li>与会话模型 BlenderBot 相比，gpt生成的对话具有更好的对话连贯性和一致性</li>
</ul>
</li>
<li>语言模型比交互式仿真更适合开放式对话数据增强</li>
<li>提示GPT不如微调GPT模型
<ul>
<li>提示型GPT-3生成可控性差</li>
<li>只有微调才能掌握任务场景和所需特征</li>
</ul>
</li>
<li>少样本（Few-shot）微调导致更好的泛化和更高的多样性
<ul>
<li>保持语言模型的内在知识</li>
<li>增加调优样本或训练步骤会导致对域外主题的泛化能力差</li>
<li>在大规模自动数据增强的帮助下，训练对话模型可能只需要少量手动策划的对话样本</li>
</ul>
</li>
<li>信息性查询（第一个对话帖子）是触发主题对话的必要条件
<ul>
<li>泛型和无信息的查询往往导致离题和肤浅的对话</li>
</ul>
</li>
</ul>
<h2 id="methodology"><a class="markdownIt-Anchor" href="#methodology"></a> Methodology</h2>
<ul>
<li>主干模型：GPT-3，微调后的GPT-J</li>
<li>提示模板：对话场景+情感支持</li>
<li>将第一个对话框作为触发查询，模型生成后续的对话</li>
<li>不采用Prompt提示，使用ESConv微调GPT-J</li>
<li>触发Query
<ul>
<li>数据来源：EmpatheticDialogues（移情对话数据集）Reddit（心理健康相关的帖子）</li>
<li>保留带有负面情绪的Query</li>
</ul>
</li>
<li>过滤结果，删除非法对话</li>
</ul>
<h2 id="augesc"><a class="markdownIt-Anchor" href="#augesc"></a> AUGESC</h2>
<p>相比ESConv对话轮次更少，内容更长。语料库规模的扩大导致唯一二元分词的数量</p>
<ul>
<li>ESConv中的对话话题与数据收集时期(如covid, pandemic, christmas)密切相关</li>
<li>AUGESC-ED 涵盖了更多关于日常生活的主题(例如，汽车、狗、房子、邻居)</li>
<li>AUGESC-Reddit 涵盖了关于心理健康的主题(例如，抑郁、焦虑、治疗师)</li>
</ul>
<h2 id="quality-evaluation"><a class="markdownIt-Anchor" href="#quality-evaluation"></a> Quality Evaluation</h2>
<p>在信息一致性、话题一致性和对话基础等方面存在问题</p>
<h2 id="interactive-evaluation"><a class="markdownIt-Anchor" href="#interactive-evaluation"></a> Interactive Evaluation</h2>
<blockquote>
<p>AUGESC是对ESConv的一种补充，用AUGESC+ESConv训练出来的模型表现优于只使用ESConv的模型</p>
</blockquote>
<h2 id="conclusion"><a class="markdownIt-Anchor" href="#conclusion"></a> Conclusion</h2>
<p>AUGESC能够显著增强对话模型提供情感支持的能力</p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>情绪支持对话</tag>
        <tag>对话数据集增强</tag>
      </tags>
  </entry>
  <entry>
    <title>Control Globally, Understand Locally</title>
    <url>/2023/Control%20Globally,%20Understand%20Locally_%20A%20Global-to-Local%20Hierarchical%20Graph%20Network%20for%20Emotional%20Support%20Conversation/</url>
    <content><![CDATA[<p><strong>Title:</strong> Control Globally, Understand Locally. A Global-to-Local Hierarchical Graph Network for Emotional Support Conversation.</p>
<p>论文的创新点在于在Encoder和Decoder之间加了一层 GCNConv 和 RGCNConv</p>
<img data-src="/2023/Control%20Globally,%20Understand%20Locally_%20A%20Global-to-Local%20Hierarchical%20Graph%20Network%20for%20Emotional%20Support%20Conversation/image-20240414083742062-17138602623661-17138606243731.png" class="" title="image-20240414083742062-17138602623661">
<span id="more"></span>
<h1 id="论文速览"><a class="markdownIt-Anchor" href="#论文速览"></a> 论文速览</h1>
<h2 id="abstract"><a class="markdownIt-Anchor" href="#abstract"></a> Abstract</h2>
<ul>
<li>目前研究的缺陷
<ul>
<li>关注序列上下文信息，忽略了全局原因和局部心理意图与其的层次关系</li>
</ul>
</li>
<li>本文
<ul>
<li>提出了一个全局到局部的<strong>层次图网络</strong>来捕获多源信息(全局原因、局部意图和对话历史)并建模它们之间的层次关系，该网络由一个多源编码器、一个层次图推理器和一个全局引导解码器组成</li>
<li>设计了一个新的训练目标来监测全局的语义信息</li>
</ul>
</li>
</ul>
<h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2>
<ul>
<li>探索求助者情绪问题的原因：<strong>全局</strong>地控制情感支持对话的整个流程</li>
<li>了解求助者的心理意图：帮助系统<strong>局部</strong>了解求助者当前时的心理状态</li>
<li>本文目标
<ul>
<li>捕获全局原因和局部心理意图</li>
<li>建模全局与局部之间的关系</li>
</ul>
</li>
<li>解决方法【全局到局部层次图网络GLHG】
<ul>
<li>多源编码器：COMET提取局部心理意图</li>
<li>层次图推理机：全局原因(对话级)、局部心理意图(句子级)和对话历史之间的层次关系进行建模</li>
<li>解码器中设计了一个新的训练目标来监控全局原因的语义信息</li>
</ul>
</li>
</ul>
<h2 id="related-work"><a class="markdownIt-Anchor" href="#related-work"></a> Related Work</h2>
<ul>
<li>图建模对话
<ul>
<li>GCN 利用自我和对话者间依赖性来模拟会话上下文</li>
<li>EGAE 使用图网络捕获面向任务对话中的对话模式</li>
</ul>
</li>
<li>常识性知识
<ul>
<li>与本人有关的心理状态：xReact、xIntent</li>
</ul>
</li>
</ul>
<h2 id="approach"><a class="markdownIt-Anchor" href="#approach"></a> Approach</h2>
<ul>
<li>问题定义</li>
<li>多源编码器
<ul>
<li>BlenderBot Encoder + Max-pooling</li>
<li>上下文 + 全局原因 + 局部原因</li>
</ul>
</li>
<li>分层图推理机
<ul>
<li>GAT 图注意力网络：其他邻域信息的特征传播到当前节点，具有确定节点之间重要性和相关性的优点</li>
<li>
<img data-src="/2023/Control%20Globally,%20Understand%20Locally_%20A%20Global-to-Local%20Hierarchical%20Graph%20Network%20for%20Emotional%20Support%20Conversation/1701777471738-5656cb06-b30d-458c-9dd1-432cf59fc949.png" class="" title="img">注意力函数（2017出版)
</li>
<li>
<img data-src="/2023/Control%20Globally,%20Understand%20Locally_%20A%20Global-to-Local%20Hierarchical%20Graph%20Network%20for%20Emotional%20Support%20Conversation/1701777606138-33d97b8c-8966-4a59-9359-ce99195ba4db.webp" class="" title="image.png"> <img data-src="/2023/Control%20Globally,%20Understand%20Locally_%20A%20Global-to-Local%20Hierarchical%20Graph%20Network%20for%20Emotional%20Support%20Conversation/1701777482262-fd172bc6-5f7f-4b43-b667-c12cd9b52505.png" class="" title="img">注意力机制
</li>
<li>
<img data-src="/2023/Control%20Globally,%20Understand%20Locally_%20A%20Global-to-Local%20Hierarchical%20Graph%20Network%20for%20Emotional%20Support%20Conversation/1701777489757-3d64bf9e-8b95-4298-a754-239e59ec6e7b.png" class="" title="img">
</li>
<li>
<img data-src="/2023/Control%20Globally,%20Understand%20Locally_%20A%20Global-to-Local%20Hierarchical%20Graph%20Network%20for%20Emotional%20Support%20Conversation/1701777519559-801ad4da-0c7f-47f2-8ab6-ed20e4e19101.png" class="" title="img">注意力机制
</li>
<li>
<img data-src="/2023/Control%20Globally,%20Understand%20Locally_%20A%20Global-to-Local%20Hierarchical%20Graph%20Network%20for%20Emotional%20Support%20Conversation/1701777507833-1ff3f1f2-17cb-4ba0-991b-a61b42818cfc.png" class="" title="img">
</li>
</ul>
</li>
<li>Global-guide 解码器
<ul>
<li>响应生成
<ul>
<li>
<img data-src="/2023/Control%20Globally,%20Understand%20Locally_%20A%20Global-to-Local%20Hierarchical%20Graph%20Network%20for%20Emotional%20Support%20Conversation/1701777873314-d88aa900-555f-40b2-8a87-4589351ce738.png" class="" title="img">，v表示图神经网络得到的全局变量
</li>
</ul>
</li>
<li>监督全局语义信息：预测问题类型
<ul>
<li>
<img data-src="/2023/Control%20Globally,%20Understand%20Locally_%20A%20Global-to-Local%20Hierarchical%20Graph%20Network%20for%20Emotional%20Support%20Conversation/1701777996376-86594b70-a6b5-4f21-90e2-e6bbdbc222b0.png" class="" title="img">
</li>
</ul>
</li>
</ul>
</li>
<li>联合训练
<ul>
<li>对数似然损失+交叉熵损失</li>
<li>
<img data-src="/2023/Control%20Globally,%20Understand%20Locally_%20A%20Global-to-Local%20Hierarchical%20Graph%20Network%20for%20Emotional%20Support%20Conversation/1701778036470-9378fc9b-a533-40a9-9990-69ffe0036656.png" class="" title="img"><img data-src="/2023/Control%20Globally,%20Understand%20Locally_%20A%20Global-to-Local%20Hierarchical%20Graph%20Network%20for%20Emotional%20Support%20Conversation/1701778063569-1fc4c281-c256-4804-ba39-785ddd2e4b1e.png" class="" title="img">
</li>
</ul>
</li>
</ul>
<h2 id="experiments"><a class="markdownIt-Anchor" href="#experiments"></a> Experiments</h2>
<ul>
<li>指标：plexity (PPL), BLEU-n (B-n), ROUGE-L (R-L), Distinct-1(D-1), and Distinct-2 (D-2)</li>
<li>由于有了意图特征，提出建议更具体有效</li>
</ul>
<h2 id="conclusion"><a class="markdownIt-Anchor" href="#conclusion"></a> Conclusion</h2>
<ul>
<li>全局到局部的层次图网络(Global-to-Local Hierarchical Graph network, GLHG)来捕获多源信息并从全局到局部的角度建模层次关系</li>
<li>新的训练目标“预测Seeker遇到问题的类型”</li>
</ul>
<h1 id="关注的问题-本文的优势"><a class="markdownIt-Anchor" href="#关注的问题-本文的优势"></a> 关注的问题 / 本文的优势</h1>
<h1 id="解决方法-创新点"><a class="markdownIt-Anchor" href="#解决方法-创新点"></a> 解决方法 / 创新点</h1>
<ul>
<li><strong>多源编码器</strong>利用情境信息并将心理意图与COMET结合，捕获全局原因和局部意图</li>
<li><strong>分层图推理机</strong>在全局原因、局部心理意图和对话历史之间进行交互，建模不同层次的关系（hierarchical graph reasoner）</li>
</ul>
<h1 id="实验结论"><a class="markdownIt-Anchor" href="#实验结论"></a> 实验结论</h1>
<h1 id="有待提升的部分"><a class="markdownIt-Anchor" href="#有待提升的部分"></a> 有待提升的部分</h1>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>情绪支持对话</tag>
        <tag>异构图神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>DQ-HGAN</title>
    <url>/2023/DQ-HGAN_%20A%20heterogeneous%20graph%20attention%20network%20based%20deep%20Q-learning%20for%20emotional%20support%20conversation%20generation/</url>
    <content><![CDATA[<p><strong>Title:</strong> A heterogeneous graph attention network based deep Q-learning for emotional support conversation generation</p>
<span id="more"></span>
<h1 id="论文速览"><a class="markdownIt-Anchor" href="#论文速览"></a> 论文速览</h1>
<h2 id="abstract"><a class="markdownIt-Anchor" href="#abstract"></a> Abstract</h2>
<ul>
<li>关注的问题
<ul>
<li>动态建模对用户状态，包含个体的意图和情感</li>
<li>综合各类因素选择最合适的支持策略</li>
</ul>
</li>
<li>提出的方法【基于异构图注意力网络的深度Q-learning情感支持对话生成】
<ul>
<li>为了捕获用户意图、情感和历史对话之间的交互关系，基于意图词典和情感分类器，构建了异构图注意力网络</li>
<li>采用基于DQN的最优响应策略以指导响应生成，优于传统的基于规则或启发式方法</li>
</ul>
</li>
</ul>
<h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2>
<ul>
<li>目前研究
<ul>
<li>ESC任务要求能够确定求助者的心理意图和情绪状态，以便提供适当的支持。因此整合意图识别和情感识别对于提高情感支持对话的质量至关重要，且目前的方法对用户状态建模不充分。</li>
</ul>
</li>
<li>关注的问题
<ul>
<li>建模用户状态</li>
<li>选择最优策略，以产生有效的保障响应</li>
</ul>
</li>
<li>提出的方法
<ul>
<li>设计了基于注意力的<strong>异构图网络</strong>，与用户的意图、情感和历史对话交互，可以有效地捕获和建模图中不同类型的节点和边</li>
<li>构建<strong>意图词典</strong>和<strong>情感分类器</strong>来捕捉求助者在语境中的细微情感表达</li>
<li><strong>DQN算法</strong>对用户未来反馈的期望值进行估计，帮助系统选择获得最优长期值的策略。其允许系统从用户的反馈中学习，调整其策略，以提供最有效的支持响应。</li>
</ul>
</li>
<li>主要贡献
<ul>
<li>提出了一种新的方法DQ-HGAN，将<strong>意图和情感识别与策略生成相结合</strong>，以提高情感支持对话系统的质量和个性化</li>
<li>构建<strong>意图词典和情感分类器</strong>，捕捉求助者在语境中的细微情感表达并跟踪其状态</li>
<li>设计了一种基于注意力机制的<strong>异构图网络</strong>，与用户的意图、情感和历史对话进行交互，并选择最优的支持策略以生成有效的支持响应</li>
<li>ESC生成中使用ESC生成中使用<strong>强化学习</strong>，具体来说，使用DQN算法（Deep Q-Network）估计用户未来反馈的期望值，动态调整策略以提供最有效的支持响应</li>
</ul>
</li>
</ul>
<h2 id="related-work"><a class="markdownIt-Anchor" href="#related-work"></a> Related Work</h2>
<ul>
<li>对话中的意图和情感识别【在模型中融合了“意图”这个特征】
<ul>
<li>多头注意力机制
<ul>
<li>多头注意力机制来捕捉用户的意图和情感。缺点：缺乏有效捕捉用户细微情感表达的能力</li>
<li>使用预训练模型，增强PLM对话相关性，识别对话意图、推断对话情感。缺点：不是专门为ESC任务定制的，性能差</li>
</ul>
</li>
<li>词典
<ul>
<li>词典包含特定意图或情感相关的词汇和短语，利用基于规则的算法将context与意图词典进行匹配，并分配相应的意图标签。缺点：只将单个单词与标签匹配，可能会忽略整个句子的意图或情感含义</li>
</ul>
</li>
</ul>
</li>
<li>图建模【捕获会话系统中用户意图、情感和对话历史之间的复杂关系】
<ul>
<li>同构图【忽略了用户意图和情感的异构性】
<ul>
<li>GAT 图注意力网络，利用自注意力机制来捕获对话图中意图和情感节点之间的交互</li>
<li>GCN 图卷积网络，利用图结构在节点之间传播信息，并捕获对话数据中的上下文依赖</li>
</ul>
</li>
<li><strong>异构图注意力网络是专为表示图中不同类型的节点和边而设计的</strong>，它擅长对<strong>不同的节点</strong>类型进行建模，如用户话语、系统响应、情感状态和意图，从而更全面地了解用户的情感状态；还擅长捕捉<strong>不同类型的边</strong>，包括顺序依赖、自依赖和状态依赖，从而能够更准确地表示用户的情感状态。此外，它还包含了一种<strong>注意力机制</strong>来进行重要性加权，允许它在聚合过程中专注于最相关的信息，从而更全面地了解用户的状态。</li>
</ul>
</li>
<li>策略选择
<ul>
<li>基于规则或启发式方法</li>
<li>强化学习方法（如：Q-learning）
<ul>
<li>采用DQN估计不同对话动作的期望值，并学习了一种最大化该值的策略。从用户反馈中学习，并生成更有吸引力和信息量的响应</li>
</ul>
</li>
</ul>
</li>
<li>响应生成
<ul>
<li>目前流行的Encoder-Decoder模型往往专注于根据对话历史生成回复，而没有考虑用户的意图、情感以及合适的支持策略</li>
</ul>
</li>
</ul>
<h1 id="preliminaries"><a class="markdownIt-Anchor" href="#preliminaries"></a> Preliminaries</h1>
<ul>
<li>ESConv：标记对话，并将其转换为词嵌入，以将其输入到模型中</li>
<li>COMET：使用COMET初始化模型的词嵌入，并在ESConv数据集上进行微调，以提高其构建意图词典的有效性</li>
<li>ATOMIC：得到意图或目的（xIntent）</li>
<li>NRC VAD 词典：得到情感词典，每个单词对应的效价-觉醒-支配（Valence-Arousal-Dominance）</li>
<li>问题定义：上下文+策略+Query =&gt;响应Yt。最优策略基于当前状态和期望的长期回报（通过Q-learning预测）</li>
</ul>
<h2 id="method"><a class="markdownIt-Anchor" href="#method"></a> Method</h2>
<img data-src="/2023/DQ-HGAN_%20A%20heterogeneous%20graph%20attention%20network%20based%20deep%20Q-learning%20for%20emotional%20support%20conversation%20generation/1701484543763-403c4648-68f4-4644-bf00-e2356c06841c.jpg" class="" title="88c61f5be72a795a087441904fcd0ad9_3_Figure_2_780332990.png">
<ul>
<li>
<p>多源编码器</p>
<ul>
<li>
<img data-src="/2023/DQ-HGAN_%20A%20heterogeneous%20graph%20attention%20network%20based%20deep%20Q-learning%20for%20emotional%20support%20conversation%20generation/1701484574764-c5051f60-2b3c-40cf-a161-5848c1d67bc2.png" class="" title="img">
</li>
<li>
<p>transformer编码器（TransformerEncoder）</p>
<ul>
<li>ht = TransformerEncoder(Ht)</li>
</ul>
</li>
<li>
<p>意图词典（COMET）：通过对ATOMIC 微调，同去意图关键词，构建意图词典（意图关键词，对应的词嵌入）</p>
<ul>
<li>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mi>t</mi></msub><mo>=</mo><mi>T</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi><mi>f</mi><mi>o</mi><mi>r</mi><mi>m</mi><mi>e</mi><mi>r</mi><mi>E</mi><mi>n</mi><mi>c</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>r</mi><mrow><mo fence="true">(</mo><munder><mo>∑</mo><mrow><msub><mi>w</mi><mi>i</mi></msub><mo>∈</mo><mi mathvariant="script">F</mi></mrow></munder><mi mathvariant="normal">softmax</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><msubsup><mi>c</mi><mi>i</mi><mi>T</mi></msubsup><msub><mi>h</mi><mi>t</mi></msub><mo fence="true">)</mo></mrow><msub><mi>c</mi><mi>i</mi></msub><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">g_{t}=TransformerEncoder\left(\sum_{w_{i}\in\mathscr{F}}\operatorname{softmax}\left(c_{i}^{T} h_{t}\right)c_{i}\right) 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.156105em;vertical-align:-1.406105em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">(</span></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0500050000000003em;"><span style="top:-1.843995em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.02691em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mrel mtight">∈</span><span class="mord mtight"><span class="mord mathscr mtight" style="margin-right:0.13634em;">F</span></span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.406105em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mord mathrm">s</span><span class="mord mathrm">o</span><span class="mord mathrm" style="margin-right:0.07778em;">f</span><span class="mord mathrm">t</span><span class="mord mathrm">m</span><span class="mord mathrm">a</span><span class="mord mathrm">x</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size4">)</span></span></span></span></span></span></span></p>
</li>
</ul>
</li>
<li>
<p>情感分类器（NRC VAD词典）</p>
<ul>
<li>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>e</mi><mi>t</mi></msub><mo>=</mo><mtext>TransformerEncoder</mtext><mrow><mo fence="true">(</mo><munder><mo>∑</mo><mrow><msub><mi>w</mi><mi>k</mi></msub><mo>∈</mo><mi mathvariant="script">Z</mi></mrow></munder><mi mathvariant="normal">softmax</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><msubsup><mi>z</mi><mi>k</mi><mi>T</mi></msubsup><msub><mi>h</mi><mi>t</mi></msub><mo fence="true">)</mo></mrow><msub><mi>g</mi><mi>t</mi></msub><mo fence="true">)</mo></mrow><mtext> </mtext></mrow><annotation encoding="application/x-tex">e_{t}=\text{TransformerEncoder}\left(\sum_{w_{k} \in \mathscr{Z}}\operatorname{softmax}\left(z_{k}^{T} h_{t}\right) g_{t}\right) \text { }
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.1618649999999997em;vertical-align:-1.411865em;"></span><span class="mord text"><span class="mord">TransformerEncoder</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">(</span></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.843995em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.02691em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span><span class="mrel mtight">∈</span><span class="mord mtight"><span class="mord mathscr mtight" style="margin-right:0.24037em;">Z</span></span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.411865em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mord mathrm">s</span><span class="mord mathrm">o</span><span class="mord mathrm" style="margin-right:0.07778em;">f</span><span class="mord mathrm">t</span><span class="mord mathrm">m</span><span class="mord mathrm">a</span><span class="mord mathrm">x</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size4">)</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord"> </span></span></span></span></span></span></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>基于异构图的用户状态跟踪</p>
<ul>
<li>
<img data-src="/2023/DQ-HGAN_%20A%20heterogeneous%20graph%20attention%20network%20based%20deep%20Q-learning%20for%20emotional%20support%20conversation%20generation/1701484605842-86e4e5d2-9d20-4ffd-ae60-37220c9258dd.png" class="" title="img">
</li>
</ul>
</li>
<li>
<p>DQN策略规划</p>
<ul>
<li>
<img data-src="/2023/DQ-HGAN_%20A%20heterogeneous%20graph%20attention%20network%20based%20deep%20Q-learning%20for%20emotional%20support%20conversation%20generation/1701484626201-fde66e58-39a7-40f7-9e6e-fe70a7cd8dd7.png" class="" title="img">
</li>
</ul>
</li>
<li>
<p>响应生成解码器</p>
<ul>
<li>
<img data-src="/2023/DQ-HGAN_%20A%20heterogeneous%20graph%20attention%20network%20based%20deep%20Q-learning%20for%20emotional%20support%20conversation%20generation/1701484638477-fd1f5c6b-b6f5-43f0-af14-a22d10dfe762.png" class="" title="img">
</li>
</ul>
</li>
</ul>
<p>Experiments<br />
Conclusion</p>
<h1 id="关注的问题-本文的优势"><a class="markdownIt-Anchor" href="#关注的问题-本文的优势"></a> 关注的问题 / 本文的优势</h1>
<h1 id="解决方法-创新点"><a class="markdownIt-Anchor" href="#解决方法-创新点"></a> 解决方法 / 创新点</h1>
<h1 id="实验结论"><a class="markdownIt-Anchor" href="#实验结论"></a> 实验结论</h1>
<h1 id="有待提升的部分"><a class="markdownIt-Anchor" href="#有待提升的部分"></a> 有待提升的部分</h1>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>情绪支持对话</tag>
        <tag>异构图神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Feedback-Aware Double</title>
    <url>/2023/FADO_%20Feedback-Aware%20Double%20COntrolling%20Network%20for%20Emotional%20Support%20Conversation/</url>
    <content><![CDATA[<p><strong>Title:</strong> Feedback-Aware Double COntrolling Network for Emotional Support Conversation</p>
<img data-src="/2023/FADO_%20Feedback-Aware%20Double%20COntrolling%20Network%20for%20Emotional%20Support%20Conversation/1701141604157-75101287-52dc-426c-abea-73184a8b8cda.png" class="" title="img">
<span id="more"></span>
<h1 id="论文速览"><a class="markdownIt-Anchor" href="#论文速览"></a> 论文速览</h1>
<h2 id="abstract"><a class="markdownIt-Anchor" href="#abstract"></a> Abstract</h2>
<ul>
<li>双层反馈策略选择器：通过反馈信息预测策略</li>
<li>双层控制阅读器：通过策略约束上下文响应</li>
<li>策略词典：丰富策略的语义信息</li>
</ul>
<h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2>
<h2 id="related-work"><a class="markdownIt-Anchor" href="#related-work"></a> Related Work</h2>
<h2 id="problem-formulation"><a class="markdownIt-Anchor" href="#problem-formulation"></a> Problem Formulation</h2>
<h2 id="approach"><a class="markdownIt-Anchor" href="#approach"></a> Approach</h2>
<ul>
<li>上下文编码器
<ul>
<li>BlenderBot预训练编码器编码上下文历史对话U，得到Ht</li>
</ul>
</li>
<li>双层反馈策略选择器
<ul>
<li>策略选择
<ul>
<li>输入
<ul>
<li>BlenderBot Encoder 编码上下文历史对话U，得到隐状态Ht</li>
<li>BlenderBot Encoder 编码策略S</li>
<li>EmoBERTa Encoder 编码上下文对话U</li>
</ul>
</li>
<li>公式
<ul>
<li>上下文编码器（策略S同理）：$$\boldsymbol{H}=\operatorname{Enc}<em>{cxt}\left(\boldsymbol{[CLS]}, \boldsymbol{u}</em>{1}, \boldsymbol{[SEP]}, \boldsymbol{u}<em>{2}, …, \boldsymbol{u}</em>{M}\right)$$，M为对话数
<ul>
<li>
\boldsymbol{H}=\left(\boldsymbol{u}_{1},..., \boldsymbol{u}_{T}\right)$$，T为Token数

</li>
<li>
\boldsymbol{E}=\left(\boldsymbol{e}_{1},..., \boldsymbol{e}_{T}\right)$$，T为Token数

</li>
<li>s、c、r 为策略S、上下文H、情感分类E。编码+平均池化操作后得到</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>双层反馈
<ul>
<li>回合级反馈：局部变量，当前用户的感受。包含每轮对话Seeker情感Δe和Seeker评分变化Δr</li>
<li>对话级反馈：全局变量Δc，用户的全局状态。包含Seeker在谈话后的情绪压力、Supporter对话题的回应的相关性、Supporter对Seeker感受的理解和共情</li>
<li>融合adapter：整合回合级和会话级反馈的两类语义信息。Δs = Δe + Δr + uΔc【计算损失时，给予正向或负向的反馈】</li>
</ul>
</li>
</ul>
</li>
<li>双控读取器（模仿情感聊天机器ECM）
<ul>
<li>context-to-strategy：利用上下文信息来选择上下文相关的策略
<ul>
<li>
\boldsymbol{g}^{c} = \operatorname{sigmoid}\left(

</li>
</ul>
\right)$$</li>
<li>strategy-to-context：编码阶段可以关注与策略相关的上下文，从而生成策略约束的响应
<ul>
<li>
\boldsymbol{g}^{o} = \operatorname{sigmoid}\left(

</li>
</ul>
\right)$$</li>
<li>残差连接：在原始信息和更新信息之间进行权衡
<ul>
<li>
\begin{array}{r}

</li>
</ul>
h_{t}^{\prime}=(1-\alpha) \cdot h_{t}+\alpha \cdot g^{o} \otimes h_{t}<br />
\end{array}$$</li>
</ul>
</li>
<li>策略字典
<ul>
<li>输入策略令牌的描述， 而不是策略令牌，以便模型对策略进行更深入的理解</li>
<li>Encoder-Decoder 之间的状态传输类似于MISC，采用cross-attention代替self-attention<a href="https://www.yuque.com/jinzang/lnx420/wrq82cgnp6p47q59?view=doc_embed">MISC: A MIxed Strategy-Aware Model Integrating COMET for Emotional Support Conversation</a></li>
</ul>
</li>
<li>响应生成
<ul>
<li>BlenderBot Decoder：$$\boldsymbol{p}\left(y_{z} \mid \boldsymbol{y}<em>{&lt;z}, \boldsymbol{h}</em>{\boldsymbol{t}}^{\prime}, \boldsymbol{V}\right)=\text { Generator }\left(\boldsymbol{W}<em>{y&lt;z}, \boldsymbol{h}</em>{\boldsymbol{t}}^{\prime}, \boldsymbol{V}\right)$$</li>
</ul>
</li>
<li>联合训练
<ul>
<li>策略预测：反馈感知负对数似然 feedback-aware negative log-likelihood
<ul>
<li>
\mathcal{L}_{1}=\left\{\begin{array}{ccc}

</li>
</ul>
-\hat{o} \log \left(1-\operatorname{softmax}\left(\boldsymbol{o}^{\prime}\right)\right) &amp; \text { if } &amp; \Delta s \leq 0<br />
\end{array}\right.\$$</li>
<li>响应生成：标准交叉熵损失优化 cross-entropy
<ul>
<li>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="script">L</mi><mn>2</mn></msub><mo>=</mo><mo>−</mo><munderover><mo>∑</mo><mrow><mi>z</mi><mo>=</mo><mn>1</mn></mrow><mi>Z</mi></munderover><mi>log</mi><mo>⁡</mo><mi mathvariant="bold-italic">p</mi><mrow><mo fence="true">(</mo><msub><mi>y</mi><mi>z</mi></msub><mo>∣</mo><msub><mi mathvariant="bold-italic">y</mi><mrow><mo>&lt;</mo><mi>z</mi></mrow></msub><mo separator="true">,</mo><msubsup><mi mathvariant="bold-italic">h</mi><mi mathvariant="bold-italic">t</mi><mo mathvariant="normal">′</mo></msubsup><mo separator="true">,</mo><mi mathvariant="bold-italic">V</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathcal{L}_{2}=-\sum_{z=1}^{Z} \log \boldsymbol{p}\left(y_{z} \mid \boldsymbol{y}_{&lt;z}, \boldsymbol{h}_{\boldsymbol{t}}^{\prime}, \boldsymbol{V}\right)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathcal">L</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0954490000000003em;vertical-align:-1.267113em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.882887em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">Z</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.267113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">y</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.13323000000000002em;"><span style="top:-2.45586em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">&lt;</span><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.27151em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">h</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.836232em;"><span style="top:-2.4530000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord boldsymbol mtight">t</span></span></span></span></span></span><span style="top:-3.1473400000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.25555em;">V</span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span></span></span></span></span></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="experiment"><a class="markdownIt-Anchor" href="#experiment"></a> Experiment</h2>
<ul>
<li>采用EmoBERTa-base作为特征提取器，以获取Seeker的情感得分和情感表征，情感得分由softmax函数使用EmoBERTa-base的[CLS]表示获得</li>
</ul>
<h2 id="experimental-results"><a class="markdownIt-Anchor" href="#experimental-results"></a> Experimental Results</h2>
<h2 id="analyses"><a class="markdownIt-Anchor" href="#analyses"></a> Analyses</h2>
<h2 id="conclusion"><a class="markdownIt-Anchor" href="#conclusion"></a> conclusion</h2>
<h1 id="关注的问题"><a class="markdownIt-Anchor" href="#关注的问题"></a> 关注的问题</h1>
<ol>
<li>预测策略只依靠对话历史，而不考虑求助者反馈，导致预测的结果与用户无关</li>
<li>建模过程只关注上下文到策略，而不关注策略到上下文和与策略相关的上下文</li>
</ol>
<h1 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h1>
<ol>
<li>双层反馈策略选择器：利用回合级和会话级反馈信息来激励或惩罚策略</li>
<li>双层控制阅读器：策略到上下文流来生成策略约束响应</li>
</ol>
<h1 id="创新点-本文的优势"><a class="markdownIt-Anchor" href="#创新点-本文的优势"></a> 创新点 / 本文的优势</h1>
<h1 id="实验结论"><a class="markdownIt-Anchor" href="#实验结论"></a> 实验结论</h1>
<h1 id="有待提升的部分"><a class="markdownIt-Anchor" href="#有待提升的部分"></a> 有待提升的部分</h1>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>情绪支持对话</tag>
      </tags>
  </entry>
  <entry>
    <title>HEAL</title>
    <url>/2023/HEAL_%20A%20Knowledge%20Graph%20for%20Distress%20Management%20Conversations/</url>
    <content><![CDATA[<p><strong>Title:</strong> A Knowledge Graph for Distress Management Conversations</p>
<span id="more"></span>
<h1 id="论文速览"><a class="markdownIt-Anchor" href="#论文速览"></a> 论文速览</h1>
<h2 id="abstract"><a class="markdownIt-Anchor" href="#abstract"></a> Abstract</h2>
<ul>
<li>相比于seq2seq的不确定性，聊天机器人利用知识图谱进行推理，被视为端到端模型的高效、万无一失的解决方案</li>
<li>提出HEAL知识图谱
<ul>
<li>基于1M痛苦叙述及其相应的安慰回应而开发的知识图谱</li>
<li>图谱可视化：表现了对话双方的情绪动态和帮助缓解情绪的有效方法</li>
<li>组成部分
<ul>
<li>22k Node 节点：识别不同类型的stressors, speaker expectations, responses, feedback types</li>
<li>104k Edge 连接：不同类型的节点之间的关系</li>
<li>每个节点和41种情绪状态相关联</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2>
<ul>
<li>神经网络架构模型缺乏可控性和黑箱性质，导致其并不可靠</li>
<li>使用常识推理和知识图结构表示，可以生成适合的、可预测的、多策略的回应</li>
<li>相关工作
<ul>
<li>ConceptNet、ATOMIC主要是通过捕获事实知识，在开放对话中嵌入常识推理辅助对话，不适用于移情对话</li>
</ul>
</li>
<li>本文，通过子Reddit精心选择的对压力事件叙述和回应，生成了一个压力对话管理知识图谱HEAL
<ul>
<li>五类节点：压力源、期望、回应类型、反馈类型、情感状态</li>
<li>可以准确描述以痛苦为导向对话的潜在背景，使对话模型可以检索到更具体的上下文响应。提取响应会导致的反馈类型和是否能达到期望等信息，从而产生更为合适的反应</li>
</ul>
</li>
</ul>
<h2 id="related-work"><a class="markdownIt-Anchor" href="#related-work"></a> Related Work</h2>
<ul>
<li>知识图谱可以帮助NLP理解用户的输入，拓展用户输入中的事实和常识性知识</li>
<li>目前工作关注于知识感知和推理对话，不会捕捉情感推理和移情反应</li>
</ul>
<h2 id="methodology"><a class="markdownIt-Anchor" href="#methodology"></a> Methodology</h2>
<ul>
<li>数据集管理
<ul>
<li>采用reddit数据集，通过Pushshift API，收集和处理8个子reddit对话主题：mentalhealthsupport、offmychest、sad、anxietyhelp、depression、suicidewatch、depressed、depressionhelp</li>
<li>数据预处理</li>
</ul>
</li>
<li>概要
<ul>
<li>针对过长而超出预训练语言模型输入上限的对话，本文采用SMMRY摘要算法保留叙事本质</li>
</ul>
</li>
<li>凝聚聚类
<ul>
<li>自动聚类：区分对话中的压力源、期望、响应和反馈类型</li>
<li>凝聚聚类法：递归地合并增加最小链接距离的簇对</li>
<li>链接距离：对SentenceBERT生成的embedding使用余弦相似度计算</li>
</ul>
</li>
<li>定义压力源
<ul>
<li>每个阈值计算了各种聚类质量指标，结果显示以0.85的相似度阈值区分压力源最合适，将压力源中的4.7%分为了4363个类。</li>
<li>将聚类结果按照TF-IDF建模，可以明显区分压力源，表明聚类结果的可靠性。</li>
</ul>
</li>
<li>期望、回复、反馈类型
<ul>
<li>提取带有❓的句子作为问题，以此问题提取相关的响应和反馈。使用NLTK分离响应和反馈中的单个对话，方便后续对其进行单一种类的聚类。</li>
<li>聚类方法与压力源一致，每个集群至少有两个不同的集群元素。</li>
</ul>
</li>
<li>情感状态建模
<ul>
<li>使用Pu提出的基于BERT的情感分类器，将每一个簇与某一情感状态相关联，共有41种情感状态。先将每一个簇下的每个文本进行分类，再按照情感出现次数和分类置信度排序，选取最相关的情感状态。</li>
</ul>
</li>
</ul>
<h2 id="statistical-analysis"><a class="markdownIt-Anchor" href="#statistical-analysis"></a> Statistical Analysis</h2>
<ul>
<li>HEAL知识图谱：2.2k集群节点和情感状态，104k连接</li>
<li>反馈集群中，负面情绪明显减少，证明HEAL中存在帮助人们降低负面情感状态的有用响应</li>
</ul>
<h2 id="visualization-and-interpretation"><a class="markdownIt-Anchor" href="#visualization-and-interpretation"></a> Visualization and Interpretation</h2>
<ul>
<li>表示大多数回答都是正向积极反馈</li>
</ul>
<h2 id="evaluating-the-utility-of-heal-in-responding-to-distress-prompts"><a class="markdownIt-Anchor" href="#evaluating-the-utility-of-heal-in-responding-to-distress-prompts"></a> Evaluating the Utility of HEAL in Responding to Distress Prompts</h2>
<ul>
<li>获取共情响应
<ul>
<li>从测试集中选取和压力源中现有叙述相似性高于0.75的新对话</li>
<li>根据压力源和响应之间边权的权重、响应簇大小进行排序，选择排名高的响应</li>
</ul>
</li>
<li>自动评估
<ul>
<li>HEAL的响应更加多样化，可以根据给定的情况给出特定的响应</li>
<li>在其他自动指标BLEU、METEOR和ROUGE方面表现不佳</li>
</ul>
</li>
<li>人类评估【DOI: 10.18653/v1/d16-1230】
<ul>
<li>HEAL模型变现更好</li>
</ul>
</li>
</ul>
<h2 id="discussion-and-conclusion"><a class="markdownIt-Anchor" href="#discussion-and-conclusion"></a> Discussion and Conclusion</h2>
<ul>
<li>HEAL：利用Reddit上约1M个与痛苦相关的对话得出的知识图谱。在不同类型的压力源、说话者期望、求助者反应和求助者反馈类型之间形成联系，同时将每个节点与41种情感状态中的一种联系起来</li>
<li></li>
</ul>
<h1 id="关注的问题-本文的优势"><a class="markdownIt-Anchor" href="#关注的问题-本文的优势"></a> 关注的问题 / 本文的优势</h1>
<ul>
<li>端到端对话经常会产生通用和重复性对话，缺乏可控性。使用常识推理和知识图结构表示，可以生成适合的、可预测的、多策略的回应。</li>
<li>目前的知识图谱不适用于移情对话。移情领域缺乏数据集和模型帮助产生移情反应，还缺乏具有上下文-相应之间关系的知识图谱。</li>
</ul>
<h1 id="解决方法-创新点"><a class="markdownIt-Anchor" href="#解决方法-创新点"></a> 解决方法 / 创新点</h1>
<ul>
<li>开发大规模知识图谱HEAL，识别不同的压力源、期望、响应、反馈和该对话的情感状态</li>
<li>统计和可视化分析，识别导致情绪强度降低的有利反应</li>
<li>评估通过HEAL检索到的回应，在解决情感困扰问题上的共情性、多样性、可靠性</li>
</ul>
<h1 id="实验结论"><a class="markdownIt-Anchor" href="#实验结论"></a> 实验结论</h1>
<ul>
<li>与RoBERTa、Blender进行比较，HEAL能够产生更多样化、更移情的反应</li>
<li>统计和可视化分析证实了在HEAL中存在有用的反应策略，这些策略降低了遭受痛苦的人的负面情感状态</li>
<li>使用纯生成模型来解决痛苦存在危险，HEAL通过战略性地识别与给定提示相关的特定压力源来避免不适当的反应</li>
</ul>
<h1 id="有待提升的部分"><a class="markdownIt-Anchor" href="#有待提升的部分"></a> 有待提升的部分</h1>
<ul>
<li>只使用了压力源与回复的边缘权重，进一步可以通过将边缘权重与说话者的期望和反馈结合起来来开发</li>
<li>知识图的信息可以用于增强神经反应生成模型，并为这些模型引入更多的可控性和可解释性，从而提高可靠性</li>
<li>仅限于识别≈4K的压力源，可以从网络上获取更多数据来增强知识图谱，这将帮助其能够处理更大范围的压力源和期望</li>
</ul>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>情绪支持对话</tag>
        <tag>知识图谱</tag>
      </tags>
  </entry>
  <entry>
    <title>KEMI</title>
    <url>/2023/Knowledge-enhanced%20Mixed-initiative%20Dialogue%20System%20for%20Emotional%20Support%20Conversations/</url>
    <content><![CDATA[<p><strong>Title:</strong> Knowledge-enhanced Mixed-initiative Dialogue System for Emotional Support Conversations</p>
<img data-src="/2023/Knowledge-enhanced%20Mixed-initiative%20Dialogue%20System%20for%20Emotional%20Support%20Conversations/1699406609845-c98dd4cb-e2ae-41f2-99b8-aed67482d60d.png" class="" title="image.png">
<span id="more"></span>
<h1 id="论文速览"><a class="markdownIt-Anchor" href="#论文速览"></a> 论文速览</h1>
<h2 id="abstract"><a class="markdownIt-Anchor" href="#abstract"></a> Abstract</h2>
<ul>
<li>混和主动性：按照说话者角色和主动类型分为四类</li>
<li>提出四个情绪支持指标</li>
<li>提出一种用于 ESC 的知识增强混合主动框架 (KEMI)</li>
</ul>
<h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2>
<ul>
<li>ESC系统
<ul>
<li>在适当的时候发起讨论，目的是提出建议，并解决问题</li>
</ul>
</li>
<li>相关工作
<ul>
<li>CIS(conversational information-seeking)可以主动发起对话，澄清交互并探索更多的信息</li>
<li>情感推理用来生成共情反应</li>
<li>identifying the dialogue acts of the utterances</li>
<li>ESC 系统预测下一个对话策略</li>
</ul>
</li>
<li>ESC问题的三个挑战
<ul>
<li>系统应该在对话过程中何时采取主动？</li>
<li>系统发起子对话需要什么样的信息？</li>
<li>系统如何促进混合主动交互？</li>
</ul>
</li>
<li>解决方法
<ul>
<li>策略预测：确定下一回合混合主动策略</li>
<li>知识选择：收集下一回合的必要知识</li>
<li>响应生成：在适当的混合主动策略和知识下产生情感支持响应</li>
</ul>
</li>
<li>提出的新东西
<ul>
<li>混合主动性特征
<ul>
<li>EAFR模式：话语注释为不同类型的说话者角色和主动类型</li>
<li>Expression, Action, Reflection, Feedback</li>
</ul>
</li>
<li>情感支持指标
<ul>
<li>Proactivity, Information, Repetition, Relaxation</li>
</ul>
</li>
<li>KEMI
<ul>
<li>使用生成的常识知识作为查询图来扩展用户话语，在知识图谱上执行子图检索</li>
<li>响应生成模块以序列到序列的方式，对策略预测和响应生成进行【多任务学习】，以生成具有外部知识的混合主动响应</li>
</ul>
</li>
</ul>
</li>
<li>主要贡献
<ul>
<li>EAFR 注释模式和四种情感支持指标</li>
<li>使用用常识知识扩展的查询图，通过子图检索从心理健康知识图谱中检索外部知识</li>
</ul>
</li>
</ul>
<h2 id="related-works"><a class="markdownIt-Anchor" href="#related-works"></a> Related Works</h2>
<ul>
<li>ESC
<ul>
<li>检测用户情绪</li>
<li>将情感信号放入Respond中</li>
<li>情绪感知反应，情感风格转移</li>
<li>共情对话系统
<ul>
<li>情感推理技巧</li>
<li>利用外部知识来提高情绪推理的建模能力：知识图、常识性模型、特定领域知识、常识性知识</li>
</ul>
</li>
</ul>
</li>
<li>混合主动对话</li>
</ul>
<h2 id="preliminary-analysis"><a class="markdownIt-Anchor" href="#preliminary-analysis"></a> Preliminary Analysis</h2>
<ul>
<li>EAFR
<ul>
<li>四种注释方法：按照角色和主动类型区分</li>
<li>四种评价指标：【待看】</li>
</ul>
</li>
<li>混合主动性分析</li>
<li>混和主动性的挑战
<ul>
<li>系统何时采取主动？</li>
<li>系统发起子对话时，需要什么信息？
<ul>
<li>情感识别：识别用户情感状态</li>
<li>因果识别：导致情感状态的压力源</li>
<li>认知识别：解决问题的过程</li>
</ul>
</li>
<li>根据历史对话，系统自发判断响应的主动或被动</li>
</ul>
</li>
<li>问题定义
<ul>
<li>给定历史对话C和用户情况s，产生相应r
<ul>
<li>策略预测y，细粒度主动性</li>
<li>知识选择k</li>
<li>使用y和k生成混合主动相应r</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="method"><a class="markdownIt-Anchor" href="#method"></a> Method</h2>
<ul>
<li>知识获取
<ul>
<li>检索心理健康知识图谱HEAL，弥补常识性知识的不足
<ul>
<li>COMET常识性知识扩展查询：Cp = COMET(p, ut)</li>
<li>构造查询图：û = {ut, {Cp}}
<ul>
<li>expectation：ut</li>
<li>affective：[xReact]</li>
<li>stressor：[xIntent]</li>
<li>responses：[xWant] [xNeed] [xEffect]</li>
</ul>
</li>
<li>子图检索
<ul>
<li>相似度计算：sentence-BERT</li>
<li>针对每个 ût 中的抽象描述，获取与其最相似的top-K个HEAL中的实体，基于HEAL中的边缘连接，构成候选子图</li>
<li>针对每个 E 中的类型节点，按照子图中的每个节点相似度得分之和排序子图，选择top-N作为检索到的知识K</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>混合主动响应生成
<ul>
<li>使用基于上下文的编码器，编码上下文对话C和知识K</li>
<li>X：[CLS]<context>[know.]&lt;know.&gt;；Y：[strategy]y[response]r</li>
<li>优化损失函数，最大化负对数似然函数L</li>
</ul>
</li>
</ul>
<h2 id="experiment"><a class="markdownIt-Anchor" href="#experiment"></a> Experiment</h2>
<ul>
<li>实验基础
<ul>
<li>数据集：ESConv、MI</li>
<li>评估参数：流利度Perplexity (PPL)、内容保留度BLEU-n (B-n)、内容保留度ROUGE-L (R-L)</li>
</ul>
</li>
<li>总体表现
<ul>
<li>BlenderBot优于Transformer</li>
<li>GLHG、MISI有效地利用了常识性知识</li>
<li>基于策略的联合学习可以提高性能</li>
<li>KEMI明显优于其他方法：HEAL知识相比常识性知识更有效地支持了预测策略，减轻了对预训练大模型的依赖</li>
</ul>
</li>
<li>人工评价
<ul>
<li>从流畅度、辨识度、舒适度、建议有效性、总体回应五个方面与BlenderBot-joint、MISC进行对比，MISC完胜</li>
</ul>
</li>
<li>消融实验
<ul>
<li>HEAL可以有效提升策略预测准确度</li>
<li>舍弃COMET，可以提高ppl准确度，因为常识性知识不是自然语句；但会降低内容保留度，因为简洁的常识性知识更为精确</li>
<li>认知识别是最有效的</li>
<li>对比Oracle，还有很大的提升空间</li>
</ul>
</li>
<li>混和主动性分析
<ul>
<li>情感支持指标分析
<ul>
<li>KEMI有效的平衡了主动性和非主动性回复</li>
<li>KEMI回复的信息更加丰富</li>
<li>KEMI容易生成重复性回复</li>
<li>KEMI有效地帮助用户解决情绪问题</li>
</ul>
</li>
<li>会话进度
<ul>
<li>相比BlenderBot和MISC，KEMI在对话过程中，主动性和非主动性的分布更加平衡</li>
<li>KEMI在对话中后期更能主动相应并缓解用户负面情绪</li>
</ul>
</li>
</ul>
</li>
<li>案例分析</li>
</ul>
<h2 id="conclusions"><a class="markdownIt-Anchor" href="#conclusions"></a> Conclusions</h2>
<ul>
<li>首次提出ESC中混和主动性的特点，并阐述其重要性</li>
<li>KEMI框架
<ul>
<li>通过查询扩展和子图检索，从大规模心理健康图谱中检索实际病例知识</li>
<li>通过检索到的知识，进行策略预测和响应生成的多任务学习</li>
</ul>
</li>
<li>结合实际案例和分析指标，结果证明KEMI优于现有方法，并在混合主动交互方面具有优势</li>
</ul>
<h2 id="limitations"><a class="markdownIt-Anchor" href="#limitations"></a> Limitations</h2>
<ul>
<li>评价指标有待改进</li>
<li>没有考虑不同知识检索方法的不同</li>
<li>从复杂的KG图中检索知识的方法有待提高</li>
<li>某些应用的知识图难以获取</li>
<li>知识库的建立需要具有专业知识的人员</li>
</ul>
<h2 id="appendix"><a class="markdownIt-Anchor" href="#appendix"></a> Appendix</h2>
<ul>
<li>混和主动性
<ul>
<li>对话主动性分析
<ul>
<li>主动性分析模型：在ESConv数据集增加混合主动的类型属性，把历史对话和当前话语作为二元输入，判断主动性。微调RoBERTTalarge，分别训练两个模型，判断用户和系统的主动性</li>
<li>情绪强度预测模型：根据用户话语预测负面情绪强度</li>
<li>用户模拟并注释四种评价指标 ：【待看】</li>
</ul>
</li>
<li>对话流分析
<ul>
<li>ESC在对话中充当主动角色；ED在对话中充当被动角色</li>
</ul>
</li>
<li>对话过程
<ul>
<li>研究内容：主动性和情绪强度变化的关系</li>
<li>结论
<ul>
<li>交互时间很重要</li>
<li>情绪缓解后才更有利于解决问题</li>
</ul>
</li>
</ul>
</li>
<li>ES指标</li>
</ul>
</li>
<li>COMET
<ul>
<li>常识性关系</li>
</ul>
</li>
<li>HEAL
<ul>
<li>情绪压力和安慰回应之间的知识图谱</li>
<li>表现了对话双方的情绪动态，确定缓解情绪的方法</li>
</ul>
</li>
</ul>
<h1 id="解决了什么问题"><a class="markdownIt-Anchor" href="#解决了什么问题"></a> 解决了什么问题</h1>
<ul>
<li>常识性知识是相当抽象的，没有详细的信息，因此它对ESC系统产生有意义和信息丰富的响应的帮助不大。在这项工作中，我们采用<strong>生成式常识模型</strong>进行查询扩展，从外部知识图中检索实际案例知识。</li>
</ul>
<h1 id="怎么解决的-该方法的优势"><a class="markdownIt-Anchor" href="#怎么解决的-该方法的优势"></a> 怎么解决的 / 该方法的优势</h1>
<ol>
<li>常识知识生成器 COMET：</li>
<li>常识性知识获取 HEAL：</li>
</ol>
<h1 id="有什么创新点"><a class="markdownIt-Anchor" href="#有什么创新点"></a> 有什么创新点</h1>
<ol>
<li>提出ESC知识增强混合主动框架
<ol>
<li>人类和系统都可以主动引导交互方向</li>
<li>通过子图检索从心理健康知识图谱中检索外部知识</li>
</ol>
</li>
<li>新的分析方法</li>
</ol>
<blockquote>
<p>保留评估 和 混合主动性分析 方面均有效优于现有方法</p>
</blockquote>
<ol>
<li>按照说话者角色和主动类型将话语注释为不同类型
<ol>
<li>Expression：用户主动</li>
<li>Action：系统主动</li>
<li>Feedback：用户非主动</li>
<li>Reflection：系统非主动</li>
</ol>
</li>
<li>提出四个情感支持指标来衡量ESC中主动性和非主动性交互的特征
<ol>
<li>Proactivity：系统主动的对话占系统对话的比例</li>
<li>Information：系统首次提出的频繁词占比</li>
<li>Repetition：系统重复用户提出的术语的频次占比</li>
<li>Relaxation：情绪强度的改善</li>
</ol>
</li>
</ol>
<h1 id="实验结果好在哪里怎么证明的"><a class="markdownIt-Anchor" href="#实验结果好在哪里怎么证明的"></a> 实验结果好在哪里，怎么证明的</h1>
<h1 id="相关工作分析"><a class="markdownIt-Anchor" href="#相关工作分析"></a> 相关工作分析</h1>
<h1 id="可以提升的地方"><a class="markdownIt-Anchor" href="#可以提升的地方"></a> 可以提升的地方</h1>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>情绪支持对话</tag>
      </tags>
  </entry>
  <entry>
    <title>MISC</title>
    <url>/2023/MISC_%20A%20MIxed%20Strategy-Aware%20Model%20Integrating%20COMET%20for%20Emotional%20Support%20Conversation/</url>
    <content><![CDATA[<p><strong>Title:</strong> A MIxed Strategy-Aware Model Integrating COMET for Emotional Support Conversation</p>
<img data-src="/2023/MISC_%20A%20MIxed%20Strategy-Aware%20Model%20Integrating%20COMET%20for%20Emotional%20Support%20Conversation/1699523191286-4f020d4d-6fee-4fc2-b943-e0443b1ca667.png" class="" title="image.png">
<span id="more"></span>
<h1 id="论文速览"><a class="markdownIt-Anchor" href="#论文速览"></a> 论文速览</h1>
<h2 id="abstract"><a class="markdownIt-Anchor" href="#abstract"></a> Abstract</h2>
<ul>
<li>先前工作的局限性
<ul>
<li>采用对话级别的情感标签，这种标签过于粗粒度，无法捕捉用户的即时精神状态</li>
<li>大多侧重于在回应中表达同理心，而不是逐渐减轻用户的痛苦</li>
</ul>
</li>
<li>本文提出了MISC
<ul>
<li>首先推断用户的细粒度情感状态，然后使用混合策略巧妙地响应</li>
<li>在基准数据集上的实验结果证明了方法的有效性，并揭示了细粒度情感理解和混合策略建模的好处</li>
</ul>
</li>
</ul>
<h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2>
<ul>
<li>目前的工作不适用于ESC
<ul>
<li>粗粒度静态的对话级情感标签无法关注到对话过程中用户情感发生的变化</li>
<li>只有移情反应，而不考虑解决求助者的情感问题</li>
</ul>
</li>
<li>本文提出的解决方法
<ul>
<li>有选择地采用COMET（预训练生成式常识推理模型）生成的知识元组进行细粒度情感理解</li>
<li>混合策略，而不是预测单一策略</li>
<li>设计一套注意力机制</li>
</ul>
</li>
<li>实验分析
<ul>
<li>回答策略建模的重要性，能够提高模型的共情能力</li>
</ul>
</li>
</ul>
<h2 id="related-work"><a class="markdownIt-Anchor" href="#related-work"></a> Related Work</h2>
<ul>
<li>情绪感知响应生成</li>
<li>NLP中的常识性知识</li>
<li>策略感知对话模型</li>
</ul>
<h2 id="preliminaries"><a class="markdownIt-Anchor" href="#preliminaries"></a> Preliminaries</h2>
<ul>
<li>ESConv数据集</li>
<li>问题设定
<ul>
<li>通过对话历史、场景、求助者最后一句话，预测回复策略和回复内容</li>
</ul>
</li>
</ul>
<h2 id="model-misc"><a class="markdownIt-Anchor" href="#model-misc"></a> Model: MISC</h2>
<ul>
<li>情感状态增强Encoder
<ul>
<li>利用COMET提取场景situation和语句x的常识性知识，将常识性知识输入Encoder得到H’s和H’x</li>
</ul>
</li>
</ul>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="bold-italic">B</mi><mi>s</mi></msup><mo>=</mo><munderover><mo>⋃</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>N</mi><mi>r</mi></msub></munderover><mi mathvariant="normal">COMET</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><msub><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">l</mi></mrow><mi>j</mi></msub><mo separator="true">,</mo><mi mathvariant="bold-italic">s</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\boldsymbol{B}^{s}=\bigcup_{j=1}^{N_{r}}\operatorname{COMET}\left(\mathrm{rel}_{j},\boldsymbol{s}\right)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.740402em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.04835em;">B</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740402em;"><span style="top:-3.1390100000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.2532130000000006em;vertical-align:-1.4137769999999998em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8394360000000005em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">⋃</span></span></span><span style="top:-4.311105em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.10903em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4137769999999998em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mord mathrm">C</span><span class="mord mathrm">O</span><span class="mord mathrm">M</span><span class="mord mathrm">E</span><span class="mord mathrm">T</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord"><span class="mord mathrm">r</span><span class="mord mathrm">e</span><span class="mord mathrm">l</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">s</span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></span></p>
<ul>
<li>将H’s和H’x分别与历史对话c做cross-attention，得到Hs和Hx</li>
<li>将历史对话c输入Encoder得到C</li>
<li>混合策略学习模块【从VQ-VAE’s codebook文章中抄来的】
<ul>
<li>C输入多层感知机+softmax得到Pg（Pg大小是strategy_size）</li>
<li>Pg作为概率分布，hg=Pg*T（T为策略嵌入）
<ul>
<li>长对话回复中可以引入多种策略，且模型学习灵活方便</li>
</ul>
</li>
</ul>
</li>
<li>多因素感知Decoder
<ul>
<li>将情绪状态和策略表征传入Decoder里的Cross-attention</li>
</ul>
</li>
</ul>
<h2 id="experiments"><a class="markdownIt-Anchor" href="#experiments"></a> Experiments</h2>
<ul>
<li>ESConv中的每十个话语作为一个样本</li>
<li>评价指标
<ul>
<li>策略预测精度：Acc</li>
<li>传统NLP指标：PPL、BLEU、ROUGE-L</li>
<li>相应多样性：Distinct</li>
<li>人类评估</li>
</ul>
</li>
<li>基准模型
<ul>
<li>MT Transformer、MoEL、MIME、BlenderBot-Joint</li>
</ul>
</li>
<li>具体实现</li>
<li>实验结果
<ul>
<li>动态细粒度情感标签更能准确给予用户回应</li>
<li>细粒度共情，多策略平稳过渡策略，可以更自然地表达共情并提供帮助</li>
<li>策略作为单独的任务进行预测比单一预测更有利</li>
<li>MISC的知识Know得分最高，成功学习到了COMET中的心理状态知识</li>
</ul>
</li>
</ul>
<h2 id="analysis"><a class="markdownIt-Anchor" href="#analysis"></a> Analysis</h2>
<ul>
<li>消融实验</li>
<li>案例研究</li>
<li>细粒度情感理解
<ul>
<li>用粗粒度的情感标签代替细粒度的心理信息可以显著提高指标</li>
</ul>
</li>
<li>混合策略感知移情反应
<ul>
<li>混合策略有利于平滑的情感支持</li>
<li>混合策略比单一策略更有效</li>
<li>混合策略适用于ESC框架</li>
</ul>
</li>
</ul>
<h2 id="conclusions"><a class="markdownIt-Anchor" href="#conclusions"></a> Conclusions</h2>
<ul>
<li>引入COMET来捕捉用户的即时心理状态</li>
<li>设计了一个混合策略感知解码器来产生支持响应</li>
</ul>
<h1 id="解决了什么问题-怎么解决的"><a class="markdownIt-Anchor" href="#解决了什么问题-怎么解决的"></a> 解决了什么问题 / 怎么解决的</h1>
<h1 id="该方法的优势"><a class="markdownIt-Anchor" href="#该方法的优势"></a> 该方法的优势</h1>
<ul>
<li>长对话中的过度更加顺畅</li>
</ul>
<h1 id="有什么创新点"><a class="markdownIt-Anchor" href="#有什么创新点"></a> 有什么创新点</h1>
<ul>
<li>提出seq2seq模型MISC，在ESC中添加了常识性知识和混合反应策略</li>
<li>提出了不同的策略模型并在对话中给予提示</li>
</ul>
<h1 id="实验结果好在哪里怎么证明的"><a class="markdownIt-Anchor" href="#实验结果好在哪里怎么证明的"></a> 实验结果好在哪里，怎么证明的</h1>
<ul>
<li>从SOTA延续下来的细粒度情感表现较粗粒度静态情感更好</li>
</ul>
<h1 id="相关工作分析"><a class="markdownIt-Anchor" href="#相关工作分析"></a> 相关工作分析</h1>
<h1 id="可以提升的地方"><a class="markdownIt-Anchor" href="#可以提升的地方"></a> 可以提升的地方</h1>
<ul>
<li>以动态的方式学习混合响应策略</li>
</ul>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>情绪支持对话</tag>
      </tags>
  </entry>
  <entry>
    <title>BlenderBot</title>
    <url>/2023/Recipes%20for%20building%20an%20open-domain%20chatbot/</url>
    <content><![CDATA[<p><strong>Title:</strong> Recipes for building an open-domain chatbot</p>
<blockquote>
<p>FaceBook 在本文中提出了 BlenderBot 编解码器模型</p>
</blockquote>
<span id="more"></span>
<h1 id="论文速览"><a class="markdownIt-Anchor" href="#论文速览"></a> 论文速览</h1>
<h2 id="abstract"><a class="markdownIt-Anchor" href="#abstract"></a> Abstract</h2>
<ul>
<li>开放域聊天机器人需要良好的谈话技巧：提出有吸引力的要点，倾听别人的意见，适当展示知识、同理性和个性，保持前后一致</li>
<li>本文证实：基于适当的训练数据和生成策略，大模型可以学习上述技巧</li>
</ul>
<h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2>
<ul>
<li>研究的主要内容
<ul>
<li>混合技巧：模型专注于个性和吸引力、知识、同理心。采用 Blended Skill Talk 实现，具体是通过提供训练数据和初始化上下文来实现。这种方法可以减少从大语料库中学习到不良特征。</li>
<li>生成策略：解码算法非常重要，对话长度强相关于对话质量，本文实验表明采样优于束搜索</li>
</ul>
</li>
<li>本文的优势和存在的问题</li>
</ul>
<h2 id="model-architectures"><a class="markdownIt-Anchor" href="#model-architectures"></a> Model architectures</h2>
<ul>
<li>检索
<ul>
<li>将训练集作为候选响应集，每个可能的候选响应都参与Encoder，并做聚类【poly-encoder】</li>
</ul>
</li>
<li>生成
<ul>
<li>使用标准的Seq2Seq Transformer架构生成响应</li>
</ul>
</li>
<li>检索和提炼
<ul>
<li>帮助模型访问没有嵌入其模型参数的外部知识</li>
<li>对话检索：通过检索模型生成响应，并将其附加到Decoder的输入序列中，并用分隔符分开。使用修改后的输入序列生成正常的响应</li>
<li>知识检索：检索Wiki生成初始候选集，使用上文提到的检索模型，排序候选词并选择条件生成的句子。此外，训练一个分类器，通过上下文判断何时需要检索知识</li>
</ul>
</li>
</ul>
<h2 id="training-objectives"><a class="markdownIt-Anchor" href="#training-objectives"></a> Training Objectives</h2>
<ul>
<li>检索排序
<ul>
<li>模型训练使用本文回答作为正例，其他对话回答作为负例</li>
</ul>
</li>
<li>响应生成模型的似然训练
<ul>
<li>建模整个序列的概率分布</li>
</ul>
</li>
<li>α-混合检索和提炼
<ul>
<li>生成模型常常不考虑对话检索语句，为确保其被使用，将检索相应中的α%替换成真实响应，α为超参数</li>
<li>知识检索的数据集里，知识条件和响应之间有明确的对应关系</li>
<li>因此训练阶段只使用知识检索的数据，充实模型参数中学到的知识</li>
</ul>
</li>
<li>响应生成模型的非似然损失
<ul>
<li>使用高于真实数据数量的n元语法中的token作为候选负样本，修正已知的偏差</li>
</ul>
</li>
</ul>
<h2 id="decoding"><a class="markdownIt-Anchor" href="#decoding"></a> Decoding</h2>
<p>选择解码方法对给定的历史对话的响应</p>
<ul>
<li>确定性解码方法
<ul>
<li>束搜索</li>
<li>贪心搜索</li>
</ul>
</li>
<li>采样
<ul>
<li>多项采样：根据预测结果概率分布，定义候选Token被选中的概率。防止采样到低概率Token，可以将采样限制在词汇表的子集内，并根据子集概率重采样</li>
<li>平滑分布采样：Temparature+SoftMax+multinomial</li>
<li>top-k sampling：Temparature+Top-k+SoftMax+multinomial，将top-k外的token概率置为0</li>
<li>sample-and-rank：多次采样，取最高概率的响应</li>
</ul>
</li>
<li>响应长度
<ul>
<li>约束最小生成长度：在实现最小序列长度之前，强制不生成结束标记</li>
<li>预测长度：根据上下文预测相应长度，这是一个四分类问题</li>
</ul>
</li>
<li>子序列分块
<ul>
<li>n-grams：考虑响应和输入上下文中对于n-grams的重复性</li>
</ul>
</li>
</ul>
<h2 id="training-details"><a class="markdownIt-Anchor" href="#training-details"></a> Training Details</h2>
<ul>
<li>预训练排序模型</li>
<li>预训练生成模型</li>
<li>微调
<ul>
<li>Fairseq-style混合精度训练</li>
</ul>
</li>
</ul>
<p>Training Data<br />
Safety Characteristics<br />
Evaluation Methods<br />
Related Work<br />
Results &amp; Analysis<br />
Released code and models<br />
Discussion</p>
<h1 id="关注的问题-本文的优势"><a class="markdownIt-Anchor" href="#关注的问题-本文的优势"></a> 关注的问题 / 本文的优势</h1>
<ul>
<li>成对比较和人性方面优于Meena</li>
</ul>
<h1 id="解决方法-创新点"><a class="markdownIt-Anchor" href="#解决方法-创新点"></a> 解决方法 / 创新点</h1>
<h1 id="实验结论"><a class="markdownIt-Anchor" href="#实验结论"></a> 实验结论</h1>
<h1 id="有待提升的部分"><a class="markdownIt-Anchor" href="#有待提升的部分"></a> 有待提升的部分</h1>
<ul>
<li>如果对话中深入询问某一方面，由于缺乏知识模型没法给出详细的回答</li>
<li>模型倾向于简单的回答</li>
<li>模型倾向于产生重复易混淆的句子</li>
</ul>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>情绪支持对话</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 使用指南</title>
    <url>/2023/hexo%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://hexo.io/docs/">官方文档</a></p>
</blockquote>
<h1 id="常用命令"><a class="markdownIt-Anchor" href="#常用命令"></a> 常用命令</h1>
<table>
<thead>
<tr>
<th>方法</th>
<th>代码</th>
</tr>
</thead>
<tbody>
<tr>
<td>快速部署</td>
<td>hexo g -d</td>
</tr>
<tr>
<td>清除缓存</td>
<td>hexo clean</td>
</tr>
<tr>
<td>预览</td>
<td>hexo s</td>
</tr>
<tr>
<td>部署</td>
<td>hexo d</td>
</tr>
<tr>
<td>生成静态页面</td>
<td>hexo generate</td>
</tr>
</tbody>
</table>
<h1 id="初始化配置"><a class="markdownIt-Anchor" href="#初始化配置"></a> 初始化配置</h1>
<p>初始化项目结构</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<p>新增标签页，设置属性（type: “tags”）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
<p>新增分类，设置属性（type: “categories”）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>
<p>配置 next 主题设置</p>
<ul>
<li>设置 menu 菜单栏</li>
<li>打开 code 代码复制</li>
</ul>
<p>Debug</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean --debug</span><br><span class="line">hexo s --debug</span><br></pre></td></tr></table></figure>
<p><strong>Git 上传插件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p><strong>latex 公式</strong></p>
<p>安装 <code>hexo-renderer-markdown-it-plus</code> 后，Katex 与 mathJax 会重复，需要在 next 中配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="string">none</span></span><br><span class="line"><span class="attr">katex:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">copy_tex:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p><strong>本地图片</strong></p>
<p><s>配置本地图片上传 <a href="https://bkystop.github.io/2022/01/05/hexo-markdown%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/index.html">Link </a> <a href="https://muxiner.github.io/organize-files/">Link</a></s></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-img --save  // 代替 hexo-asset-image</span><br></pre></td></tr></table></figure>
<p><strong>Markdown 文字高亮</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-markdown-it-plus --save</span><br></pre></td></tr></table></figure>
<p>_config.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">markdown:</span></span><br><span class="line">    <span class="attr">preset:</span> <span class="string">&quot;default&quot;</span></span><br><span class="line">    <span class="attr">plugins:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">markdown-it-mark</span></span><br></pre></td></tr></table></figure>
<p><strong>添加Sitemap</strong></p>
<p>为自己的网站配置sitemap，可以有效地提升SEO</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>
<p>并在站点配置文件<code>_config.yml</code>的末尾添加：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidusitemap.xml</span></span><br></pre></td></tr></table></figure>
<p><strong>改 blockquote 颜色</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">blockquote</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#d0a7020d</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">4px</span> solid <span class="number">#d0a702</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--blockquote-color);</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">15px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">cite</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">5px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="备份本地博客"><a class="markdownIt-Anchor" href="#备份本地博客"></a> 备份本地博客</h1>
<p><a href="https://blog.csdn.net/u014532291/article/details/131805350">利用mklink实现OneDrive自定义文件双向同步</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MKLINK [[/D] | [/H] | [/J]] Link Target</span><br><span class="line"></span><br><span class="line">        /D      创建目录符号链接。默认为文件符号链接。</span><br><span class="line">        /H      创建硬链接而非符号链接。</span><br><span class="line">        /J      创建目录联接。</span><br><span class="line">        Link    指定新的符号链接名称。</span><br><span class="line">        Target  指定新链接引用的路径</span><br><span class="line">                (相对或绝对)。</span><br></pre></td></tr></table></figure>
<p>使用 <code>mklink /D 目标地址 源地址</code> 将博客<u>硬链接</u>到 OneDrive 文件夹下备份</p>
<h1 id="2024423-更新主题-next"><a class="markdownIt-Anchor" href="#2024423-更新主题-next"></a> 2024.4.23 更新主题 Next</h1>
<blockquote>
<p>由于 NexT 以前使用的 swig 模版引擎停止维护，去年迁移到了 Nunjucks，但是 目录下的模版文件后缀名没有更改。原因是修改后缀名影响太广，会使用户在执行 进行更新时产生大量的冲突。这次更换仓库为了解决这些历史遗留问题，没有保留之前的 commit 历史。</p>
</blockquote>
<p>按照<a href="https://theme-next.js.org/docs/getting-started/">官网</a>配置</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 文档阅读</title>
    <url>/2024/Git%20%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<p><a href="https://git-scm.com/book/zh/v2">Git 中文文档</a></p>
<blockquote>
<p>有空可以看看这个 <a href="https://github.com/xirong/my-git">Git 笔记汇总</a></p>
</blockquote>
<span id="more"></span>
<h2 id="chapter-1-起步"><a class="markdownIt-Anchor" href="#chapter-1-起步"></a> Chapter 1 起步</h2>
<h3 id="版本控制"><a class="markdownIt-Anchor" href="#版本控制"></a> 版本控制</h3>
<ol>
<li>
<p>集中化版本控制（CVCS）缺点</p>
<ol>
<li>中央服务器的单点故障就无法协同工作</li>
<li>本地只有快照，项目整体和其变更历史只保存在服务器上</li>
</ol>
</li>
<li>
<p>分布式版本控制（DVCS）优点</p>
<ol>
<li>代码仓库完整地镜像下来，包括完整的历史记录</li>
<li>用户在本地保存了所有改动，每一次的克隆都是对仓库的完整备份</li>
<li>可以指定和若干不同的远端代码仓库进行交互</li>
</ol>
</li>
</ol>
<h3 id="git-简史"><a class="markdownIt-Anchor" href="#git-简史"></a> Git 简史</h3>
<ol>
<li>并行开发</li>
<li>完全分布式</li>
<li>速度快</li>
<li>数据量大</li>
</ol>
<h3 id="git-简介"><a class="markdownIt-Anchor" href="#git-简介"></a> Git 简介</h3>
<ol>
<li>大多版本控制工具都是基于差异的，存储文件随时间变化的差异，而Git储存项目快照或索引</li>
<li>Git 安全性优，只做增不做删；完整性好，使用SHA-1 哈希算法</li>
<li>文件的四种状态：已提交（committed）、已修改（modified）、已暂存（staged）、未跟踪（untracked）</li>
<li>项目的三个阶段：工作目录、暂存区域以及 Git 仓库</li>
<li>工作流程：修改文件、暂存文件、将暂存区文件快照永久存在Git目录</li>
</ol>
<h3 id="git-配置"><a class="markdownIt-Anchor" href="#git-配置"></a> Git 配置</h3>
<blockquote>
<p>git config --list --show-origin</p>
</blockquote>
<ol>
<li>/etc/gitconfig 系统通用配置 git config --system</li>
<li>~/.gitconfig 当前用户配置 git config --global</li>
<li>.git/config 当前项目配置 git config --local</li>
</ol>
<h2 id="chapter-2-基础"><a class="markdownIt-Anchor" href="#chapter-2-基础"></a> Chapter 2 基础</h2>
<blockquote>
<p>Git命令只能控制当前文件夹和子文件夹内的修改</p>
</blockquote>
<h3 id="基础命令"><a class="markdownIt-Anchor" href="#基础命令"></a> 基础命令</h3>
<ol>
<li>git init
<ol>
<li>初始化仓库</li>
</ol>
</li>
<li>git clone
<ol>
<li>克隆仓库</li>
</ol>
</li>
<li>git status
<ol>
<li>查看文件状态</li>
<li>[-s] 简要文件状态信息</li>
</ol>
</li>
<li>git add
<ol>
<li>[&lt;file&gt;] 跟踪新文件</li>
<li>[&lt;file&gt;] 已修改的文件放到暂存区</li>
<li>[&lt;file&gt;] 合并时把有冲突的文件标记为已解决状态</li>
</ol>
</li>
<li>git diff
<ol>
<li>已修改文件与已暂存文件的内容差异</li>
<li>[–staged] 已暂存与分支HEAD的内容差异</li>
</ol>
</li>
<li>git rm
<ol>
<li>[&lt;file&gt;] 记录此次移除文件的操作</li>
<li>[-f] 强制移除存在未暂存修改的文件</li>
<li>[ --cached] 文件保留在工作区中，从Git仓库和暂存区中删除</li>
</ol>
</li>
<li>git commit
<ol>
<li>提交文件</li>
<li>[-m] 提交备注</li>
<li>[–amend] 追加提交</li>
<li>[-a] 直接将工作区和暂存区的所有修改一起提交</li>
</ol>
</li>
<li>git mv
<ol>
<li>[&lt;oldfilename&gt; &lt;newfilename&gt;] 移动文件/改名</li>
</ol>
</li>
<li>git log
<ol>
<li>回顾提交历史</li>
<li>[–stat] 显示每次提交的简要信息</li>
<li>[-p ] 显示每次提交的详细信息</li>
<li>[–pretty=format:“xxx”] 自定义信息格式</li>
<li>[–oneline --graph --all] 显示提交历史、各个分支的指向以及项目的分支分叉情况</li>
<li>[–since] 限制时间</li>
</ol>
</li>
<li>git reset
<ol>
<li>[HEAD &lt;file&gt;] 取消暂存</li>
</ol>
</li>
<li>git checkout
<ol>
<li>[-- &lt;filename&gt;] 撤销修改</li>
<li>[&lt;branch&gt;/&lt;version&gt;]  切换分支</li>
<li>[-b &lt;localnewbranchname&gt; &lt;remotenewbranchname&gt;] 创建本地和远程分支并切换，本地与远程分支相关联</li>
</ol>
</li>
<li>git remote
<ol>
<li>[-v] 列出远程仓库</li>
<li>[add &lt;Repositoryname&gt; &lt;url&gt;] 添加远程仓库</li>
<li>[remane &lt;oldRepositoryname&gt; &lt;newRepositoryname&gt;] 修改仓库本地名称</li>
<li>[show &lt;remoteRepository&gt;] 查看远程仓库信息</li>
<li>[remove &lt;remotebranch&gt;] 移除远程仓库</li>
</ol>
</li>
<li>git fetch
<ol>
<li>[&lt;remoteBranch&gt;] 从远程仓库抓取</li>
</ol>
</li>
<li>git push
<ol>
<li>[&lt;Repositoryname&gt; &lt;branch&gt; ] 推送到远程分支</li>
<li>[&lt;Repository&gt; &lt;tagname&gt;/–tags] 推送标签/所有标签</li>
<li>[&lt;Repository&gt; --delete &lt;branch&gt;] 删除远程分支</li>
<li>[-u &lt;remote&gt; --all]  本地的仓库和远程仓库进行关联</li>
<li>[–set-upstream origin main] 将本地分支与远程分支关联</li>
</ol>
</li>
<li>git pull
<ol>
<li>[&lt;Repositoryname&gt; &lt;branch&gt; ] 拉取到本地分支并合并</li>
</ol>
</li>
<li>git tag
<ol>
<li>列出已有的标签</li>
<li>[-l &lt;通配符&gt;] 查询某些对应标签</li>
<li>[&lt;version&gt;] 轻量标签（提交校验和存储到一个文件中）</li>
<li>[-a &lt;version&gt; -m &lt;comment&gt;] 创建附注标签（数据库中的一个完整对象， 可以被校验）</li>
<li>[-d] 删除标签</li>
</ol>
</li>
<li>git show
<ol>
<li>标签信息和与之对应的提交信息</li>
</ol>
</li>
<li>git restore
<ol>
<li>[&lt;filename&gt;] 丢弃工作区修改</li>
<li>[–staged &lt;filename&gt;] 暂存区修改放回工作区</li>
</ol>
</li>
<li>git merge
<ol>
<li>[&lt;branch&gt;] 合并当前分支到branch分支</li>
</ol>
</li>
<li>git branch
<ol>
<li>[-d &lt;branchname&gt;] 删除分支</li>
<li>[-v] 每个分支的最后一次提交</li>
<li>[-vv] 跟踪信息</li>
<li>(–set-upstream-to=&lt;upstream&gt; | -u &lt;upstream&gt;) [&lt;branchname&gt;] 跟踪上游分支</li>
<li>[–merged --no-merged] 合并/未合并到当前分支的其他分支</li>
</ol>
</li>
<li>git stash
<ol>
<li>贮藏工作</li>
<li>[list] 列出所有贮藏</li>
<li>[apply] 恢复贮藏</li>
</ol>
</li>
<li>git rebase
<ol>
<li>[&lt;basebranch&gt; &lt;topicbranch&gt;] 变基</li>
</ol>
</li>
</ol>
<h3 id="忽略"><a class="markdownIt-Anchor" href="#忽略"></a> 忽略</h3>
<p>.gitignore 正则表达式：<a href="https://github.com/github/gitignore">官方样例文件</a></p>
<h2 id="chapter-3-分支"><a class="markdownIt-Anchor" href="#chapter-3-分支"></a> Chapter 3 分支</h2>
<blockquote>
<p>相关命令合并到 Chapter2 中</p>
</blockquote>
<ol>
<li>Git 中 HEAD是一个指针，指向当前工作位置</li>
<li>git mergetool 图形化冲突解决工具</li>
<li>有 Git 特性演化出的开发工作流：长期分支、主题分支</li>
</ol>
<h3 id="变基"><a class="markdownIt-Anchor" href="#变基"></a> 变基</h3>
<p>如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作。</p>
<p>工作原理：提取&lt;topicbranch&gt;内的修改并存为临时文件，然后将HEAD指向&lt;basebranch&gt;，最后以此将之前另存为临时文件的修改依序应用</p>
<h2 id="chapter-6-github"><a class="markdownIt-Anchor" href="#chapter-6-github"></a> Chapter 6 GitHub</h2>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>版本管理</tag>
      </tags>
  </entry>
  <entry>
    <title>ESConv</title>
    <url>/2023/Towards%20Emotional%20Support%20Dialog%20Systems/</url>
    <content><![CDATA[<p><strong>Title:</strong> Towards Emotional Support Dialog Systems</p>
<span id="more"></span>
<h1 id="论文速览"><a class="markdownIt-Anchor" href="#论文速览"></a> 论文速览</h1>
<ul>
<li>Abstract
<ul>
<li>本文关注于情感支持对话，提供了一个带策略的情绪支持数据集</li>
</ul>
</li>
<li>Introduction
<ul>
<li>情感支持应用广泛</li>
<li>情绪支持数据集应该包括exploration、understand、suggestion三个过程，还包括有用户的情绪强度变化</li>
<li>目前的研究模型中没有具体有效的情绪支持方法；采集数据集时需要训练有素的支持者</li>
<li>ESC框架：三个阶段，多种策略；众包做数据集；在情绪支持方面有提升</li>
</ul>
</li>
<li>Related Work
<ul>
<li>移情、同感对话</li>
<li>情绪支持的数据集</li>
<li>情绪支持对话
<ul>
<li>任务定义</li>
<li>ESC框架
<ul>
<li>三个阶段：探索、理解、建议</li>
<li>八种策略</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Data Collection
<ul>
<li>获取数据集的方法</li>
</ul>
</li>
<li>Data Characteristics
<ul>
<li>数据展示</li>
</ul>
</li>
<li>Experiments
<ul>
<li>基准模型：BlenderBot、DialoGPT</li>
<li>模型变种：不带策略：Vanilla；带策略：Random、Joint、Oracle</li>
<li>评估指标：PPL、B-2、R-L、Extrema</li>
<li>实验结果：
<ul>
<li>带策略的Oracle优于不带策略的Vanilla</li>
<li>带策略的Oracle稍微弱于不带策略的Vanilla，因为一旦策略预测错误，respond会完全不同</li>
<li>BlenderBot 变体始终比 DialoGPT 变体表现更好</li>
</ul>
</li>
<li>人类互动评价结果：
<ul>
<li>微调后ES能力提升</li>
<li>带策略微调后能更加适合用户需求</li>
<li>正确的策略更重要</li>
</ul>
</li>
</ul>
</li>
<li>Conclusion
<ul>
<li>三个阶段、多种策略、ESConv</li>
<li>道德评估</li>
</ul>
</li>
</ul>
<h1 id="解决了什么问题"><a class="markdownIt-Anchor" href="#解决了什么问题"></a> 解决了什么问题</h1>
<ol>
<li>目前的对话系统没有针对情感支持的任务和语料库，因此ESC方向还没有被探索到，对话场景中缺乏情感支持。</li>
<li>情感支持（ES）旨在减少个人的情绪困扰，帮助他们理解和应对所面临的挑战。目前的模型大都只能表示共情而不能解决问题。</li>
<li>通过社交而不是专业咨询的方式提供情感支持。</li>
</ol>
<h1 id="怎么解决的该方法的优势"><a class="markdownIt-Anchor" href="#怎么解决的该方法的优势"></a> 怎么解决的/该方法的优势</h1>
<ol>
<li>基于Hill的帮助技能理论，提出了ESC框架
<ol>
<li>情感支持过程
<ol>
<li>理解遇到的困难，exploration</li>
<li>表达理解和同情，insight/comforting</li>
<li>提出解决问题的方法，action</li>
</ol>
</li>
</ol>
</li>
<li>构建ESConv数据集，有丰富的注释（支持策略）
<ol>
<li>每个聊天会都会标记：
<ol>
<li>问题类别</li>
<li>用户情绪类别</li>
<li>用户情绪强度</li>
<li>遇到困难的简介</li>
</ol>
</li>
</ol>
</li>
<li>ESC系统
<ol>
<li>选择支持策略，生成策略约束Respond</li>
<li>情绪状态建模，跟踪用户情绪变化【待分析】</li>
<li>提出了评估ES实验效果的新方法</li>
</ol>
</li>
</ol>
<h1 id="有什么创新点"><a class="markdownIt-Anchor" href="#有什么创新点"></a> 有什么创新点</h1>
<h1 id="实验结果好在哪里怎么证明的"><a class="markdownIt-Anchor" href="#实验结果好在哪里怎么证明的"></a> 实验结果好在哪里，怎么证明的</h1>
<h1 id="相关工作分析"><a class="markdownIt-Anchor" href="#相关工作分析"></a> 相关工作分析</h1>
<ol>
<li>表达情感
<ol>
<li>ECM：情感对话，可以生成情感反应。有情商而不只是智商</li>
<li>ES：有情绪支持的能力，可以减少用户情绪困扰</li>
</ol>
</li>
<li>共情能力
<ol>
<li>反应出同情心，不能做情绪支持</li>
</ol>
</li>
<li>数据集
<ol>
<li>数据集中的对话短，不适合ES任务</li>
</ol>
</li>
<li>ESC系统
<ol>
<li>大多研究都人为预先规定好的规则和回复词典</li>
</ol>
</li>
</ol>
<h1 id="可以提升的地方"><a class="markdownIt-Anchor" href="#可以提升的地方"></a> 可以提升的地方</h1>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>情绪支持对话</tag>
      </tags>
  </entry>
  <entry>
    <title>如何保持专注</title>
    <url>/2024/Stay-Focused/</url>
    <content><![CDATA[<p>磨刀不误砍柴工，弄明白如何做事比糊里糊涂的做更重要。当下的目标是通过不断<strong>实践试错</strong>并<strong>总结纠错</strong>，从而找到最适合我的高效专注的做事方法。在此，再以高中的座右铭激励自己：当你觉得为时已晚的时候，恰恰是最早的时候。从学生变成社会人、从孩子变成家庭支柱、从做事的变成管人的（总会有那天的啦），我还有很多要改进要学习的地方（如何清楚明确的表达自己的工作内容，如何高效明确的和别人沟通），这些变化不是为了适应社会的表演，而是成年人的责任。<s>（tmd这文字像是初中生写出来的，文化沙漠了属于是，有时间还是得多看看书捏）</s></p>
<blockquote>
<p>Thought is already is late, exactly is the earliest time.</p>
</blockquote>
<h1 id="启动"><a class="markdownIt-Anchor" href="#启动"></a> 启动</h1>
<p>布置好工作环境，安排好工作内容，让自己发自内心得希望把事情完成。</p>
<ul>
<li><strong>早起，立即开始工作</strong>。早起会立即给自己一个潜意识的信号，让自己在那天努力工作。</li>
<li><strong>制定一个行动计划</strong>。用 10 分钟来筹划接下来的几个小时要做的事情，让事情可以推动自己前进。</li>
<li><strong>提前完成一连串的工作</strong>。清晨就处理完当天最紧要的工作，白天的时间就会显得从容，这也会产生积极的启动，这将持续一整天。</li>
</ul>
<h1 id="无干扰休息"><a class="markdownIt-Anchor" href="#无干扰休息"></a> 无干扰休息</h1>
<p>休息可以帮助自己以新的方式思考问题，可以清醒头脑，从而重新集中注意力。无干扰的休息意味着休息不会扼杀你的动力，这样你就可以重新振作起来，而不会陷入拖延的弯路。</p>
<ul>
<li><strong>避免参与式的休息</strong>。短视频，游戏，微信等会占据头脑的东西都会打断做事的势头。</li>
<li><strong>专注于放松</strong>。走一小段路、喝一杯水或伸展身体都是不错的选择，可以很容易地从休息中抽身出来回去工作。</li>
</ul>
<p>休息不是为了玩得开心，这才是真正休息的目的。休息是关于战略性地恢复你的能量和注意力，以重新处理手头的工作。把电视、游戏和娱乐活动留给晚上可以无愧疚地放松的时候。</p>
<h1 id="积极工作"><a class="markdownIt-Anchor" href="#积极工作"></a> 积极工作</h1>
<p>被动任务比主动任务更难集中注意力。改变这种状况的关键是，或者。</p>
<ul>
<li><strong>使任务处于活动状态</strong>。将被动学习任务转换为主动学习任务，如写提纲、记录重点。</li>
<li><strong>穿插活动任务</strong>。将被动学习与主动任务穿插在一起，以定期提高注意力，如表达自己见解、用自己的话复述一遍。</li>
</ul>
<blockquote>
<p><strong><a href="https://www.youtube.com/watch?v=FrNqSLPaZLc">Feynman 学习法</a></strong></p>
<p>Step1: choose your concept【写下你要学习的概念】</p>
<p>Step2: Pretend You’re Teaching the ldea to a New Student【假象你在教一位不懂这件事情的人这个概念，尝试将这件事情说明白】</p>
<p>Step3: If You Get Stuck, Go Back to the Book【如果你在这个过程中遇到了困难，回到课本和视频中进一步学习】</p>
<p>Step4: Simplify and Create Analogies【尝试精简自己的解释，并将其与其他概念做类比，从而更好地理解概念】</p>
<p>总结一下，当你可以教会某人一个ta完全不懂的概念的时候，说明你真正掌握了这个概念</p>
</blockquote>
<h1 id="固定日程安排"><a class="markdownIt-Anchor" href="#固定日程安排"></a> 固定日程安排</h1>
<p>努力工作的最好方式就是拥有生活</p>
<ul>
<li>
<p><strong>保证休息</strong>，应对大量工作任务的办法是保证自己有休息时间。如果你白天不好好工作，却逼迫自己整夜学习的话，你很容易就会筋疲力尽的。无论压力再大任务再多，都要保证休息时间，一颗清醒的大脑决定了工作的质量。</p>
</li>
<li>
<p>使用时间分块法或每周/每日目标法，将工作和生活清晰地分离开，好好工作好好玩。</p>
</li>
</ul>
<blockquote>
<p><strong>时间分块法</strong></p>
<p>将一天分成更小的时间分块法。在每一段时间里，专注于一项任务或一组相似的任务。其重点是<strong>规划出需要完成的任务</strong>，然后<strong>划分特定的时间段专注完成这些任务</strong>。</p>
<p>当你把一整天分成时间段后，它会让你专注于任务，并限制其他人占用你的时间。</p>
<p>时间分块法让你每天都有一个要完成的具体任务的时间表，而不是遵循一个不断扩大的待办事项列表，你只需要关注于当下应该做的事情。</p>
</blockquote>
<p><a href="https://www.scotthyoung.com/blog/2011/11/28/focus-without-caffeine/">Refer</a></p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>保持专注</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC</title>
    <url>/JUC/</url>
    <content><![CDATA[<h1 id="threadlocal"><a class="markdownIt-Anchor" href="#threadlocal"></a> ThreadLocal</h1>
<p>每一个线程都有自己的专属本地变量，通过空间换时间的方式避免并发下线程安全问题</p>
<p><strong>原理</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">            Object value;</span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="built_in">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存放数据</span></span><br><span class="line">        <span class="keyword">private</span> Entry[] table;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体结构图</p>
<style>.syborgdiwlps{zoom:50%;}</style><img data-src="/JUC/v2-ce5b8a32cd1245c7c8af5fc15ffcc39f_1440w.webp" class="syborgdiwlps" alt="img">
<p>引用关系图</p>
<style>.obefihmfhpxq{zoom:50%;}</style><img data-src="/JUC/v2-6875e31029e2c834cce5feb04bc22474_1440w.webp" class="obefihmfhpxq" alt="img">
<h2 id="重点问题"><a class="markdownIt-Anchor" href="#重点问题"></a> 重点问题</h2>
<p><strong>Entry的key为什么设计成弱引用？</strong></p>
<p>ThreadLocal 变量生命周期结束后，ThreadLocal 对象就可以被回收；</p>
<p><strong>ThreadLocal为什么会导致内存泄露，如何解决？</strong></p>
<p>虽然 get、set 或 remove 方法会回收 key 为 null 的 value 值，但是如果没有调用这些方法，Entry和ThreadLocalMap将会长期存在下去，会导致内存泄露；</p>
<p>使用完ThreadLocal对象之后，调用remove方法；</p>
<p><strong>ThreadLocal是如何定位数据的？</strong></p>
<p><code>int i = key.threadLocalHashCode &amp; (len-1);</code></p>
<p>如果有冲突就通过线性探测再散列，直到 table[i] = null；</p>
<blockquote>
<p>其他Hash冲突解决方法：开放寻址法（再散列）、拉链法</p>
</blockquote>
<p><strong>ThreadLocal是如何扩容的？</strong></p>
<ul>
<li>size&gt;threshold</li>
</ul>
<p><strong>父子线程如何共享数据？</strong></p>
<p>InheritableThreadLocal</p>
<p>init 方法会将 父线程中往 ThreadLocal 设置的值，拷贝一份到子线程中；</p>
<p><strong>ThreadLocal 变量为什么建议要定义成static的？</strong></p>
<p>将 ThreadLocal 定义为 static 可以确保所有线程都访问同一个 ThreadLocal 实例，但它们各自存储的数据是独立的；</p>
<p>确保它们的生命周期与线程的生命周期一致，而不是与类的实例的生命周期一致；</p>
<p><strong>使用InheritableThreadLocal时，如果父线程中重新set值，在子线程中能够正确的获取修改后的新值吗？</strong></p>
<p>不会影响到已经存在的子线程中 InheritableThreadLocal 的值。子线程将保持它在创建时从父线程中继承的原始值。</p>
<h1 id="volatile"><a class="markdownIt-Anchor" href="#volatile"></a> Volatile</h1>
<ul>
<li>保证变量的可见性，但无法在多线程读写变量时保证操作原子性</li>
<li>防止 JVM 的指令重排序：对该变量读写时，会插入特定的内存屏障</li>
</ul>
<blockquote>
<p>也可以采用**<code>Unsafe</code> 类的内存屏障**实现 防止指令重排序 的效果</p>
</blockquote>
<h1 id="jmm"><a class="markdownIt-Anchor" href="#jmm"></a> JMM</h1>
<p>Java 内存模型定义了 Java 程序中各种变量（主内存和线程工作内存）的访问规则。保证多线程环境下数据的一致性和可见性。</p>
<p><strong>双重校验锁实现对象单例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//类对象加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java并发</tag>
      </tags>
  </entry>
  <entry>
    <title>RAG架构和Langchain框架</title>
    <url>/LLM-RAG-Langchain/</url>
    <content><![CDATA[<p>当下，微调（Fine-Tuning）和检索增强生成（Retrieval-Augmented Generation，简称RAG）是大型语言模型（LLM）与专有数据之间融合贯通的最主流的两种方法。微调对数据集和硬件要求高，主要还是学习检索增强生成（RAG架构）方向</p>
<h1 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h1>
<p>RAG 是一种使用额外数据增强 LLM 知识的技术，是 2020 年发表的论文 <a href="https://arxiv.org/abs/2005.11401">面向知识密集型 NLP 任务的检索增强生成</a>中提出的新思想。LLM 通过外部知识源获取额外信息，从而生成更准确、更符合上下文的答案，并减少错误信息（或称为“幻觉”，即模型对用户意图的误解或在处理特定指示时产生了不准确的推断）。典型的 RAG 应用程序有两个主要组件：</p>
<ul>
<li>索引：用于引入源数据并对其进行<strong>索引</strong>的管道，通常离线运行。
<ul>
<li>加载：将数据库中的大段文本读入系统</li>
<li>拆分：因为大块数据更难搜索，并且不适合模型的有限上下文窗口，因此需要拆分数据。</li>
<li>存储：采用向量数据库和索引存储数据</li>
</ul>
</li>
<li>检索和生成：实际的 RAG 链，它在运行时接受用户查询并从索引中检索相关数据，然后将其传递给模型。
<ul>
<li>检索：将用户的查询通过嵌入模型转化为向量，以便与向量数据库中的其他上下文信息进行比对。通过这种相似性搜索，可以找到向量数据库中最匹配的前 k 个数据。</li>
<li>生成：将用户的查询和检索到的额外信息一起嵌入到一个预设的提示模板中，这个经过检索增强的提示内容会被输入到大语言模型 (LLM) 中，以生成所需的输出。</li>
</ul>
</li>
</ul>
<p>从原始数据到答案最常见的完整序列如下所示：</p>
<img data-src="/LLM-RAG-Langchain/x7ta8v77.png" class="" title="x7ta8v77">
<h1 id="langchain"><a class="markdownIt-Anchor" href="#langchain"></a> Langchain</h1>
<p>LangChain 采用组件化设计的思想，将语言模型开发分为多个子任务：对话历史 Memory、提示工程 Prompt、输出解析 Parase、LLM链 Chain、索引 Indexes、代理 Agents。Langchain 模块化设计的中心思想是提升代码维护、扩展和重用的能力，可以快速开发多轮提示以及解析输出的应用。</p>
<h2 id="模型链-chain"><a class="markdownIt-Anchor" href="#模型链-chain"></a> 模型链 Chain</h2>
<blockquote>
<p>链（Chains）通常将大语言模型（LLM）与其他组件组合在一起来构建更复杂的链。</p>
</blockquote>
<p>Chain 基类是所有 Chain 对象的起点，处理输入、输出、历史和回调等功能，支持同步和异步调用，内部组件也可以通过回调进行交互；</p>
<p>自定义 Chain 需要继承 Chain 基类，实现 _call/_acall 方法定义调用逻辑；</p>
<h2 id="对话历史-memory"><a class="markdownIt-Anchor" href="#对话历史-memory"></a> 对话历史 Memory</h2>
<p>根据需求可以将历史存储在 SQLite、qdrant、本地内存等地方，下面代码将历史存储在缓存中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.memory <span class="keyword">import</span> ConversationBufferMemory</span><br><span class="line">memory = ConversationBufferMemory(</span><br><span class="line">    memory_key=<span class="string">&quot;history&quot;</span>, <span class="comment"># 与 prompt 的输入变量保持一致。</span></span><br><span class="line">    return_messages=<span class="literal">True</span> <span class="comment"># 将以消息列表的形式返回聊天记录，而不是单个字符串</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="提示工程-prompt"><a class="markdownIt-Anchor" href="#提示工程-prompt"></a> 提示工程 Prompt</h2>
<p>Prompt 很少是写明不变的，通常从多个组件构建而成的。 PromptTemplate 负责构建这个输入。</p>
<p><strong>输出解析 Parase</strong> 是提示工程的一种：</p>
<ul>
<li><code>get_format_instructions() -&gt; str</code>：方法，返回一个包含有关如何格式化语言模型输出的字符串，即提示 Prompt。</li>
<li><code>parse(str) -&gt; Any</code>：方法，接受一个字符串（假定为语言模型的响应）并将其解析为某个结构。</li>
<li><code>parse_with_prompt(str) -&gt; Any</code>：一个方法，它接受一个字符串（假设是语言模型的响应）和一个提示（假设是生成这样的响应的提示），并将其解析为某种结构。提示在此大多数情况下是为了提供信息以便 OutputParser 重新尝试或以某种方式修复输出。</li>
</ul>
<h2 id="索引-indexes"><a class="markdownIt-Anchor" href="#索引-indexes"></a> 索引 Indexes</h2>
<p>结构化文档，以便 LLM 可以与外部文档交互。 LangChain有许多模块可帮助您加载、结构化、存储和检索文档。<a href="https://yeqiuo.github.io/LLM%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/#%E7%A7%81%E6%9C%89%E6%95%B0%E6%8D%AE%E7%9F%A5%E8%AF%86%E5%BA%93">详见</a></p>
<h2 id="代理-agents"><a class="markdownIt-Anchor" href="#代理-agents"></a> 代理 Agents</h2>
<p>代理使用LLM来确定采取哪些行动以及顺序。</p>
<ul>
<li>使用工具并观察其输出</li>
<li>生成相应返回给用户</li>
</ul>
]]></content>
      <categories>
        <category>大语言模型应用开发</category>
      </categories>
      <tags>
        <tag>RAG架构</tag>
      </tags>
  </entry>
  <entry>
    <title>LLM应用开发</title>
    <url>/LLM-Application/</url>
    <content><![CDATA[<p>实验室项目对话模块的主要工作和创新点，先大致记录一下思路，后续慢慢完善</p>
<h1 id="何为llm应用开发"><a class="markdownIt-Anchor" href="#何为llm应用开发"></a> 何为LLM应用开发</h1>
<p>网上不少人认为，与其去做 Prompt 应用不如去提升 LLM 的智能，Prompt 应用对于大语言模型能力提升的作用有限。但我不以为然，获得 Prompt 的加持之后，LLM 可以<strong>应用现实生活的所有工具</strong>；可以<strong>按步骤正确处理一个复杂问题</strong>（因为 LLM 不同于人类对话，只有构造出非常详细且周密的过程约束，才能得到最正确的答案，不然会出现“幻觉”现象）；可以引导 <strong>LLM 自我规划</strong>（下文的长文本对话），目前 Prompt 最常应用在 <code>Dynamic Few-Shot Examples</code> 领域中，可以快速定位与 Query 最相关的小样本，不使不相关的内容分散 LLM 的注意力，而不只局限于“聊天机器人”和“搜索引擎”这类看似没啥么太大用处的名头。</p>
<p>一言以蔽之，应用开发就是将 LLM 聪明的大脑装上可随时替换的手脚、五官和前额叶、海马体，它可以变成任何人，使用任何工具。</p>
<h1 id="长文本对话"><a class="markdownIt-Anchor" href="#长文本对话"></a> 长文本对话</h1>
<h2 id="问题背景"><a class="markdownIt-Anchor" href="#问题背景"></a> 问题背景</h2>
<p>虽然模型都支持32k的上下文，但是无法要求模型一次性输出超长文本。若给模型输入：“给我讲讲中国五千年历史，字数不得少于五千”，是无法得到想要的回答，模型最多生成一两千的字，而且由于所有输出都是一次返回的，上下文逻辑和内容都不尽人意。</p>
<h2 id="解决思路"><a class="markdownIt-Anchor" href="#解决思路"></a> 解决思路</h2>
<p>先调用模型生成一次大纲，再拆分大纲分批次输入模型，每次模型的输出只需要关注一小块内容，因此可以获得更优结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">OutlinePrompt = ChatPromptTemplate.from_template(<span class="string">f&#x27;请根据<span class="subst">&#123;query&#125;</span>，按照以下格式对问题提炼目录。回答内容尽量简短\n \</span></span><br><span class="line"><span class="string">            开始生成大纲:\n \</span></span><br><span class="line"><span class="string">            1. XXX\n    1.1xxx 1.2xxx 1.3xxx ...\n  \</span></span><br><span class="line"><span class="string">            2. XXX\n    2.1xxx 2.2xxx 2.3xxx ...\n  \</span></span><br><span class="line"><span class="string">            .......\n&#x27;</span>)</span><br><span class="line">chain = LLMChain(prompt=OutlinePrompt, llm=model1, memory=<span class="literal">None</span>, verbose=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>由于需要<strong>结构化解析</strong>输出结果并<strong>链式调用</strong>模型扩写子论点，采用结构化输出解析器 <code>from langchain.output_parsers import StructuredOutputParser, ResponseSchema</code> 和模型调用链 <code>from langchain.chains import SimpleSequentialChain, SequentialChain</code> ，该方法相较于直接 for 循环调用模型更加麻烦，但是便于整体项目的开发、调用和维护。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chat_prompt = PromptTemplate.from_template(<span class="string">f&#x27;请以<span class="subst">&#123;title&#125;</span>的<span class="subst">&#123;contexts&#125;</span>为主要内容，帮我扩写到<span class="subst">&#123;num&#125;</span>字&#x27;</span>)</span><br><span class="line">combined_prompt = PromptTemplate.from_template(<span class="string">f&#x27;写一段过渡段，从<span class="subst">&#123;title&#125;</span>自然过渡到<span class="subst">&#123;next_title&#125;</span>，内容简短&#x27;</span>)</span><br><span class="line">chat_chain = LLMChain(llm=llm, prompt=chat_prompt, output_key=<span class="string">&quot;chat&quot;</span>)</span><br><span class="line">combined_chain = LLMChain(llm=llm, prompt=combined_prompt, output_key=<span class="string">&quot;combined&quot;</span>)</span><br><span class="line">single_chain = SequentialChain(</span><br><span class="line">    chains=[chat_chain, combined_chain], </span><br><span class="line">    input_variables=[<span class="string">&quot;title&quot;</span>, <span class="string">&quot;contexts&quot;</span>, <span class="string">&quot;num&quot;</span>, <span class="string">&quot;next_title&quot;</span>],</span><br><span class="line">    output_variables=[<span class="string">&quot;chat&quot;</span>, <span class="string">&quot;combined&quot;</span>],</span><br><span class="line">    verbose=<span class="literal">True</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>目前还是通过 for 循环遍历大纲，后续考虑采用路由链 <code>LLMRouterChain</code>，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">router_prompt = PromptTemplate(</span><br><span class="line">    template=router_template,</span><br><span class="line">    input_variables=[<span class="string">&quot;input&quot;</span>],</span><br><span class="line">    output_parser=RouterOutputParser(),</span><br><span class="line">)</span><br><span class="line">chain = MultiPromptChain(</span><br><span class="line">    router_chain=router_chain,    <span class="comment"># 路由链路</span></span><br><span class="line">    destination_chains=destination_chains,   <span class="comment"># 目标链路（LLmChain 数组）</span></span><br><span class="line">    default_chain=default_chain,      <span class="comment"># 默认链路</span></span><br><span class="line">    verbose=<span class="literal">True</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h1 id="私有数据知识库"><a class="markdownIt-Anchor" href="#私有数据知识库"></a> 私有数据知识库</h1>
<h2 id="问题背景-2"><a class="markdownIt-Anchor" href="#问题背景-2"></a> 问题背景</h2>
<p>离线私有数据不能直接作为语料库训练模型，LLM 需要具有基于私有数据返回的能力。</p>
<h2 id="解决思路-2"><a class="markdownIt-Anchor" href="#解决思路-2"></a> 解决思路</h2>
<p>知识库系统要包括文档加载、切分、存储、检索和存储聊天记录模块，具体通过向量表征 <code>Embeddings</code> 和向量存储 <code>Vector Store</code> 实现</p>
<ul>
<li>文本表征是对文本语义的向量表征，相似内容的文本具有相似的表征向量。这使我们可以在向量空间中比较文本的相似性。</li>
<li>向量数据库<code>Vector Database</code>用来存储文档的文本块。对于给定的文档，我们首先将其分成较小的文本块<code>chunks</code>，然后获取每个小文本块的文本表征，并将这些表征储存在向量数据库中。这个流程正是创建索引<code>index</code>的过程。将文档分成小文本块的原因在于我们可能无法将整个文档传入语言模型进行处理。</li>
</ul>
<img data-src="/LLM-Application/image-20240424102449161.png" class="" title="image-20240424102449161">
<p>Langchain 中文本分割器 <code>langchain.text_splitter</code> 都根据 chunk_size(块大小) 和 chunk_overlap(块与块之间的重叠大小) 进行分割</p>
<ul>
<li>chunk_size 指每个块包含的字符或 Token（如单词、句子等）的数量</li>
<li>chunk_overlap 指两个块之间共享的字符数量，用于保持上下文的连贯性，避免分割丢失上下文信息</li>
</ul>
<style>.mihpkxerwxui{zoom:50%;}</style><img data-src="/LLM-Application/image-20240424102824838.png" class="mihpkxerwxui" alt="langchain.text_splitter">
<p><strong>Q1</strong>：如何加强搜索结果的多样性？</p>
<p><strong>A1</strong>：最大边际相关性 <code>Maximum marginal relevance</code> ，过滤搜索结果中相似度很高的文档，可以同时满足查询的相关性和结果的多样性</p>
<p><strong>Q2</strong>：如何将查询限定在某些文档中？如 LLM 在查询时可能同时查找 浙江省财政报告、江苏省财政报告，但问题只与浙江省相关</p>
<p><strong>A2</strong>：通过 <code>SelfQueryRetriever</code> 参数 <code>document_content_description</code> 指定元素的不同字段（source）以及它们对应的位置（page）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">metadata_field_info_chinese = [</span><br><span class="line">    AttributeInfo(</span><br><span class="line">        name=<span class="string">&quot;source&quot;</span>,</span><br><span class="line">        description=<span class="string">&quot;文章来源于 `index-浙江省财政报告`, `index-江苏省财政报告` 的其中之一&quot;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="string">&quot;string&quot;</span>,</span><br><span class="line">    ),</span><br><span class="line">    AttributeInfo(</span><br><span class="line">        name=<span class="string">&quot;page&quot;</span>,</span><br><span class="line">        description=<span class="string">&quot;文章中的哪一页&quot;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="string">&quot;integer&quot;</span>,</span><br><span class="line">    ),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>Q3</strong>：如何通过过获取到的文档得到 LLM 响应</p>
<p><strong>A3</strong>：采用 检索式问答链 <code>RetrievalQA</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">template = <span class="string">&quot;&quot;&quot;使用以下上下文片段来回答最后的问题。如果你不知道答案，只需说不知道，不要试图编造答案。答案最多使用三个句子。尽量简明扼要地回答。在回答的最后一定要说&quot;感谢您的提问！&quot;</span></span><br><span class="line"><span class="string">&#123;context&#125;</span></span><br><span class="line"><span class="string">问题：&#123;question&#125;</span></span><br><span class="line"><span class="string">有用的回答：&quot;&quot;&quot;</span></span><br><span class="line">QA_CHAIN_PROMPT = PromptTemplate.from_template(template)</span><br><span class="line"><span class="comment"># RetrievalQA 内部使用了 QA_CHAIN_PROMPT</span></span><br><span class="line">qa_chain = RetrievalQA.from_chain_type( </span><br><span class="line">    llm,</span><br><span class="line">    retriever=vectordb.as_retriever()</span><br><span class="line">)</span><br><span class="line">result = qa_chain(&#123;<span class="string">&quot;query&quot;</span>: question&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>Q4</strong>：如果文档太多，无法将它们全部适配到上下文窗口中怎么办？</p>
<p><strong>A4</strong>：采用 <code>MapReduce</code>，首先将每个独立的文档单独发送到语言模型以获取原始答案。然后，将答案通过最终对语言模型的一次调用组合成最终的答案</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">qa_chain_mr = RetrievalQA.from_chain_type(</span><br><span class="line">    llm,</span><br><span class="line">    retriever=vectordb.as_retriever(),</span><br><span class="line">    chain_type=<span class="string">&quot;map_reduce&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>如果信息分布在两个文档之间，无法在同一上下文中获取到所有的信息，也就没法给出正确答案。为解决这个问题，可以采用 <code>Refine 检索式问答链</code> ，Refine 文档链类似于 MapReduce 链，对于每一个文档，会调用一次 LLM，但有所改进的是，我们每次发送给 LLM 的最终提示是一个序列，这个序列会将先前的响应与新数据结合在一起，并请求得到改进后的响应。这种方法类似于 RNN，我们增强了上下文，从而解决信息分布在不同文档的问题。</p>
<p><a href="https://github.com/chatchat-space/Langchain-Chatchat">Github 参考项目链接</a></p>
<h1 id="多场景知识图谱"><a class="markdownIt-Anchor" href="#多场景知识图谱"></a> 多场景知识图谱</h1>
<h2 id="问题背景-3"><a class="markdownIt-Anchor" href="#问题背景-3"></a> 问题背景</h2>
<p>参考 Langchain 外部知识库开源项目的 <a href="https://github.com/chatchat-space/Langchain-Chatchat/issues/1583">Issue</a>，可以发现，由于单一的文档切分方法和已训练好的分词器切分方法（项目中用的是 bge-large-zh-v1.5 模型）并不能理解场景相关的概念，也就无法构建有针对性的对话知识库，因此简单的导入外部数据无法实现多场景需求。</p>
<h2 id="解决思路-3"><a class="markdownIt-Anchor" href="#解决思路-3"></a> 解决思路</h2>
<p>针对私有数据的多场景对话需求，可以构建并应用不同场景的知识图谱。</p>
<img data-src="/LLM-Application/image-20240424140419971.png" class="" title="image-20240424140419971">
<p>基于 用户输入Query 和 图数据库 Schema 构建 Prompt，通过 LLM 获取简短、精要的实体和关系信息，后续再基于此生成对话响应。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.chains <span class="keyword">import</span> GraphCypherQAChain</span><br><span class="line"><span class="keyword">from</span> langchain.graphs <span class="keyword">import</span> Neo4jGraph</span><br><span class="line"></span><br><span class="line">graph = Neo4jGraph(</span><br><span class="line">    url=<span class="string">&quot;bolt://localhost:7687&quot;</span>, </span><br><span class="line">    username=<span class="string">&quot;neo4j&quot;</span>, </span><br><span class="line">    password=<span class="string">&quot;&quot;</span></span><br><span class="line">)</span><br><span class="line">chain = GraphCypherQAChain.from_llm(</span><br><span class="line">    model, graph=graph, verbose=<span class="literal">True</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>Langchain 底层针对图数据库对话的 Prompt</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CYPHER_GENERATION_TEMPLATE = <span class="string">&quot;&quot;&quot;Task:Generate Cypher statement to query a graph database.</span></span><br><span class="line"><span class="string">Instructions:</span></span><br><span class="line"><span class="string">Use only the provided relationship types and properties in the schema.</span></span><br><span class="line"><span class="string">Do not use any other relationship types or properties that are not provided.</span></span><br><span class="line"><span class="string">Schema:</span></span><br><span class="line"><span class="string">&#123;schema&#125;</span></span><br><span class="line"><span class="string">Note: Do not include any explanations or apologies in your responses.</span></span><br><span class="line"><span class="string">Do not respond to any questions that might ask anything else than for you to construct a Cypher statement.</span></span><br><span class="line"><span class="string">Do not include any text except the generated Cypher statement.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">The question is:</span></span><br><span class="line"><span class="string">&#123;question&#125;&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>Langchain 底层针对上下文问答的 Prompt</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CYPHER_QA_TEMPLATE = <span class="string">&quot;&quot;&quot;You are an assistant that helps to form nice and human understandable answers.</span></span><br><span class="line"><span class="string">The information part contains the provided information that you must use to construct an answer.</span></span><br><span class="line"><span class="string">The provided information is authoritative, you must never doubt it or try to use your internal knowledge to correct it.</span></span><br><span class="line"><span class="string">Make the answer sound as a response to the question. Do not mention that you based the result on the given information.</span></span><br><span class="line"><span class="string">If the provided information is empty, say that you don&#x27;t know the answer.</span></span><br><span class="line"><span class="string">Information:</span></span><br><span class="line"><span class="string">&#123;context&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Question: &#123;question&#125;</span></span><br><span class="line"><span class="string">Helpful Answer:&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="多轮对话"><a class="markdownIt-Anchor" href="#多轮对话"></a> 多轮对话</h1>
<p>采用 qdrant 向量库保存对话历史</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomQdrantMemory</span>(<span class="title class_ inherited__">BaseChatMemory</span>):</span><br><span class="line">    <span class="comment"># 访问数据库抽取最相关联的 message_limit 条数据</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buffer</span>(<span class="params">self, inputs: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]</span>) -&gt; <span class="type">List</span>[BaseMessage]:</span><br><span class="line">        chat_messages: <span class="type">List</span>[BaseMessage] = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> inputs:</span><br><span class="line">            <span class="keyword">return</span> chat_messages</span><br><span class="line">        hits = self.qdrant.search(</span><br><span class="line">            collection_name=self.conversation_id,</span><br><span class="line">            query_vector=self.encoder.encode(inputs[<span class="string">&#x27;input&#x27;</span>]).tolist(),</span><br><span class="line">            limit=self.message_limit,</span><br><span class="line">        )</span><br><span class="line">        hits = <span class="built_in">sorted</span>(hits, key=<span class="keyword">lambda</span> x:x.<span class="built_in">id</span>)</span><br><span class="line">        <span class="keyword">for</span> hit <span class="keyword">in</span> hits:</span><br><span class="line">            chat_messages.append(HumanMessage(content=hit.payload[<span class="string">&#x27;human&#x27;</span>]))</span><br><span class="line">            chat_messages.append(AIMessage(content=hit.payload[<span class="string">&#x27;assistant&#x27;</span>]))</span><br><span class="line">        curr_buffer_length = self.llm.get_num_tokens(get_buffer_string(chat_messages))</span><br><span class="line">        <span class="comment"># 如果超出模型最长上下文，则弹出最早的对话历史</span></span><br><span class="line">        <span class="keyword">if</span> curr_buffer_length &gt; self.max_token_limit:</span><br><span class="line">            pruned_memory = []</span><br><span class="line">            <span class="keyword">while</span> curr_buffer_length &gt; self.max_token_limit <span class="keyword">and</span> chat_messages:</span><br><span class="line">                pruned_memory.append(chat_messages.pop())</span><br><span class="line">                curr_buffer_length = self.llm.get_num_tokens(get_buffer_string(chat_messages))</span><br><span class="line">        <span class="keyword">return</span> chat_messages        </span><br></pre></td></tr></table></figure>
<h1 id="虚拟人设"><a class="markdownIt-Anchor" href="#虚拟人设"></a> 虚拟人设</h1>
<p>流程</p>
<ul>
<li>音视频上传
<ul>
<li>语音转文字 FFmpeg</li>
<li>【初始化时】声纹构建</li>
<li>语音转文字 Whisper</li>
<li>特征语料库构建</li>
</ul>
</li>
<li>语料 + Chroma 向量库相似度 + KNN 距离匹配</li>
<li>组成输入，LLM 响应结果</li>
</ul>
<p><a href="https://github.com/LC1332/Chat-Haruhi-Suzumiya">Github 参考项目链接</a></p>
<h1 id="python-notes"><a class="markdownIt-Anchor" href="#python-notes"></a> Python Notes</h1>
<p>def _call() 方法把这个类型的对象当作函数来使用</p>
]]></content>
      <categories>
        <category>LLM应用开发</category>
      </categories>
      <tags>
        <tag>Langchain</tag>
        <tag>向量数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/OS/</url>
    <content><![CDATA[<p><strong>进程和线程的区别</strong></p>
<p>线程是调度的基本单位，而进程则是资源拥有的基本单位。</p>
<ul>
<li>进程是资源（包括内存、打开的文件等）分配的最小单位，线程是 CPU 调度的最小单位；</li>
<li>进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈，线程之间共享地址空间和文件等资源；</li>
<li>线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；</li>
<li>线程能减少并发执行的时间和空间开销；</li>
</ul>
<p><strong>进程间通信方式</strong></p>
<p>匿名管道 / 命名管道</p>
<p>消息队列</p>
<p>共享内存+信号量</p>
<p>Socket</p>
<p>多线程竞争共享资源</p>
<p><strong>虚拟地址</strong></p>
<p>进程隔离</p>
<p>IO多路复用</p>
<p>select,poll,epoll</p>
]]></content>
      <categories>
        <category>八股文</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
</search>
